[
  {
    "objectID": "KeiryouKeizaigaku25/index.html",
    "href": "KeiryouKeizaigaku25/index.html",
    "title": "計量経済学2025 -高知工科大学",
    "section": "",
    "text": "この資料は、2025年高知工科大学経済マネジメント学群にて実施された集中講義「計量経済学」（高知工科大学・矢内先生と関西学院大学・宋先生）の授業を基に、藤井が再構成したものである。"
  },
  {
    "objectID": "KeiryouKeizaigaku25/index.html#理論資料",
    "href": "KeiryouKeizaigaku25/index.html#理論資料",
    "title": "計量経済学2025 -高知工科大学",
    "section": "理論資料",
    "text": "理論資料\n計量経済学講義ノート2025PDF"
  },
  {
    "objectID": "KeiryouKeizaigaku25/index.html#実践資料",
    "href": "KeiryouKeizaigaku25/index.html#実践資料",
    "title": "計量経済学2025 -高知工科大学",
    "section": "実践資料",
    "text": "実践資料\n計量経済学実習コード\n\n戻る\nトップページに戻る"
  },
  {
    "objectID": "Kyouikuseidoronn/America.html#チャータースクール",
    "href": "Kyouikuseidoronn/America.html#チャータースクール",
    "title": "アメリカの特色",
    "section": "チャータースクール",
    "text": "チャータースクール\n半官半民　国が金は出すが、カリキュラムは学校で決定できる\n全米のうち、9000/25000校がこれ　うち6000校が学力向上を重視\n公立中学校\n\nキップアカデミー（KIIP）\nヒスパニックなどが多い　低所得者層の子どもたちへの公立中学校\n「幸せを求める力」 を身に着ける\n勉強時間は通常比1.7倍　\nミニテストを行い、みんなで答え合わせ　→　自分で問題を出す 　宿題はミニテストのおさらい（毎日2－3時間かかる宿題）\n親は必ず宿題にサインをしなくてはならない　\n→生徒が主体的に勉強できる環境が出来上がる？\n最終確認テスト　寝転んでやっているくらい自由\nフィードバックが多いから成果が可視化されやすい\n一斉授業ではなく、個別最適な学びを自己進度学習で実施　先生は机間巡視して質問に答える\n先生は携帯の番号を教え、いつでも電話して質問できる\n親はメキシコからの移民で日雇い労働者　→息子が医学部進学へ\n不登校もほとんどいない\n\n小学校の方から深い学びをしている　 Ex) 関数や0の概念\n\nちゃんとそれぞれに夢がある\n→　地区の学校情報は全て見やすい形で開示し、自ら選択ができるように\n3Dアカデミー　：　KIIPのカリキュラムを導入\n子どもたちが「チャレンジできる」と思わせることが大切"
  },
  {
    "objectID": "Kyouikuseidoronn/America.html#本質",
    "href": "Kyouikuseidoronn/America.html#本質",
    "title": "アメリカの特色",
    "section": "本質",
    "text": "本質\n\n戻る\n教育制度論トップ\nトップページに戻る"
  },
  {
    "objectID": "Shizenchirigaku/4Nettai.html",
    "href": "Shizenchirigaku/4Nettai.html",
    "title": "４　各気候の特徴",
    "section": "",
    "text": "ケッペンの気候区分",
    "crumbs": [
      "Home",
      "地理学",
      "各気候の特徴"
    ]
  },
  {
    "objectID": "Shizenchirigaku/4Nettai.html#気候の特徴",
    "href": "Shizenchirigaku/4Nettai.html#気候の特徴",
    "title": "４　各気候の特徴",
    "section": "気候の特徴",
    "text": "気候の特徴\n地球表面の36％を占める。\n降水は、局所的に短時間に集中して強雨になることが多い。\n熱帯収束帯のかかり方によって、Af（年間を通じて収束下）、Am（季節的に収束下）に区分される。\n\n赤道付近では、亜熱帯高圧帯からの貿易風が卓越\n上昇気流が発生し、活発な雲が帯状に発生",
    "crumbs": [
      "Home",
      "地理学",
      "各気候の特徴"
    ]
  },
  {
    "objectID": "Shizenchirigaku/4Nettai.html#人の暮らし",
    "href": "Shizenchirigaku/4Nettai.html#人の暮らし",
    "title": "４　各気候の特徴",
    "section": "人の暮らし",
    "text": "人の暮らし\n\n住居\n\n湿気を防ぐため高床式住居　オセアニアでは、熱帯植物の葉や茎を使用して作られる。\n\n\n\n衣服\n\nインドのサリー、ガーナのケンテなど\n一枚の布を体に巻き付ける",
    "crumbs": [
      "Home",
      "地理学",
      "各気候の特徴"
    ]
  },
  {
    "objectID": "Shizenchirigaku/4Nettai.html#砂漠地域が分布する場所",
    "href": "Shizenchirigaku/4Nettai.html#砂漠地域が分布する場所",
    "title": "４　各気候の特徴",
    "section": "砂漠地域が分布する場所",
    "text": "砂漠地域が分布する場所\n中緯度高気圧帯の影響を受ける地域　Ex）サハラ砂漠、中東地域\n海洋から遠く離れた地域　Ex）ゴビ砂漠、タクラマカン砂漠\n沖合に寒流が流れ空気が冷却されて上昇気流が発生しにくい場所　Ex）アタカマ砂漠、ナミブ砂漠\n山脈の風下側　Ex）パタゴニア",
    "crumbs": [
      "Home",
      "地理学",
      "各気候の特徴"
    ]
  },
  {
    "objectID": "Shizenchirigaku/4Nettai.html#砂漠気候の特徴",
    "href": "Shizenchirigaku/4Nettai.html#砂漠気候の特徴",
    "title": "４　各気候の特徴",
    "section": "砂漠気候の特徴",
    "text": "砂漠気候の特徴\n降水量は1年を通じて少ない。地球の1/3は砂漠地帯に属する。相対湿度が低いため、気温の日較差が大きい（砂漠の土壌は日射の反射率が大きい）。\n乾燥指数（\\(AI\\)）：年平均降水量（\\(P\\)）\\(÷\\) 可能蒸発散量(\\(PET\\))\n\n極乾燥地域 \\(AI&lt;0.05\\)\n半湿潤地域 \\(0.50≦AI＜0.65\\)\n\nオアシス：砂漠土壌と岩盤の間に地下水が流下している場合に形成される",
    "crumbs": [
      "Home",
      "地理学",
      "各気候の特徴"
    ]
  },
  {
    "objectID": "Shizenchirigaku/4Nettai.html#乾燥地の農業",
    "href": "Shizenchirigaku/4Nettai.html#乾燥地の農業",
    "title": "４　各気候の特徴",
    "section": "乾燥地の農業",
    "text": "乾燥地の農業\n乾燥地は降水量が少ないが、日照が十二分にあるため、水があれば非常に高い農業収穫が期待できる。",
    "crumbs": [
      "Home",
      "地理学",
      "各気候の特徴"
    ]
  },
  {
    "objectID": "Shizenchirigaku/1Chirigakutoha.html",
    "href": "Shizenchirigaku/1Chirigakutoha.html",
    "title": "１　地理学",
    "section": "",
    "text": "地理学とは\n地理学は、空間、地域という特有の見方でアプローチする学問であり、複合科学的な性質を持つ。地上に存在するあらゆる事象には、空間と地域が伴うので、あらゆる事が地理学の対象となる。\n\n\n\n地理学の構造\n\n\n\n地理的条件の分析科学としての地理学\n地理的条件の生成とメカニズム、及び、地理的条件間の関係について分析し、その中から普遍的な原理を導き出す。\n⇒ 系統地理学\n\n地理的条件\n\n位置・地形・気候・土壌・植生・資源などの自然条件\n文化や社会組織などの人文・社会的条件\n\n分析対象となる地理的条件により体系化\n\n自然地理学：都市のヒートアイランド問題、土砂災害etc\n経済地理学：農業活動、企業活動と空間特性etc\n政治地理学：地図上の相対的位置と政治との関係\n文化地理学：地域文化の生成とあり方\n\n\n\n\n場所（地域）の総合科学としての地理学\n場所に関する知識を整理・表現すると同時に、ある空間的範囲に居住する人類集団が作り出してきた特徴（場所の個性）を見いだし、その場所の理解を深める\n⇒ 地誌学\n\n地理的条件の複合性を構造的に把握して、地域性を明らかにする\n\n人種や民族による人類学的形態\n言語\n衣食住のあり方\n祈りの形態\n社会の構造\n人間の感性や行動形態\n\n\n地域を記述すること　＝　地域を知ること\nその地域を治めるための効果的な手段\nEx）風土記など\n\n\n\n地理学の重要性\n地理を知ることは、以下のような重要性がある\n\n地域に係る諸問題の解決\n地域活性化のプロジェクトの検討なども、地域の歴史や変遷、統計などを調査し、その地の地域性やそれに適応できる形でのビジネスモデルの構築などにむけて地理的に分析し、その地域性の対策に使用できる\n\n\n国家戦略の立案\n国家の存立は食料と天然資源にかかっており、いかに安定的に・継続して収集できるかがカギとなる。\n食料生産地・天然資源の分布は限定的で、生産地が自国外となると、その国家との関係性、輸送ルートの確保（外交戦略）がカギとなるだけでなく、自国の産業政策（食糧安保等）にも影響を与える。\n⇒ 地政学 （地理は政治の基礎情報）\n\n\n自然災害への対応と日常生活への応用\nこれまで人類は、自然環境を利用して、文明を築き上げてきた。我々は自然から意識するしないに関わらず恩恵をうけると同時に、様々な災害も被っている。\n自然環境の「しくみ」を理解することで、更なる恩恵を受けられると同時に、災害も避けることが可能になる。\n\n\n\n環境決定論と環境可能論\nヒトの日々の暮らしを取り巻く諸条件\n\n自然条件・・・気候、地形、地質、植生、水など\n人文・社会条件・・・政治、経済、社会、産業、交通など\n\n\n\n\n\n\n\nノート環境決定論\n\n\n\n人間の生活様式は、その地域の自然環境によって決定づけられる\n\n\n\n\n\n\n\n\nノート環境可能論\n\n\n\n自然環境は人間に機会を与える存在として位置づけられる\n\n\nいずれにせよ自然環境は、人間の行動に強く影響を与えている。\n\n\n地域性とは\n\n\n\n\n\n\nノート地域性\n\n\n\nその地で見られる自然的・人文的な特徴\n\n\n多様性・空間性・関連性・時間性・階層性を認識することが、自然災害や環境問題の軽減につながるだけでなく、その地域が抱える諸問題を分析し、その答えを提示することができる。",
    "crumbs": [
      "Home",
      "地理学",
      "地理学"
    ]
  },
  {
    "objectID": "Shizenchirigaku/index.html",
    "href": "Shizenchirigaku/index.html",
    "title": "地理学",
    "section": "",
    "text": "1 地理学とは\n2 大気大循環\n3 ケッペンの気候区分\n4 各気候の特徴\n\n\n高橋日出男、小泉武栄, 『自然地理学概論（地理学基礎シリーズ２）』朝倉書店\n杉谷隆, 平井幸弘, 松本淳, 『風景の中の自然地理』古今書院\n松原彰子, 自然地理学（第3版）慶應義塾大学出版会",
    "crumbs": [
      "Home",
      "地理学",
      "地理学トップ"
    ]
  },
  {
    "objectID": "Shizenchirigaku/index.html#参考文献",
    "href": "Shizenchirigaku/index.html#参考文献",
    "title": "地理学",
    "section": "",
    "text": "高橋日出男、小泉武栄, 『自然地理学概論（地理学基礎シリーズ２）』朝倉書店\n杉谷隆, 平井幸弘, 松本淳, 『風景の中の自然地理』古今書院\n松原彰子, 自然地理学（第3版）慶應義塾大学出版会",
    "crumbs": [
      "Home",
      "地理学",
      "地理学トップ"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html",
    "href": "Rinri/6Seimeirinnrigaku.html",
    "title": "６　応用倫理学と生命倫理学",
    "section": "",
    "text": "応用倫理学は、規範倫理学の成果を個別の場面に応用することであり、新技術の発達に伴い、新しい問題が生まれることから、理論の修正などが行われる。\n従来の倫理学の人間観　＝　「理性的存在者」 　根本のモデルは、成熟した理性的な白人の男性\n\n\n医療現場にはこの前提から外れている人もいる。（乳幼児、重度の知的障害、脳死など）彼らは我々は人間として扱う。であれば、従来の原理には限界。\n理性中心主義によって、健全な理性を持つ者以外の人間が排除され始めた。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#伝統的な人間観の更新",
    "href": "Rinri/6Seimeirinnrigaku.html#伝統的な人間観の更新",
    "title": "６　応用倫理学と生命倫理学",
    "section": "",
    "text": "医療現場にはこの前提から外れている人もいる。（乳幼児、重度の知的障害、脳死など）彼らは我々は人間として扱う。であれば、従来の原理には限界。\n理性中心主義によって、健全な理性を持つ者以外の人間が排除され始めた。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#つの基本原則",
    "href": "Rinri/6Seimeirinnrigaku.html#つの基本原則",
    "title": "６　応用倫理学と生命倫理学",
    "section": "4つの基本原則",
    "text": "4つの基本原則\n\n自立尊重原理\n選択は患者がする\n無危害原理\n患者が安楽死を望んでも、決して患者を殺したり傷つけたりしてはならない\n仁恵原理\n患者にとって良いとみなせる治療を（手術拒否を説得するなど）\n正義原理\n貧しい人も治療を受けられるように医療資源の配分は公平にせよ\n\nパターナリズム（家父長主義） ：医者の言うことには従え　今はNG\nインフォームドコンセント ：患者が治療方針を十分説明し、患者の意思を確認し、患者が選択する",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#脳死問題",
    "href": "Rinri/6Seimeirinnrigaku.html#脳死問題",
    "title": "６　応用倫理学と生命倫理学",
    "section": "脳死問題",
    "text": "脳死問題\n\n医学上の死の取り扱い\n\n呼吸停止\n心拍停止\n瞳孔散大\n\n→ 人工呼吸器の登場で、「脳死」という概念が登場\n\n\n脳死の規定\n\n人間の基本的動き（意識や感覚）を維持\n身体の統合（呼吸や心拍機能）\n\n脳死は、この２機能の喪失と定義\n\n\n\n\n\n\n警告植物状態\n\n\n\n植物状態は１であり、長期の生存・回復があり得る\n\n\n\n\n脳死は人の死か？\n脳の二機能が失われるなら、医学的・生物学的には、もはや「生」ではない？\n\n脳死で「個体としての統一性」が失われる？\n\n脳死患者は出産がありうる\n\n脳死状態になったら数日中に心停止に至る？\n\n14年ほど生きる長期脳死もありうる\n\n\nとはいえ、日本でも法整備が進む。\n\n\n\n\n\n\n\n1997 臓器移植法\n2010 改正臓器移植法\n\n\n\n\n本人の書面による意思表示(書面)\n本人の意思が不明の場合、家族の同意で移植可能\n\n\n家族の承認が必要\n\n\n\n15歳未満提供不可\n年齢制限なし\n\n\n\n親族への優先提供\n\n\n\n\n\n懸念点\n\nドナー側\n\nドナー側の意思が尊重されているか。\n周囲から近親者に圧力がかからないか\n\nレシピエント側\n\n臓器移植は最良の治療法になっているか？\n免疫の問題\n\n移植後は免疫抑制剤の投与を続ける必要（＝ 抵抗力の低下）\n\n精神的負担",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#再生医療",
    "href": "Rinri/6Seimeirinnrigaku.html#再生医療",
    "title": "６　応用倫理学と生命倫理学",
    "section": "再生医療",
    "text": "再生医療\n再生医療は、事故や病気で損傷した部位を再び再生させる。\nただし倫理的問題が絡んでくることも\n\n幹細胞\n特定の組織や臓器になる手前にあり、失われた細胞を再生産して補充する能力をもった細胞\n\n多分化能\nさまざまな細胞に分化する能力\n自己複製能\nじぶんとまったく同じ能力をもつ細胞に分裂する能力\n\n幹細胞には、細胞幹細胞と多能性幹細胞が存在し、多能性幹細胞は、胎盤などを除くあらゆる細胞に分化する能力を持つ。\nEx）iPS細胞　ES細胞",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#人胚の道徳的地位",
    "href": "Rinri/6Seimeirinnrigaku.html#人胚の道徳的地位",
    "title": "６　応用倫理学と生命倫理学",
    "section": "人胚の道徳的地位",
    "text": "人胚の道徳的地位\n\nES細胞\n「胚性幹細胞（ES細胞）」は、受精卵からの成長過程の細胞からつくられる幹細胞 - 受精卵に非常に近い胚の細胞からつくられるので、あらゆる細胞に分化しうる「万能細胞」 - iPS細胞が出てくるまでは再生医療の中心だった\n\n\nES細胞の問題点\n\n患者本人の細胞ではないので拒絶反応のリスクがある\n\n通常のES細胞ベースの移植で拒絶反応が生じるのは、それが他人の細胞だから\n\n➡ じゃあ、患者本人の細胞からつくればよいのでは？\n＝ 「ヒト・クローン胚」からのES細胞作製\nそうした「ヒト・クローン胚」は、そのまま育てば「クローン人間」になる……\n➡ どこかしらで胚が盗まれてクローンがつくられるという可能性もなくはない（禁断）\nヒトES細胞は受精卵を「破壊」してつくられる\n\n一方で「生命尊重主義」からすれば、いずれ人間になるヒト胚を手段として “殺害する” ことはNG\nたとえばカトリックは受精の瞬間から「生命」と認めるため、大反対している\n➡「ヒト胚も生きる権利をもつ」\n\n\n\nこれに対する反論\n\n通常の妊娠過程でもひとりの子どもが生まれるまでに1~4つの受精卵が “死んで” いる ➡ 生命尊重主義は立場を一貫できるか？\nヒト胚は潜在的に人格をもつ？\n\n一般に潜在的にXだからといって現時点でXとしての権利をもつわけではない",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#クローニング",
    "href": "Rinri/6Seimeirinnrigaku.html#クローニング",
    "title": "６　応用倫理学と生命倫理学",
    "section": "クローニング",
    "text": "クローニング\n問題点は３つ 1. クローンによって人間の尊厳がおびやかされる 2. 同じ遺伝子をもつ人間が複数存在することで個体性があいまいになる\n\n反論\n\n「一卵性双生児」は自然なクローンとも云えるものだが、それによって尊厳や個体性は損なわれていない（むしろ一卵性双生児の方が、年齢は同じだし、生育環境も同じになりがちなので、類似性は高いはず）\nクローニングは人間の「道具化」か？（cf. カント～義務論）\n私たちはさまざまな目的で子どもを設ける（老後のため、男の子／女の子がほしい etc.）\n➡ そういった（ありふれた）事例も「道具化」にあたる？\n\n\n人類の遺伝子プールが画一化し、環境の変化（疫病など）に耐えられなくなるのでは？\n反論\n\nいまから2,000年前には人口も遥かに少なかったので、人類の遺伝子プールの多様性も遥かに少なかったはず\n\n➡ それでも問題なかったのだからよいのでは？\n\nそこまでクローニングが一般化することはあるのか？\nとはいえ、じぶんの遺伝子をもった子どもを設ける方法がクローンしかないという状況も想定しうる。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/6Seimeirinnrigaku.html#ips細胞",
    "href": "Rinri/6Seimeirinnrigaku.html#ips細胞",
    "title": "６　応用倫理学と生命倫理学",
    "section": "iPS細胞",
    "text": "iPS細胞\n京大　山中伸弥教授開発\n\n受精卵を用いず患者本人の体細胞から作製できる ＝ 拒絶反応もないし、ヒト・クローン胚の破壊もない\n\nただし、ただし、現時点ではシャーレの上で十分な臓器を作製することはできない\n➡ ブタなどの動物の身体を借りる必要がある……",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "応用倫理学と生命倫理学"
    ]
  },
  {
    "objectID": "Rinri/4Kourisyugi.html",
    "href": "Rinri/4Kourisyugi.html",
    "title": "４　功利主義と義務論",
    "section": "",
    "text": "行為の 「正・不正」の基準 を扱う分野\n「私たちはどのように行為すべきか？」\n以下の考え方が対立\n\n帰結主義：正・不正の基準は「帰結」にある\n義務論：正・不正の基準は「義務」にある\n徳倫理学：正・不正の基準は「徳」にある (今回は扱わず)",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "功利主義と義務論"
    ]
  },
  {
    "objectID": "Rinri/4Kourisyugi.html#問題点",
    "href": "Rinri/4Kourisyugi.html#問題点",
    "title": "４　功利主義と義務論",
    "section": "問題点",
    "text": "問題点\n\n義務は絶対的で無条件であり、いかなるときも嘘をついてはならない。\n→ いい嘘に対しては…？カントは、道徳法則を捻じ曲げてまですることではないと説明する。\nモラルジレンマの対応ができない\n→ カントは、完全義務と不完全義務を区別し、義務の間に序列を作ることで対処。ただ、序列付けは難しくね？という反論もある。\n\n\n義務論のメリット\n\n何をすればいいのかわかりやすく計算不要\n不公平や権利侵害が起こり得ない\n\n大勢のために一人を犠牲にすることは認められない\n\n行為者相対性がある\n\n\n\n義務論のデメリット\n\nモラルジレンマに対応しにくい\n義務があらかじめ定まっていない場合は？\n\n脳死などの新しい状況が科学の発達で発生\n\n既存の義務そのものの妥当性は？\n\n「女は専業主婦になるべき」みたいなものは理不尽",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "功利主義と義務論"
    ]
  },
  {
    "objectID": "Rinri/4Kourisyugi.html#功利主義-vs-義務論",
    "href": "Rinri/4Kourisyugi.html#功利主義-vs-義務論",
    "title": "４　功利主義と義務論",
    "section": "功利主義 vs 義務論",
    "text": "功利主義 vs 義務論\nEx）トロリー問題\nトロリーが暴走している。このままでは５人が縛り付けられているところへ向かう。もう片方には１人縛り付けられている。あなたはトロリーの進路を変えるか",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "功利主義と義務論"
    ]
  },
  {
    "objectID": "Rinri/index.html",
    "href": "Rinri/index.html",
    "title": "哲学・倫理学",
    "section": "",
    "text": "吉川孝、横地徳広、池田喬 編著　『映画で考える生命環境倫理学』勁草書房、2019年\nこの教科書の著者は、大陸系の研究者の著書である。すなわち、この記事では、英米系の研究者の視点が欠落していることに留意する必要がある。\nまた、倫理学という分野は、分析系の研究があまりメジャーでなく、その視点も欠落していることに留意する必要がある。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学・倫理学トップ"
    ]
  },
  {
    "objectID": "Rinri/index.html#参考文献",
    "href": "Rinri/index.html#参考文献",
    "title": "哲学・倫理学",
    "section": "",
    "text": "吉川孝、横地徳広、池田喬 編著　『映画で考える生命環境倫理学』勁草書房、2019年\nこの教科書の著者は、大陸系の研究者の著書である。すなわち、この記事では、英米系の研究者の視点が欠落していることに留意する必要がある。\nまた、倫理学という分野は、分析系の研究があまりメジャーでなく、その視点も欠落していることに留意する必要がある。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学・倫理学トップ"
    ]
  },
  {
    "objectID": "Rinri/index.html#哲学",
    "href": "Rinri/index.html#哲学",
    "title": "哲学・倫理学",
    "section": "哲学",
    "text": "哲学\n哲学：当たり前に見える根本概念を徹底的に反省、分析する営み\n\n\n\n分野\n内容\n\n\n\n\n形而上学\n時間 存在 論理\n\n\n認識論\n知識\n\n\n言語哲学\n意味\n\n\n行為論\n行為とは？\n\n\n宗教哲学\n宗教上の哲学\n\n\n哲学史\n哲学の歴史\n\n\n論理学\n証明論　数学などで使われる\n\n\n心の哲学\n心脳二元論など\n\n\n倫理学\n正・不正の基準\n\n\n\nc.f.　概念工学：人権などを作る",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学・倫理学トップ"
    ]
  },
  {
    "objectID": "Rinri/index.html#倫理学",
    "href": "Rinri/index.html#倫理学",
    "title": "哲学・倫理学",
    "section": "倫理学",
    "text": "倫理学\n倫理学：合理的に考える必要がある。つまり、全てにおいて理由が必要である。\n倫理学は哲学の中の一つ。\n直観は対立するため、必ずしも信頼できるものではないし、バイアスもかかっている。\n\n倫理学の種類\n\n\n\n\n\n\n\n\n\n分野\n区分\n内容\n例\n\n\n\n\n規範倫理学\n功利主義, 義務論, 徳倫理学\n「私たちはなぜ倫理的でなければならないか」など、道徳的行為の原理を探求する。\n-\n\n\n応用倫理学\n生命倫理学, 環境倫理学など\n個別場面への応用。具体的な問題解決を目指す。\n脳死、環境問題\n\n\nメタ倫理学\n実在論, 非実在論\n倫理的判断や概念そのものが持つ意味や性質を分析する。\n「善」とは何か\n\n\n記述倫理学\n-\nその国や地域の倫理の状況や慣習を記録・記述する。\n-",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学・倫理学トップ"
    ]
  },
  {
    "objectID": "programming2025/index.html",
    "href": "programming2025/index.html",
    "title": "プログラミング2025",
    "section": "",
    "text": "このサイトは、高知工科大学 小林豊先生の2025年プログラミングのサイトを再利用のため保存しているものである。 実際のサイトはコチラをご参照願いたい。\nトップページに戻る\n\n\n\nプログラミング2025\n\n目次\n授業の概要\n到達目標\n学習教材\n受講に際しての心構え\n資料目次\n\n第1回　プログラミング概論\n第2回　VS Code/仮想環境入門\n第3回　バージョン管理入門\n第4回　変数とメモリ\n第5回　データ型と制御構文\n第6回　標準ライブラリ(1)―タプル、文字列、ファイル入出力\n第7回　標準ライブラリ(2)―辞書、集合\n第8回　関数とモジュール\n第9回　NumPy/SciPy入門\n第10回　pandas入門\n第11回　statsmodels入門\n第12回　OOP入門\n第13回　otree入門\n第14回　ワンショットゲーム\n第15回　繰り返しゲーム\n\n教科書\n\n『独習Python』山田祥寛 著 (翔泳社, 2020年) ISBN 978-4-7981-6364-2\n\nその他\n\n\n\n\n\n本講義の狙いは、市販の入門書では習得が非常に困難であるような、タイピング技術、エディターに関する知識、Githubリポジトリの活用、情報科学の基本的知識、Markdownによる文書作成技術、プログラミング言語が動く仕組みの理解など、すぐには役立たなくとも長期的に効力を発揮するようなプログラミングの基礎力を向上させることです。\n本講義でプログラミングを学ぶために用いる言語はPythonです。本講義の受講者はRを使ったことがあるので、Pythonの理解は比較的容易です。しかしながら、Pythonには、パソコンやプログラムのことが分かっていないと陥る落とし穴が多くあり、Rよりもハードルの高い言語です。本講義では、この落とし穴を詳細に研究し、「どうしてPythonはこんな変な動きをするんだろう?」と考えながら、Pythonやコンピュータープログラムの仕組みを理解することを狙います。\n\n\n\n\n本講義の受講者が達成すべき具体的目標は、以下の通りです。\n\n標準的なエディターであるVS Codeを使いこなす\nMarkdownファイルによる資料作成ができる\nGit/GitHubを用いてアプリケーション開発ができる\n計算機とプログラムの基本的な原理を理解している\nPythonがメモリをどのように使用しているかを理解しており、その知識を用いてバグのないプログラムを作成できる\nバグを発見し、取り除くことができる\nPythonを用いて基本的なデータの操作、可視化、統計解析ができる\nOOP(オブジェクト指向プログラミング)のコンセプトを理解し、otreeを用いて簡単な実験プログラムを作成できる\n\n注）今年度は上記の「7.統計解析」までを扱う予定です。実験プログラミングに興味が有る方は、単位を取得した後、個人的に教員にご相談ください。\n\n\n\n皆さんが本講義を通してPythonを学ぶに当たっては、以下の教材を有効活用することをおすすめします。\n\n『独習Python』(教科書)\n本サイト\nPython公式ドキュメント\n生成AI(ChatGPT, Gemini, Claudeなど)\n\n内容の網羅性で言うと、2&lt;1&lt;3です。本サイトではPythonの標準機能の一部しか紹介できませんので、足りない部分を2の教科書で補うことにします。さらに、プログラミングをしていると、教科書を含む一般向け書籍にはなかなか書かれていないようなことも時々調べなくてはなりません。そのような場合は、3の公式ドキュメントを当たれば大抵のことがかかれています。4の生成AIについては、賢い使い方をすれば大変に勉強になります。ただし、AIは古い情報や誤った情報を出力することがありますので注意してください。\n\n\n\n\nエラーメッセージ(英語)を良く読む\nエラーメッセージが理解できなければ検索する\n検索の際は英語ページも調べる\n質問の際はエラーメッセージを添付する\n\n\n\n\n\n\nプログラムが動くとはどういうことか、プログラミング言語にはどのようなものがあるのか等、事前に押さえるべき必要最低限の事項を解説する。\n\n\n\n本講義でプログラミングに用いるエディター(VS Code)の解説を行う。また、Pythonの特徴である仮想環境およびAnacondaの操作、環境設定について解説を行う。\n\n\n\nアプリケーションやパッケージ作成の際に有用なGit/GitHubを用いたバージョン管理について解説する。\n\n\n\n変数に値を代入するということが意味するところについて、Rとの比較を通して詳細な解説を行う。その際に、ランダムアクセスメモリ(RAM)について多少のイメージを養うことが必要である。\n\n\n\nPythonの最も基本的なデータ構造であるリストの操作について解説する。また、Rとの比較を通して、条件分岐やループ処理などの制御構文について学ぶ。\n\n\n\nリスト以外の重要な組み込みデータ構造である文字列とタプル、そしてファイル入出力について解説する。\n\n\n\n残った組み込みデータ構造である辞書と集合について解説する。\n\n\n\n現代的なプログラミングでは、既存のものを再利用するのが普通である。再利用のための代表的な道具である関数とモジュール、そしてそれらにまつわる諸概念について学ぶ。\n\n\n\nPythonにおいて数値計算やデータ解析をするために最も重要なモジュールであるnumpyの挙動とそのメリットについて解説する。numpyを乱数シミュレーションや記述統計量の計算について学ぶ。numpyを使った科学技術計算ライブラリであるSciPyを用いて単回帰分析を実施する。\n\n\n\nデータ操作のためのモジュールとして標準的なpandasを使ってCSVデータを読み書きし、基本的な記述統計を計算する方法について学ぶ。さらにpandasに搭載されているグラフ機能とmatplotlibモジュールを用いてデータを可視化する。\n\n\n\n単回帰と重回帰を例にとり、標準的な統計モデルを納めたstatsmodelsモジュールを紹介する。また、機械学習モジュールのscikit-learnについても軽く触れる。\n\n\n\n大規模プロジェクトや実験プログラミングに必要なオブジェクト指向プログラミング(OOP)について学ぶ。クラス、メソッド、継承、ポリモルフィズムなど鍵となる概念について解説する。\n\n\n\nPythonで実験プログラムを作成するためのフレームワークであるotreeの解説を行う。簡単なサーベイのプログラムを作成する。\n\n\n\notreeを用いてワンショットゲームを作成する方法について学ぶ。\n\n\n\n前回作成したワンショットゲームを発展させ、繰り返しゲームを作成する。また、実験の結果得られるデータの取り扱いについて解説する。最後に、これまで学んできた知識をどのように研究に活かせばよいか解説し、まとめとする。\n\n\n\n\n\n\n\n\n\n\n\nチートシート\nちょっと細かい話(CPythonの詳細)"
  },
  {
    "objectID": "programming2025/index.html#目次",
    "href": "programming2025/index.html#目次",
    "title": "プログラミング2025",
    "section": "",
    "text": "プログラミング2025\n\n目次\n授業の概要\n到達目標\n学習教材\n受講に際しての心構え\n資料目次\n\n第1回　プログラミング概論\n第2回　VS Code/仮想環境入門\n第3回　バージョン管理入門\n第4回　変数とメモリ\n第5回　データ型と制御構文\n第6回　標準ライブラリ(1)―タプル、文字列、ファイル入出力\n第7回　標準ライブラリ(2)―辞書、集合\n第8回　関数とモジュール\n第9回　NumPy/SciPy入門\n第10回　pandas入門\n第11回　statsmodels入門\n第12回　OOP入門\n第13回　otree入門\n第14回　ワンショットゲーム\n第15回　繰り返しゲーム\n\n教科書\n\n『独習Python』山田祥寛 著 (翔泳社, 2020年) ISBN 978-4-7981-6364-2\n\nその他"
  },
  {
    "objectID": "programming2025/index.html#授業の概要",
    "href": "programming2025/index.html#授業の概要",
    "title": "プログラミング2025",
    "section": "",
    "text": "本講義の狙いは、市販の入門書では習得が非常に困難であるような、タイピング技術、エディターに関する知識、Githubリポジトリの活用、情報科学の基本的知識、Markdownによる文書作成技術、プログラミング言語が動く仕組みの理解など、すぐには役立たなくとも長期的に効力を発揮するようなプログラミングの基礎力を向上させることです。\n本講義でプログラミングを学ぶために用いる言語はPythonです。本講義の受講者はRを使ったことがあるので、Pythonの理解は比較的容易です。しかしながら、Pythonには、パソコンやプログラムのことが分かっていないと陥る落とし穴が多くあり、Rよりもハードルの高い言語です。本講義では、この落とし穴を詳細に研究し、「どうしてPythonはこんな変な動きをするんだろう?」と考えながら、Pythonやコンピュータープログラムの仕組みを理解することを狙います。"
  },
  {
    "objectID": "programming2025/index.html#到達目標",
    "href": "programming2025/index.html#到達目標",
    "title": "プログラミング2025",
    "section": "",
    "text": "本講義の受講者が達成すべき具体的目標は、以下の通りです。\n\n標準的なエディターであるVS Codeを使いこなす\nMarkdownファイルによる資料作成ができる\nGit/GitHubを用いてアプリケーション開発ができる\n計算機とプログラムの基本的な原理を理解している\nPythonがメモリをどのように使用しているかを理解しており、その知識を用いてバグのないプログラムを作成できる\nバグを発見し、取り除くことができる\nPythonを用いて基本的なデータの操作、可視化、統計解析ができる\nOOP(オブジェクト指向プログラミング)のコンセプトを理解し、otreeを用いて簡単な実験プログラムを作成できる\n\n注）今年度は上記の「7.統計解析」までを扱う予定です。実験プログラミングに興味が有る方は、単位を取得した後、個人的に教員にご相談ください。"
  },
  {
    "objectID": "programming2025/index.html#学習教材",
    "href": "programming2025/index.html#学習教材",
    "title": "プログラミング2025",
    "section": "",
    "text": "皆さんが本講義を通してPythonを学ぶに当たっては、以下の教材を有効活用することをおすすめします。\n\n『独習Python』(教科書)\n本サイト\nPython公式ドキュメント\n生成AI(ChatGPT, Gemini, Claudeなど)\n\n内容の網羅性で言うと、2&lt;1&lt;3です。本サイトではPythonの標準機能の一部しか紹介できませんので、足りない部分を2の教科書で補うことにします。さらに、プログラミングをしていると、教科書を含む一般向け書籍にはなかなか書かれていないようなことも時々調べなくてはなりません。そのような場合は、3の公式ドキュメントを当たれば大抵のことがかかれています。4の生成AIについては、賢い使い方をすれば大変に勉強になります。ただし、AIは古い情報や誤った情報を出力することがありますので注意してください。"
  },
  {
    "objectID": "programming2025/index.html#受講に際しての心構え",
    "href": "programming2025/index.html#受講に際しての心構え",
    "title": "プログラミング2025",
    "section": "",
    "text": "エラーメッセージ(英語)を良く読む\nエラーメッセージが理解できなければ検索する\n検索の際は英語ページも調べる\n質問の際はエラーメッセージを添付する"
  },
  {
    "objectID": "programming2025/index.html#資料目次",
    "href": "programming2025/index.html#資料目次",
    "title": "プログラミング2025",
    "section": "",
    "text": "プログラムが動くとはどういうことか、プログラミング言語にはどのようなものがあるのか等、事前に押さえるべき必要最低限の事項を解説する。\n\n\n\n本講義でプログラミングに用いるエディター(VS Code)の解説を行う。また、Pythonの特徴である仮想環境およびAnacondaの操作、環境設定について解説を行う。\n\n\n\nアプリケーションやパッケージ作成の際に有用なGit/GitHubを用いたバージョン管理について解説する。\n\n\n\n変数に値を代入するということが意味するところについて、Rとの比較を通して詳細な解説を行う。その際に、ランダムアクセスメモリ(RAM)について多少のイメージを養うことが必要である。\n\n\n\nPythonの最も基本的なデータ構造であるリストの操作について解説する。また、Rとの比較を通して、条件分岐やループ処理などの制御構文について学ぶ。\n\n\n\nリスト以外の重要な組み込みデータ構造である文字列とタプル、そしてファイル入出力について解説する。\n\n\n\n残った組み込みデータ構造である辞書と集合について解説する。\n\n\n\n現代的なプログラミングでは、既存のものを再利用するのが普通である。再利用のための代表的な道具である関数とモジュール、そしてそれらにまつわる諸概念について学ぶ。\n\n\n\nPythonにおいて数値計算やデータ解析をするために最も重要なモジュールであるnumpyの挙動とそのメリットについて解説する。numpyを乱数シミュレーションや記述統計量の計算について学ぶ。numpyを使った科学技術計算ライブラリであるSciPyを用いて単回帰分析を実施する。\n\n\n\nデータ操作のためのモジュールとして標準的なpandasを使ってCSVデータを読み書きし、基本的な記述統計を計算する方法について学ぶ。さらにpandasに搭載されているグラフ機能とmatplotlibモジュールを用いてデータを可視化する。\n\n\n\n単回帰と重回帰を例にとり、標準的な統計モデルを納めたstatsmodelsモジュールを紹介する。また、機械学習モジュールのscikit-learnについても軽く触れる。\n\n\n\n大規模プロジェクトや実験プログラミングに必要なオブジェクト指向プログラミング(OOP)について学ぶ。クラス、メソッド、継承、ポリモルフィズムなど鍵となる概念について解説する。\n\n\n\nPythonで実験プログラムを作成するためのフレームワークであるotreeの解説を行う。簡単なサーベイのプログラムを作成する。\n\n\n\notreeを用いてワンショットゲームを作成する方法について学ぶ。\n\n\n\n前回作成したワンショットゲームを発展させ、繰り返しゲームを作成する。また、実験の結果得られるデータの取り扱いについて解説する。最後に、これまで学んできた知識をどのように研究に活かせばよいか解説し、まとめとする。"
  },
  {
    "objectID": "programming2025/index.html#その他",
    "href": "programming2025/index.html#その他",
    "title": "プログラミング2025",
    "section": "",
    "text": "チートシート\nちょっと細かい話(CPythonの詳細)"
  },
  {
    "objectID": "programming2025/programming-9.html",
    "href": "programming2025/programming-9.html",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "第9回 NumPy/SciPy入門\n\nNumPy/SciPyとは\nNumPyの利点\n目標\nインストールとインポート\n1次元配列の作成\nベクトル演算\nインデクシング・スライス\nビュー\n乱数の生成\n記述統計量\n線形モデルからのサンプリング\n単回帰分析\n行列の作成\n行列のインデクシング\n行列演算\n行列の記述統計量\n行列のブロードキャスト\n行列のデータ構造\n配列を作る様々な方法\nまとめ\n参考書\n宿題(ホームワーク)\n課題(アサインメント)\n\n\n\n\nこれまで見てきたように、Pythonには、Rのベクトルのような数値計算に適したデータ型が標準で備わっていません。それはPythonが汎用プログラミング言語だからです。Pythonは、一つの仕事に特化した機能を標準で提供するのではなく、標準機能は柔軟性が高く、汎用性の高いものだけを提供し、専門的な機能については、全てモジュールあるいはパッケージの形で、拡張機能として提供する仕組みを採用しています。そのおかげで、世界中の有志のプログラマによって、Pythonの様々な拡張機能が提供され、機械学習、ウェブアプリケーション、GIS、経済実験など、多様な分野で成功を収めて来ました。\n今回取り上げるNumPyはPythonに高度な数値計算ライブラリを提供するモジュールで、他の様々なライブラリがNumPyに依存しています。Pythonでデータ解析をするならば、NumPyは絶対に避けて通れませんので、今回の講義でしっかりと基礎を押さえましょう。\nまた、NumPyをベースにした科学計算ライブラリであるSciPyについても簡単に取り上げます。NumPyの機能は非常に高度で強力ですが、科学の個別の分野には適応していません。統計や物理計算などの個別の分野に特化した計算は、NumPyをベースにしたSciPyモジュールが提供します。\nなお、NumPyやSciPyのような複数のモジュールを集めて作ったモジュールはパッケージと呼ばれます。リファレンスマニュアルにあるように、全てのパッケージはモジュールですが、モジュールは必ずしもパッケージではありません。\n使う側からすると、あるモジュールがパッケージかどうかということは通常問題になりません。従って、本講義では、区別する必要が生じないかぎり、パッケージのことをモジュールと呼ぶことにします。\n\n\n\nNumPyを使う利点は、主に以下のようなものでしょう。\n\nベクトルや高次元の配列を扱うことができる\n種々のベクトル・行列演算が可能\n標準機能に比べ、演算が高速\n\n中でも速度の問題は科学技術計算において重大です。特にPythonのforループによる処理が遅いことはPythonユーザーの間でも有名です。常識的な時間内に、本格的な科学計算を終わらせたいのなら、Pythonのリストやforループ、内包表記と言ったものをコードの主要な部分で使おうとは考えないことです。\nNumPyでのベクトル演算が高速な主な理由は、C言語でのプログラミングと同じように、メモリ上で連続した配列(各要素のバイト数は固定)に直接数値を格納し、しかも一つの配列には「整数」や「浮動小数点数」など決まったデータ型の数値しか格納しないからです。\n一方、これまで学んできたように、リストを始め、Pythonのコンテナは全て数値そのものではなく、オブジェクトへの参照を格納しています。しかも、オブジェクトのデータ型は、実際にオブジェクトが参照されるまでわかりません。\nより具体的にPythonが遅い理由を考えるため、「リストAの要素とリストBの要素を要素ごとに足して、一つのリストを作る」という操作をPythonが処理するときの手順について考えてみるとよいでしょう。第1要素を足し合わせるだけで、以下のプロセスが必要になります。\n\nリストA、Bの第1要素に格納されている参照(アドレス)を取得\nそれらの参照をたどって、2つのオブジェクトを取得\n2つのオブジェクトの型を調べる\n+演算子が2つの型の間で定義されているか調べる\n定義されていなければエラーを返す\n定義されていれば2つのオブジェクトから数値を取り出して足す\n演算結果の数値をPythonの数値オブジェクトに加工する\n\n少なくともこれだけの操作が、それぞれの要素について必要になるはずです。\n一方NumPyのベクトルの場合は、一つのベクトルが複数のデータ型を混在させることは通常ありません(注；Structured arrayという高度な方法でデータ型を混在させることができますが、リストのような、型が動的に決まるタイプの柔軟性のある混在ではありません)。従って要素ごとに演算がどのように定義されているか調べる必要はありません。しかもベクトルは参照ではなく数値そのものを格納しているため、参照をたどる時間も必要ありませんし、計算結果を要素ごとにオブジェクト化する時間も必要ありません。これが主な高速化の理由ですが、他にも内部で諸々の効率性のよいアルゴリズムを使っているということがあるでしょう。\n\n\n\nNumPyやSciPyの様々な機能を1回の講義で幅広く説明することは困難です。そこで、今回は的を絞り、以下の2点の達成を目標とします。\n\nNumPyで線形モデルに従って疑似データを作成する\nそのデータに対してSciPyで線形回帰を行う\n\n上記の作業を自分でできるようになれば、NumPy/SciPyのマニュアルはインターネット上や書籍で豊富に提供されていますので、他の作業は容易に独学で学ぶことができると思います。\n独学の際に有用な資料を以下にリストアップしておきます。\n\nNumPyリファレンス\nSciPyリファレンス\nNumPyによるデータ分析入門\n\n\n\n\nそれでは、早速NumPyを使ってみましょう。まず準備として、Anacondaのbase以外の環境を使っている方は、numpyモジュールをインストールする必要があります。\nconda install numpy\nNumPyのモジュール名はnumpyです。ルールではありませんが、numpyはnpという別名でimportするのが慣習ですので、特に理由がないかぎりそうしましょう。\nしたがって、次のようにimportしてください。以降、numpyはnpの名前で使うことができるようになります。\nimport numpy as np\nNumPyの主要なデータ型はndarrayという配列型です。NumPyは、配列オブジェクトを作成し、配列オブジェクトを操作するためのモジュールであると考えて概ね間違いはありません。よって、配列を極めることがNumPyを極めることでもあります。\n\n\n\n本講義では、まず1次元の配列を作る方法に限定して説明し、多次元については必要に応じて随時説明することにします。1次元の配列とは、数値が一列にならんだだけのものであり、ベクトルとも呼ばれます。\n1次元配列を作る方法は色々とありますが、最も基本的なのは、array関数を用いてリスト、タプル、あるいはレンジから作る方法です。\n&gt;&gt;&gt; x = np.array([1,2,3,4,5])   # リストから作成\n&gt;&gt;&gt; x\narray([1, 2, 3, 4, 5])\n&gt;&gt;&gt; x = np.array((1,2,3,4,5))   # タプルから作成\n&gt;&gt;&gt; x\narray([1, 2, 3, 4, 5])\n&gt;&gt;&gt; x = np.array(range(10))     # レンジから作成\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; type(x)\n&lt;class 'numpy.ndarray'&gt;\nこのように、配列を出力すると、array([...])という表記で出力されますが、内側の[]はPythonのリストとは何の関係もありません。\nなお、レンジから配列を作る場合は、以下のようなarangeという関数が別に用意されているので、こちらから作っても良いでしょう。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; type(x)\n&lt;class 'numpy.ndarray'&gt;\nxのデータ型はndarrayですが、xが内部にもっている数値データの配列もまた『型』を持ちます。データの型は、ndarrayオブジェクトのdtype属性に収められています。\n&gt;&gt;&gt; x.dtype\ndtype('int64')\nこの出力は、x内部の要素配列がint64というNumPyモジュール内で定義されたデータ型を有することを示しています。\nint64型の数値は、64ビット、つまり8バイトのメモリ領域に格納される整数です。8バイト整数は仮に非負の整数だけに用いれば0〜2**64-1の範囲の整数を表すことができますが、int64は符号つき整数ですので、-2**63〜2**63-1、つまり下が-9223372036854775808から上が9223372036854775807までの整数を表現することができます。\n一つの数値で8バイト占有しますので、xの配列全体では80バイト消費しているはずですが、これを確認することができます。ndarray型オブジェクトは、属性nbytesにオーバーヘッドを除いた占有メモリ量を格納しています。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; type(x)\n&lt;class 'numpy.ndarray'&gt;\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x.nbytes\n80\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getsizeof(x)\n184\n上記のように、筆者の環境ではx全体が184バイト占有していますのでオーバーヘッドは104バイトということになります(オーバーヘッドはNumPyのバージョンや環境に依存しえます)。\nndarrayオブジェクト内部の数値型は、配列オブジェクトを作成するときに適当なものが自動的に選択されます。上記で数値型が自動的にint64になったのは、筆者の環境が64ビット処理系であることに関連しています。\n数値型を明示的に指定したい場合は、array関数のdtype引数に数値型を指定します。たとえば、小さな正整数しか扱わないことが分かっている場合は、メモリを節約するために、数値型を符号なし16ビット整数に設定したいということがあるかもしれません。その場合は、array関数のdtype引数に数値型を指定します。\n# arrayを使う場合\n&gt;&gt;&gt; x = np.array(range(10),dtype=np.uint16)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint16)\n&gt;&gt;&gt; x.nbytes\n20\n# arangeを使っても同じ\n&gt;&gt;&gt; x = np.arange(10,dtype=np.uint16)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint16)\n&gt;&gt;&gt; x.nbytes\n20\nこれで使用メモリを1/4まで削減できました(ただしオーバーヘッド除く)。ここでuint16は”unsigned integer 16 bits”(符号なし16ビット整数)を表すデータ型であり、NumPyモジュール内でuint16という名前で定義されています。\nNumPyには、主に以下のようなデータ型があります。\n\n\n\n数値型\n意味\n\n\n\n\nint8\n8ビット符号付き整数\n\n\nint16\n16ビット符号付き整数\n\n\nint32\n32ビット符号付き整数\n\n\nint64\n64ビット符号付き整数\n\n\nuint8\n8ビット符号なし整数\n\n\nuint16\n16ビット符号なし整数\n\n\nuint32\n32ビット符号なし整数\n\n\nuint64\n64ビット符号なし整数\n\n\nfloat16\n16ビット浮動小数点数\n\n\nfloat32\n32ビット浮動小数点数\n\n\nfloat64\n浮動小数点数(通常64ビット、処理系依存)\n\n\ncomplex64\n64ビット複素数\n\n\ncomplex128\n複素数(通常128ビット、処理系依存)\n\n\nbool\nブール値(1バイト)\n\n\nunicode\n固定長文字列\n\n\nobject\nオブジェクトの参照(通常8バイト、処理系依存)\n\n\n\n\n\n\nNumPy配列は、Rのベクトルによく似たベクトル演算をサポートしています。つまり、同じサイズの２つの配列に二項演算子を施すと、要素ごとの演算を実行します。\n&gt;&gt;&gt; x = np.array([0,2,4,6,8])\n&gt;&gt;&gt; y = np.array([1,2,2,3,4])\n&gt;&gt;&gt; x + y\narray([ 1,  4,  6,  9, 12])\n&gt;&gt;&gt; x - y \narray([-1,  0,  2,  3,  4])\n&gt;&gt;&gt; x * y\narray([ 0,  4,  8, 18, 32])\n&gt;&gt;&gt; x / y\narray([0., 1., 2., 2., 2.])\n四則演算だけでなく、比較演算子もベクトル化されます。\n&gt;&gt;&gt; x = np.array([0,5,10])\n&gt;&gt;&gt; y = np.array([3,2,10])\n&gt;&gt;&gt; x &gt; y\narray([False,  True, False])\n&gt;&gt;&gt; x &gt;= y\narray([False,  True,  True])\n&gt;&gt;&gt; x == y\narray([False, False,  True])\n&gt;&gt;&gt; x != y\narray([ True,  True, False])\nベクトルとスカラーの二項演算もサポートされています。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x + 3\narray([ 3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\n上記の場合、NumPyは、xと同じで全ての要素が3であるNumPy配列を作成し、それとxのベクトル演算を行います。つまり、本質的に次の演算が行われます。\n&gt;&gt;&gt; x + np.array([3] * 10)\narray([ 3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\nより一般に、NumPyは、形状の異なる配列同士のベクトル演算を行うとき、小さい方の配列を変形して大きい方に形状を合わせてから演算を行います。これをブロードキャストと言います。\n1次元配列においてブロードキャストが可能なのは、一方がスカラーもしくは要素が一つしかないリストや配列の場合だけです。それ以外の場合はエラー(ValueError)が出ます。\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x + np.array([1,2,3])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (10,) (3,) \n多次元配列のブロードキャストルールはもう少し複雑です。これについては、あとで行列を扱うときに説明します。\n\n\n\nNumPyの配列は、Pythonのリストと同じように、インデックス参照およびスライス記法によって要素を取得したり、部分配列を取得できます。\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x[5]\n5\n&gt;&gt;&gt; x[-1]\n9\n&gt;&gt;&gt; x[3:7]\narray([3, 4, 5, 6])\n&gt;&gt;&gt; x[:6]\narray([0, 1, 2, 3, 4, 5])\n&gt;&gt;&gt; x[4:]\narray([4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x[::2]\narray([0, 2, 4, 6, 8])\n&gt;&gt;&gt; \n代入文の左辺にインデックス参照やスライス記法を用いることもできますが、左辺と右辺の形状が違う場合はブロードキャストのルールが適用されます。\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x[4] = 100\n&gt;&gt;&gt; x\narray([  0,   1,   2,   3, 100,   5,   6,   7,   8,   9])\n&gt;&gt;&gt; x[3:6] = [300,400,500]\n&gt;&gt;&gt; x\narray([  0,   1,   2, 300, 400, 500,   6,   7,   8,   9])\n&gt;&gt;&gt; x[3:6] = np.array([10,10])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: could not broadcast input array from shape (2,) into shape (3,)\n上記の最後の例では、3つの要素をもつスライスに2つしか要素を持たないベクトルを代入しようとしたため、エラーが出ました。\n\n\n\n実は、配列のスライスによって得られるものは、ビュー(view)というNumPy特有のオブジェクトです。ビューは始めて現れる概念だけでなく、理解していないと意図しないデータ操作をしてしまうことになりますので、少し丁寧に解説しておきます。\nたとえば次のようにしてxのスライスを作ってyに代入したとしましょう。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; y = x[2:8:2]\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; y\narray([2, 4, 6])\nNumPy配列は内部に、生の数値データが収められた配列を持っていることを思い出しましょう。上記のようにスライス記法でyを作成すると、yはxと異なるオブジェクトでありながら、数値データの配列はxと共有した状態になります。\n\n\n\nview\n\n\nこれは次のようにして確かめることが出来ます。まず、xとyが異なるオブジェクトであることを確かめておきましょう。\n# %%\nimport numpy as np\nx = np.arange(10)\ny = x[2:8:2]\nprint(\"x:\",x)\nprint(\"y:\",y)\nprint(\"x is y:\",x is y)         # x is y?\nprint(\"x is at\",hex(id(x)))     # xのアドレス\nprint(\"y is at\",hex(id(y)))     # yのアドレス\n# 出力\n\nx: [0 1 2 3 4 5 6 7 8 9]\ny: [2 4 6]\nx is y: False\nx is at 0x7f04b60c5e70\ny is at 0x7f04fc0a8cf0\nNumPy配列は、内部の数値データ配列の情報を直接取得することができるようになっています。この情報は、__array_interface__という属性に辞書の形で収められています。これを出力してみましょう。\n# %%\nprint(\"x:\")\nfor key,value in x.__array_interface__.items():\n    print(' ',key,value)\n\nprint(\"y:\")\nfor key,value in y.__array_interface__.items():\n    print(' ',key,value)\n# 出力\n\nprint(\"x:\")...\nx:\n  data (38235568, False)\n  strides None\n  descr [('', '&lt;i8')]\n  typestr &lt;i8\n  shape (10,)\n  version 3\ny:\n  data (38235584, False)\n  strides (16,)\n  descr [('', '&lt;i8')]\n  typestr &lt;i8\n  shape (3,)\n  version 3\n上記のように__array_interface__属性は6個のエントリーをもつ辞書ですが、特に重要なのは以下のエントリーです。\n\n\n\nキー\n内容\n\n\n\n\ndata\n(データのアドレス,読み出し属性)\n\n\nstrides\nストライド\n\n\ntypestr\n数値データの型\n\n\nshape\n配列の形状\n\n\n\ndataはタプルですが、その１つめの要素はデータ配列のアドレスであり、xとyのアドレスがきっかり16バイト違うことに注目してください。読み出し属性は、Trueなら読み出し専用、Falseなら書き込みもできます。\nnp.int64型のデータは一つの数値で8バイト占有しますので、上記の結果は、yのデータは、xのデータの2区画先から始まっていることを表しています。\n次にstridesですが、これは、ストライド(歩幅)と言って、ビューにおいて隣り合う数値データの間のアドレスの間隔をバイトで表したものです。xのほうはビューではないのでNoneになっています(数値データは隙間なくメモリ上にならんでいます)。一方yのほうは、ストライドが16バイトですので、数値データの間隔は2区画分、つまり一つとばしで並んでいることが分かります。\ntypestrは数値の型を表す文字列ですが、最初の文字&lt;は、リトルエンディアンを表します。もしここが&gt;になっていればビッグエンディアンです。i8は、8バイト(64ビット)整数(integer)を表します。もし浮動小数点数ならばiの代わりにf(floating point number)と表示されます。\n最後にshapeですが、これは要素の数ですので、特に説明はいらないでしょう。\nこのように、xとyは違うNumPy配列オブジェクトでありながら、データを共有していることが分かります。２つの配列オブジェクトがメモリを共有しているかどうかは、numpyモジュールのshares_memory関数で調べることができます。\n&gt;&gt;&gt; np.shares_memory(x,y)\nTrue\nこのように、xとそのビューであるyはデータを共有しているので、yの変更はxに影響を及ぼします。\n&gt;&gt;&gt; y[0] = 100\n&gt;&gt;&gt; x\narray([  0,   1, 100,   3,   4,   5,   6,   7,   8,   9])\nなお、ビューの親となっている元のオブジェクトはビューのbaseという属性に格納されています。\n&gt;&gt;&gt; y.base\narray([  0,   1, 100,   3,   4,   5,   6,   7,   8,   9])\n&gt;&gt;&gt; y.base is x\nTrue\nまたビューのストライドは、stridesという属性にも格納されています。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; y = x[2:8:2]\n&gt;&gt;&gt; y.strides\n(16,)\n\n\n\nNumPyにはrandomという乱数発生用のモジュールが含まれています。randomには、正規乱数や一様乱数など、様々な種類の乱数を生成する関数が定義されており、シミュレーションに重宝しますので、是非活用できるようになってください。以下、それらのごく一部を紹介します。\n\n\n\n関数\n分布\n\n\n\n\nnormal\n正規分布\n\n\nrandom\n区間[0,1)の一様分布\n\n\nuniform\n任意区間の一様分布\n\n\npoisson\nポワソン分布\n\n\nrandint\n離散一様分布\n\n\ngumbel\nガンベル分布\n\n\n\nその他の乱数生成関数や個々の関数の詳しい使い方については、NumPyリファレンスを参照してください。\n例えば、標準正規分布からサイズ20のサンプルを取得するには、次のようにします。\n&gt;&gt;&gt; x = np.random.normal(0,1,20)\n&gt;&gt;&gt; x\narray([ 0.09725553,  2.00971439, -0.58210648,  1.54395503,  0.45286862,  1.11726181, -0.4284753,  0.54515861, -0.87370196,  0.01872232, -0.71166122, -0.91043368, 1.03194197,  1.17382845, -0.11945387, -0.6825217 , 0.62068263,  0.22084924, -0.74841417, -0.65386876])\n&gt;&gt;&gt; len(x)\n20\nnormalの第1引数は期待値、第2引数は標準偏差、第3引数はサンプルサイズです。\nなお、乱数のシード値を具体的に与えない場合は、Pythonを起動するごとに異なった乱数列が得られます。\n&gt;&gt;&gt; np.random.normal(0,1,5)\narray([-1.16956415, -1.10909057,  1.11722481,  0.65070696,  0.66218606])\n&gt;&gt;&gt; np.random.normal(0,1,5)\narray([ 0.81478851, -1.3194389 ,  0.91750309, -0.41069239, -0.52968867])\n&gt;&gt;&gt; np.random.normal(0,1,5)\narray([-0.29362213, -0.82283927,  1.99318359, -0.62032484,  0.12263955])\n毎回必ず決まった乱数列がほしい場合は、以下のようにしてdefault_rng関数を用いて新しい乱数ジェネレータオブジェクトを作成します。\n&gt;&gt;&gt; rng = np.random.default_rng(123)\n&gt;&gt;&gt; type(rng)\n&lt;class 'numpy.random._generator.Generator'&gt;\ndefault_rngに与える引数は整数ならば何でも構いません。戻り値は乱数ジェネレータオブジェクトであり、これはrandomモジュールと同じように使うことができます。\n&gt;&gt;&gt; rng.normal(0,1,10)\narray([-0.98912135, -0.36778665,  1.28792526,  0.19397442,  0.9202309, 0.57710379, -0.63646365,  0.54195222, -0.31659545, -0.32238912])\nなお、配列にはroundという丸めのためのメソッドが備わっています。引数には小数点以下に残す桁数を指定します。\n&gt;&gt;&gt; x = rng.normal(0,1,10)\n&gt;&gt;&gt; x\narray([ 0.09716732, -1.52593041,  1.1921661 , -0.67108968,  1.00026942, 0.13632112,  1.53203308, -0.65996941, -0.31179486,  0.33776913])\n&gt;&gt;&gt; x.round(3)    # 小数点以下3桁に丸める\narray([ 0.097, -1.526,  1.192, -0.671,  1.   ,  0.136,  1.532, -0.66, -0.312,  0.338])\n\n\n\nNumPy配列には、要素の平均や分散などの記述統計量を計算する関数やメソッドが標準で備わっています。\n\n\n\nメソッド\n統計量\n\n\n\n\nmean\n平均\n\n\nvar\n分散\n\n\nstd\n標準偏差\n\n\nsum\n総和\n\n\n\n&gt;&gt;&gt; x = np.random.normal(0,1,10)\n&gt;&gt;&gt; x.mean().round(3)\n0.049\n&gt;&gt;&gt; x.sum().round(3)\n0.495\n&gt;&gt;&gt; x.var().round(3)\n1.292\n&gt;&gt;&gt; x.std().round(3)\n1.137\nただし、arrを配列とすると、arr.var()はデフォルトでは平均との差の二乗和をサンプルサイズlen(arr)で割ったものになるので注意してください(varのマニュアル)。不偏分散がほしいときは、オプション引数ddofに1を設定する必要があります。ddofはDelta Degrees of Freedom(自由度の差分)であり、自由度はlen(arr)-ddofに設定されます(分散=平均との差の二乗和/自由度です)。標準偏差を計算するstdについても同様です。\n&gt;&gt;&gt; x.var(ddof=1).round(3)  # 不偏分散\n1.435\n&gt;&gt;&gt; x.std(ddof=1).round(3)  # 不偏分散の平方根\n1.198\n&gt;&gt;&gt; np.sqrt(x.var(ddof=1)).round(3)\n1.198\nなお、sqrt関数は平方根を計算するNumPyの関数です。\n\n\n\nそれではいよいよ、線形モデルからサンプリングを行います。この線形モデルでは、xという独立変数と、yという従属変数があるとします。次のようなモデルを考えましょう。\n# %%\ny = b0 + b1 * x + e\nここでb0が定数項(切片)、b1は傾き、eは正規分布に従う期待値0の乱数とします。以下では、このモデルからサンプリングによって得られた擬似的データに単回帰分析を行い、b0およびb1の推定値を求めます。なお、b1の推定値がいわゆる回帰係数となります。\n回帰分析において独立変数は定数として扱われますので、分布は何でも構いませんが、ここでは期待値8、標準偏差2の正規分布を仮定しましょう。また、乱数項の標準偏差は3であると仮定します。\n# %%\nimport numpy as np\nx = np.random.normal(8,2,100)\ne = np.random.normal(0,3,100)\ny = 1 + 2 * x + e\nこれで独立変数値の列x、乱数項の列e、従属変数値の列yが全て配列として得られました。yを求めるときにブロードキャストを利用して定数項とベクトルの演算を行ったことに注意してください。\n\n\n\n単回帰分析には、SciPyモジュールを使います。SciPyにはstatsという統計モジュールが含まれていますので、それをインポートしましょう。\n# %%\nfrom scipy import stats\n上記のfrom-import命令では、scipyモジュールのstatsというサブモジュールだけを読み込んでいます。なお、一般に次のように書くことで、モジュールから、特定のサブモジュールや関数、属性(モジュール内のグローバル名前空間で定義されている変数)だけを読み込むことができます。\nfrom module import sub\nここでsubはサブモジュールあるいは関数名や属性名です。\n単回帰分析には、statsモジュール内のlinregress関数を使います。第1引数が独立変数で、第2引数が従属変数です。\n# %%\nres = stats.linregress(x,y)\ntype(res)\n# 出力\n\nscipy.stats._stats_mstats_common.LinregressResult\n上記のように、結果はLinregressionResult型のオブジェクトとして返されます。このオブジェクトは、以下の属性を持っています。\n\n\n\n属性\n意味\n\n\n\n\nslope\n回帰係数のOLS推定値\n\n\nstderr\nslopeの標準誤差\n\n\npvalue\nslopeのP値(両側t検定)\n\n\nrvalue\n相関係数R\n\n\nintercept\n切片のOLS推定値\n\n\nintercept_stderr\ninterceptの標準誤差\n\n\n\nこれらを順番に表示してみましょう。\n# %%\ncoeffs = ['slope','stderr','pvalue','rvalue','intercept','intercept_stderr']\nfor cf in coeffs:\n    value = round(eval(\"res.\" + cf),3)\n    print(cf + \": \",value)\n# 出力\n\nslope:  2.083\nstderr:  0.177\npvalue:  0.0\nrvalue:  0.765\nintercept:  1.058\nintercept_stderr:  1.425\n上記のように、傾きや切片が概ね正しく推定されています。また傾きのP値はほぼ0ですので、傾きが統計的に有意に0から離れていることが分かります。\nなお、linregressが計算するP値は両側検定のP値ですので、片側検定の場合はその半分の値となります。\nなお、上記のモデル、疑似データ、回帰直線をプロットすると、以下の図のようになります。オレンジの線が真のモデル、灰色の線が推定された回帰直線です。\nこうした図を作成する方法については、次回の講義で取り扱います。\n\n\n\nlinregress\n\n\n\n\n\n初歩的なデータ解析においても重要になる2次元配列について、少し取り扱っておきたいと思います。\n1次元配列をベクトルであるとすれば、2次元配列は行列です。(matrixという行列を表す特別な型もありますが、本稿では扱いません。)行列を作るには、まず行列のもとになる入れ子になったリストを作成します。\n下図のような行列を作成するとします。\n\n\n\nmatrix\n\n\nこの場合、次のような入れ子のリストを作成します。\n# %%\narr_like = [[0,1,2],[3,4,5],[6,7,8]]\nこのリストにおいて、第1要素が行列の1行目、第2要素が2行目、第3要素が3行目に相当します。このarr_likeリストをNumPyのarray関数に渡すことにより、行列が作成されます。\n# %%\narr2d = np.array(arr_like)\narr2d\n# 出力\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\nもう一つの作り方は、1次元配列を作ってからreshapeメソッドによって行列化することです。\n# %%\narr_nums = np.arange(9).reshape((3,3))\narr_nums\nここでreshapeの引数には、(行数、列数)のタプルを与えます。\n# 出力\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n\n\n配列の要素にアクセスするときは、行・列のインデックスをコンマでつないで指定します。\n# %%\n# 1行2列の要素\n\nprint(arr2d[1,2])\n# 出力\n5\n1次元のときと同じように、スライス記法も使用可能です。たとえば、0～1行目、1～2列目の部分行列を取り出したいときは、次のようにします。\n# %%\narr2d[0:2,1:3]\n# 出力\n\narray([[1, 2],\n       [4, 5]])\nただし、スライスで得られるのは、1次元配列の場合と同様コピーではなくビューであることに注意してください。\n# %%\narr2d_view = arr2d[0:2,1:3]\nnp.shares_memory(arr2d_view,arr2d)\n# 出力\nTrue\nインデックスを1つだけ指定すると、特定の行を取得できます。\n# %%\narr2d[1]\n# 出力\n\narray([3, 4, 5])\n列を取得するときは行をスライスする必要があります。\n# %%\narr2d[:,1]\n# 出力\narray([1, 4, 7])\nただしこのようにすると、戻されるビューは次元が落ちてしまいます。もとの配列の次元を維持するには、列もスライスにします。\n# %%\narr2d[:,1:2]\narray([[1],\n       [4],\n       [7]])\n\n\n\nNumPyの行列には、通常の線形代数で用いるような行列演算がサポートされています。\n二つの行列の積をとるときは、演算子@を使います。\n# %%\narr1 = np.array([[1,2],[3,4]])\narr2 = np.array([[1,3],[2,4]])\narr3 = arr1 @ arr2\nprint(\"arr1:\")\nprint(arr1)\nprint(\"\\narr2:\")\nprint(arr2)\nprint(\"\\narr1 @ arr2:\")\nprint(arr3)\n# 出力\n\narr1:\n[[1 2]\n [3 4]]\n\narr2:\n[[1 3]\n [2 4]]\n\narr1 @ arr2:\n[[ 5 11]\n [11 25]]\n行列とベクトルの間の積についても、@が使えます。\n# %%\nvec1 = np.array([-1,5])\nvec2 = arr1 @ vec1\nprint(\"arr1:\")\nprint(arr1)\nprint(\"\\nvec1:\")\nprint(vec1)\nprint(\"\\narr1 @ vec2:\")\nprint(vec2)\n# 出力\narr1:\n[[1 2]\n [3 4]]\n\nvec1:\n[-1  5]\n\narr1 @ vec2:\n[ 9 17]\n行列の転置は、transposeメソッドもしくはT属性を用いることができます。\n# %%\nprint(\"arr1:\")\nprint(arr1)\nprint(\"\\narr1.T\")\nprint(arr1.T)\nprint(\"\\narr1.transpose()\")\nprint(arr1.transpose())\n# 出力\n\narr1:\n[[1 2]\n [3 4]]\n\narr1.T\n[[1 3]\n [2 4]]\n\narr1.transpose()\n[[1 3]\n [2 4]]\n\n\n\n行列についても、記述統計量を計算するメソッドをそのまま使うことができます。たとえば、全ての要素の平均はmeanメソッドによって得られます。\n# %%\narr = np.arange(9).reshape((3,3))\nprint(\"arr:\")\nprint(arr)\nprint(\"\\narr.mean():\")\nprint(arr.mean())\n行ごとの平均、列ごとの平均をとるときは、axis引数を設定します。このとき、axis=0で行方向の平均(つまり列ごとの平均)、axis=1で列方向の平均(つまり行ごとの平均)を計算できます。\n# %%\narr = np.arange(9).reshape((3,3))\nprint(\"arr:\")\nprint(arr)\nprint(\"\\narr.mean(axis=0):\")\nprint(arr.mean(axis=0))\nprint(\"\\narr.mean(axis=1):\")\nprint(arr.mean(axis=1))\n# 出力\n\narr:\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\narr.mean(axis=0):\n[3. 4. 5.]\n\narr.mean(axis=1):\n[1. 4. 7.]\naxisの指定の仕方がRのmarginとは逆なので気を付けてください。Rのmargin=1がNumPy行列のaxis=1、margin=2がaxis=0に相当します。\naxis引数は、他の統計量関連のメソッド(sum、var、stdなど)でも利用可能ですので、調べてみてください。\n\n\n\n行列においては、ブロードキャストにより、行列とベクトル、行列とスカラーの演算が可能になります。\n行列とスカラーの演算については、ベクトルの場合と同じで、スカラーの方が行列と同じ形状に変換されます。\n一方、行列とベクトルの演算については、ベクトルは、行列の行と同じ形状もしくは列と同じ形状をもつ必要があります。\nたとえば、次のように、ベクトルが行列の行と同じ形状をもつ場合、NumPyは当のベクトルを行方向に複製して行列にキャスト(型変換)します。\n# %%\narr = np.array([[1,2,3],[4,5,6]])\nvec = np.array([2,2,2])\nprint(\"arr:\")\nprint(arr)\nprint(\"\\nvec:\")\nprint(vec)\nprint(\"\\narr + vec:\")\nprint(arr + vec)\n同様に、ベクトルが行列の列と同じ形状を持つ場合は、列方向に複製することで行列にキャストされます。\n# %%\narr = np.array([[1,2,3],[4,5,6]])\nvec = np.array([[2],[2]])\nprint(\"arr:\")\nprint(arr)\nprint(\"\\nvec:\")\nprint(vec)\nprint(\"\\narr + vec:\")\nprint(arr + vec)\n# 出力\narr:\n[[1 2 3]\n [4 5 6]]\n\nvec:\n[[2], [2]]\n\narr + vec:\n[[3 4 5]\n [6 7 8]]\n\n\n\n行列は、概念的には表の形をしていますが、メモリに物理的に格納される際には、1次元の配列として格納されています。\nこの事実は、行列のスライスをとってビューを作成してみると良く分かります。\n# %%\narr_like = [[1,2,3],[4,5,6],[7,8,9]]\narr = np.array(arr_like)\narr2 = arr[0:2,0:2]\n\nprint(\"Original:\")\nprint(arr)\nprint()\n\nfor key,value in arr.__array_interface__.items():\n    print(key,value)\n\nprint(\"\\nView:\")\nprint(arr2)\nprint()\n\nfor key,value in arr2.__array_interface__.items():\n    print(key,value)\n# 出力\n\nOriginal:\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\ndata (1882324077584, False)\nstrides None\ndescr [('', '&lt;i4')]\ntypestr &lt;i4\nshape (3, 3)\nversion 3\n\nView:\n[[0 1]\n [3 4]]\n\ndata (1882324077584, False)\nstrides (12, 4)\ndescr [('', '&lt;i4')]\ntypestr &lt;i4\nshape (2, 2)\nversion 3\n重要なのは、ビューのストライドが(12,4)になっていることです。これは、\n\n次の行へ進むときは、12バイト先へ飛んでください\n次の列へ進むときは、4バイト先へ飛んでください\n\nという意味です。また、データの型は&lt;i4ですので、4バイト整数であることが分かります。すなわち、一つの数値で4バイトメモリを占有します。\nこれらを総合すると、データは実際には数のように直線的に格納されていて、それを行列の形に見せているだけだということが分かります。\n\n\n\nmatrixdata\n\n\nこのように、多次元配列構造を1次元的にメモリに保存することは計算機科学ではありふれたことですので、覚えておきましょう。\n(余談ですが、Rでは、FORTRAN型の行列を継承しており、データは列ごとにメモリに格納されますが、NumPyでは、C型の行列を継承しており、データは行ごとにメモリに格納されます。データ解析においては、列を変数、行をオブザベーションとすることがほとんどですので、FORTRAN型行列のほうが自然です。次回紹介するpandasのデータフレームでは、内部でNumPy行列を用いてデータを格納していますが、その際、NumPy行列の行をデータフレームの列として使うことで、FORTRAN型のデータフレームを実現しています。RとPythonがそれぞれ、FOTRANとCからどれだけ多くの物を受け継いでいるか調べてみてください。)\n\n\n\n配列は様々な方法で作ることができます。配列を作成するNumPy関数の一部を以下に列挙しておきます。全ての配列作成関数についてはNumPyのリファレンスマニュアルを参照してください。\nまずは、形状を(行数、列数)のようにタプルで与える関数です。スカラーを与えると1次元配列になります。\n\n\n\n関数\n意味\n用例\n\n\n\n\nones\n全てが1の配列を作る\nnp.ones((2,3))\n\n\nzeros\n全てが0の配列を作る\nnp.zeros((2,3))\n\n\nfull\n全てが同じ値の配列を作る\nnp.full((2,3),5)\n\n\n\n次に、_like系の関数です。これらについては、ある既存の配列を引数に与えて、それと同じ形状の配列を作ります。\n\n\n\n関数\n意味\n用例\n\n\n\n\nones_like\n全てが1の配列を作る\nnp.ones_like(arr)\n\n\nzeros_like\n全てが0の配列を作る\nnp.zeros(arr)\n\n\nfull_like\n全てが同じ値の配列を作る\nnp.full(arr,5)\n\n\n\n\n\n\n今回の講義では、以下のことを学びました。\n\nNumPy1次元配列の作成\nベクトル演算\n配列のスライスとビュー\n乱数の生成\n線形モデルのシミュレーション\nSciPyの単回帰分析\n行列の作成・操作\n行列のデータ構造\n記述統計量の計算\n\n分量の都合上、NumPy配列の機能のごく一部しか紹介できませんでした。NumPyのマスターはデータ分析において非常に重要ですので、参考書やNumPyのリファレンスマニュアルを読んで勉強しておいてください。\nまた、SciPyには、linalgというモジュールがあり、NumPy配列のための線形代数ライブラリを提供しています。例えば特異値分解(関数svd)など、多変量解析で不可欠になる機能が多数実装されているので、是非試していただきたいと思います。\n今回、3次元以上のNumPy配列については扱いませんでしたが、深層学習などの分野においては中心的な役割を演じる重要なデータ構造ですので、機会があれば資料に足していきたいと思います。\n\n\n\n以下の参考書が、薄くて読みやすくかつ内容も大変充実しています。\n\n『NumPyによるデータ分析入門』(Umit Mert Cakmak, Mert Cuhadaroglu著、山崎 邦子 (翻訳), 山崎 康宏 (翻訳))(2019) オライリージャパン. ISBN-13: 978-4873118871.\n\n\n\n\n\nスライスの代わりに、取り出したい行あるいは列を明示的にリストによって指定するインデクシングの方法をファンシーインデックス参照と言います。たとえば、arr2dから0行目と2行目だけを取り出したい場合は次のようにします。ファンシーインデックス参照を試してみなさい。そのうえで、それが元の配列のビューではなくコピーを作ることを確認し、なぜそのようになっているのか、ストライドの概念を用いて考察してみなさい。\n# %% \n# ファンシーインデックス参照\n# コピーを作る\nx = arr2d[[0,2],:]\nprint(x)\n\n# 見かけ上同じだがスライス記法\n# ビューを作る \ny = arr2d[0::2,:]\nprint(y)\nSciPyのlinalgモジュールを用いて、行列の固有値・固有ベクトルを計算してみなさい。\n以下のように3次元NumPy配列を作成し、それがどのように表示されるか確認しなさい。sumメソッドでAxis0、Axis1、Axis2方向に和をとり、何が起きているのか考察しなさい。\n# %%\narr3d = np.arange(27).reshape((3,3,3))\nsum0 = arr3d.sum(axis=0)\nsum1 = arr3d.sum(axis=1)\nsum2 = arr3d.sum(axis=2)\nndarrayのviewメソッドを用いると、データ型を変えたビューを作成することができます。以下では、array関数の引数dtype='&lt;i2'でリトルエンディアン2バイト整数型の配列xを作った後、viewメソッドのdtype='i1'引数で1バイト整数型のビューyを作っています。なぜyの出力がこのようになるのか、考察してみてください。さらに、yに何らかの演算を施して、xがどのように変化するか観察してみてください。\n# %%\nx = np.array([256,256],dtype='&lt;i2')\ny = x.view(dtype='i1')\nprint(y)\n# 出力\n[0 1 0 1]"
  },
  {
    "objectID": "programming2025/programming-9.html#numpyscipyとは",
    "href": "programming2025/programming-9.html#numpyscipyとは",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "これまで見てきたように、Pythonには、Rのベクトルのような数値計算に適したデータ型が標準で備わっていません。それはPythonが汎用プログラミング言語だからです。Pythonは、一つの仕事に特化した機能を標準で提供するのではなく、標準機能は柔軟性が高く、汎用性の高いものだけを提供し、専門的な機能については、全てモジュールあるいはパッケージの形で、拡張機能として提供する仕組みを採用しています。そのおかげで、世界中の有志のプログラマによって、Pythonの様々な拡張機能が提供され、機械学習、ウェブアプリケーション、GIS、経済実験など、多様な分野で成功を収めて来ました。\n今回取り上げるNumPyはPythonに高度な数値計算ライブラリを提供するモジュールで、他の様々なライブラリがNumPyに依存しています。Pythonでデータ解析をするならば、NumPyは絶対に避けて通れませんので、今回の講義でしっかりと基礎を押さえましょう。\nまた、NumPyをベースにした科学計算ライブラリであるSciPyについても簡単に取り上げます。NumPyの機能は非常に高度で強力ですが、科学の個別の分野には適応していません。統計や物理計算などの個別の分野に特化した計算は、NumPyをベースにしたSciPyモジュールが提供します。\nなお、NumPyやSciPyのような複数のモジュールを集めて作ったモジュールはパッケージと呼ばれます。リファレンスマニュアルにあるように、全てのパッケージはモジュールですが、モジュールは必ずしもパッケージではありません。\n使う側からすると、あるモジュールがパッケージかどうかということは通常問題になりません。従って、本講義では、区別する必要が生じないかぎり、パッケージのことをモジュールと呼ぶことにします。"
  },
  {
    "objectID": "programming2025/programming-9.html#numpyの利点",
    "href": "programming2025/programming-9.html#numpyの利点",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPyを使う利点は、主に以下のようなものでしょう。\n\nベクトルや高次元の配列を扱うことができる\n種々のベクトル・行列演算が可能\n標準機能に比べ、演算が高速\n\n中でも速度の問題は科学技術計算において重大です。特にPythonのforループによる処理が遅いことはPythonユーザーの間でも有名です。常識的な時間内に、本格的な科学計算を終わらせたいのなら、Pythonのリストやforループ、内包表記と言ったものをコードの主要な部分で使おうとは考えないことです。\nNumPyでのベクトル演算が高速な主な理由は、C言語でのプログラミングと同じように、メモリ上で連続した配列(各要素のバイト数は固定)に直接数値を格納し、しかも一つの配列には「整数」や「浮動小数点数」など決まったデータ型の数値しか格納しないからです。\n一方、これまで学んできたように、リストを始め、Pythonのコンテナは全て数値そのものではなく、オブジェクトへの参照を格納しています。しかも、オブジェクトのデータ型は、実際にオブジェクトが参照されるまでわかりません。\nより具体的にPythonが遅い理由を考えるため、「リストAの要素とリストBの要素を要素ごとに足して、一つのリストを作る」という操作をPythonが処理するときの手順について考えてみるとよいでしょう。第1要素を足し合わせるだけで、以下のプロセスが必要になります。\n\nリストA、Bの第1要素に格納されている参照(アドレス)を取得\nそれらの参照をたどって、2つのオブジェクトを取得\n2つのオブジェクトの型を調べる\n+演算子が2つの型の間で定義されているか調べる\n定義されていなければエラーを返す\n定義されていれば2つのオブジェクトから数値を取り出して足す\n演算結果の数値をPythonの数値オブジェクトに加工する\n\n少なくともこれだけの操作が、それぞれの要素について必要になるはずです。\n一方NumPyのベクトルの場合は、一つのベクトルが複数のデータ型を混在させることは通常ありません(注；Structured arrayという高度な方法でデータ型を混在させることができますが、リストのような、型が動的に決まるタイプの柔軟性のある混在ではありません)。従って要素ごとに演算がどのように定義されているか調べる必要はありません。しかもベクトルは参照ではなく数値そのものを格納しているため、参照をたどる時間も必要ありませんし、計算結果を要素ごとにオブジェクト化する時間も必要ありません。これが主な高速化の理由ですが、他にも内部で諸々の効率性のよいアルゴリズムを使っているということがあるでしょう。"
  },
  {
    "objectID": "programming2025/programming-9.html#目標",
    "href": "programming2025/programming-9.html#目標",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPyやSciPyの様々な機能を1回の講義で幅広く説明することは困難です。そこで、今回は的を絞り、以下の2点の達成を目標とします。\n\nNumPyで線形モデルに従って疑似データを作成する\nそのデータに対してSciPyで線形回帰を行う\n\n上記の作業を自分でできるようになれば、NumPy/SciPyのマニュアルはインターネット上や書籍で豊富に提供されていますので、他の作業は容易に独学で学ぶことができると思います。\n独学の際に有用な資料を以下にリストアップしておきます。\n\nNumPyリファレンス\nSciPyリファレンス\nNumPyによるデータ分析入門"
  },
  {
    "objectID": "programming2025/programming-9.html#インストールとインポート",
    "href": "programming2025/programming-9.html#インストールとインポート",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "それでは、早速NumPyを使ってみましょう。まず準備として、Anacondaのbase以外の環境を使っている方は、numpyモジュールをインストールする必要があります。\nconda install numpy\nNumPyのモジュール名はnumpyです。ルールではありませんが、numpyはnpという別名でimportするのが慣習ですので、特に理由がないかぎりそうしましょう。\nしたがって、次のようにimportしてください。以降、numpyはnpの名前で使うことができるようになります。\nimport numpy as np\nNumPyの主要なデータ型はndarrayという配列型です。NumPyは、配列オブジェクトを作成し、配列オブジェクトを操作するためのモジュールであると考えて概ね間違いはありません。よって、配列を極めることがNumPyを極めることでもあります。"
  },
  {
    "objectID": "programming2025/programming-9.html#次元配列の作成",
    "href": "programming2025/programming-9.html#次元配列の作成",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "本講義では、まず1次元の配列を作る方法に限定して説明し、多次元については必要に応じて随時説明することにします。1次元の配列とは、数値が一列にならんだだけのものであり、ベクトルとも呼ばれます。\n1次元配列を作る方法は色々とありますが、最も基本的なのは、array関数を用いてリスト、タプル、あるいはレンジから作る方法です。\n&gt;&gt;&gt; x = np.array([1,2,3,4,5])   # リストから作成\n&gt;&gt;&gt; x\narray([1, 2, 3, 4, 5])\n&gt;&gt;&gt; x = np.array((1,2,3,4,5))   # タプルから作成\n&gt;&gt;&gt; x\narray([1, 2, 3, 4, 5])\n&gt;&gt;&gt; x = np.array(range(10))     # レンジから作成\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; type(x)\n&lt;class 'numpy.ndarray'&gt;\nこのように、配列を出力すると、array([...])という表記で出力されますが、内側の[]はPythonのリストとは何の関係もありません。\nなお、レンジから配列を作る場合は、以下のようなarangeという関数が別に用意されているので、こちらから作っても良いでしょう。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; type(x)\n&lt;class 'numpy.ndarray'&gt;\nxのデータ型はndarrayですが、xが内部にもっている数値データの配列もまた『型』を持ちます。データの型は、ndarrayオブジェクトのdtype属性に収められています。\n&gt;&gt;&gt; x.dtype\ndtype('int64')\nこの出力は、x内部の要素配列がint64というNumPyモジュール内で定義されたデータ型を有することを示しています。\nint64型の数値は、64ビット、つまり8バイトのメモリ領域に格納される整数です。8バイト整数は仮に非負の整数だけに用いれば0〜2**64-1の範囲の整数を表すことができますが、int64は符号つき整数ですので、-2**63〜2**63-1、つまり下が-9223372036854775808から上が9223372036854775807までの整数を表現することができます。\n一つの数値で8バイト占有しますので、xの配列全体では80バイト消費しているはずですが、これを確認することができます。ndarray型オブジェクトは、属性nbytesにオーバーヘッドを除いた占有メモリ量を格納しています。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; type(x)\n&lt;class 'numpy.ndarray'&gt;\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x.nbytes\n80\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getsizeof(x)\n184\n上記のように、筆者の環境ではx全体が184バイト占有していますのでオーバーヘッドは104バイトということになります(オーバーヘッドはNumPyのバージョンや環境に依存しえます)。\nndarrayオブジェクト内部の数値型は、配列オブジェクトを作成するときに適当なものが自動的に選択されます。上記で数値型が自動的にint64になったのは、筆者の環境が64ビット処理系であることに関連しています。\n数値型を明示的に指定したい場合は、array関数のdtype引数に数値型を指定します。たとえば、小さな正整数しか扱わないことが分かっている場合は、メモリを節約するために、数値型を符号なし16ビット整数に設定したいということがあるかもしれません。その場合は、array関数のdtype引数に数値型を指定します。\n# arrayを使う場合\n&gt;&gt;&gt; x = np.array(range(10),dtype=np.uint16)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint16)\n&gt;&gt;&gt; x.nbytes\n20\n# arangeを使っても同じ\n&gt;&gt;&gt; x = np.arange(10,dtype=np.uint16)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=uint16)\n&gt;&gt;&gt; x.nbytes\n20\nこれで使用メモリを1/4まで削減できました(ただしオーバーヘッド除く)。ここでuint16は”unsigned integer 16 bits”(符号なし16ビット整数)を表すデータ型であり、NumPyモジュール内でuint16という名前で定義されています。\nNumPyには、主に以下のようなデータ型があります。\n\n\n\n数値型\n意味\n\n\n\n\nint8\n8ビット符号付き整数\n\n\nint16\n16ビット符号付き整数\n\n\nint32\n32ビット符号付き整数\n\n\nint64\n64ビット符号付き整数\n\n\nuint8\n8ビット符号なし整数\n\n\nuint16\n16ビット符号なし整数\n\n\nuint32\n32ビット符号なし整数\n\n\nuint64\n64ビット符号なし整数\n\n\nfloat16\n16ビット浮動小数点数\n\n\nfloat32\n32ビット浮動小数点数\n\n\nfloat64\n浮動小数点数(通常64ビット、処理系依存)\n\n\ncomplex64\n64ビット複素数\n\n\ncomplex128\n複素数(通常128ビット、処理系依存)\n\n\nbool\nブール値(1バイト)\n\n\nunicode\n固定長文字列\n\n\nobject\nオブジェクトの参照(通常8バイト、処理系依存)"
  },
  {
    "objectID": "programming2025/programming-9.html#ベクトル演算",
    "href": "programming2025/programming-9.html#ベクトル演算",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPy配列は、Rのベクトルによく似たベクトル演算をサポートしています。つまり、同じサイズの２つの配列に二項演算子を施すと、要素ごとの演算を実行します。\n&gt;&gt;&gt; x = np.array([0,2,4,6,8])\n&gt;&gt;&gt; y = np.array([1,2,2,3,4])\n&gt;&gt;&gt; x + y\narray([ 1,  4,  6,  9, 12])\n&gt;&gt;&gt; x - y \narray([-1,  0,  2,  3,  4])\n&gt;&gt;&gt; x * y\narray([ 0,  4,  8, 18, 32])\n&gt;&gt;&gt; x / y\narray([0., 1., 2., 2., 2.])\n四則演算だけでなく、比較演算子もベクトル化されます。\n&gt;&gt;&gt; x = np.array([0,5,10])\n&gt;&gt;&gt; y = np.array([3,2,10])\n&gt;&gt;&gt; x &gt; y\narray([False,  True, False])\n&gt;&gt;&gt; x &gt;= y\narray([False,  True,  True])\n&gt;&gt;&gt; x == y\narray([False, False,  True])\n&gt;&gt;&gt; x != y\narray([ True,  True, False])\nベクトルとスカラーの二項演算もサポートされています。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x + 3\narray([ 3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\n上記の場合、NumPyは、xと同じで全ての要素が3であるNumPy配列を作成し、それとxのベクトル演算を行います。つまり、本質的に次の演算が行われます。\n&gt;&gt;&gt; x + np.array([3] * 10)\narray([ 3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\nより一般に、NumPyは、形状の異なる配列同士のベクトル演算を行うとき、小さい方の配列を変形して大きい方に形状を合わせてから演算を行います。これをブロードキャストと言います。\n1次元配列においてブロードキャストが可能なのは、一方がスカラーもしくは要素が一つしかないリストや配列の場合だけです。それ以外の場合はエラー(ValueError)が出ます。\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x + np.array([1,2,3])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (10,) (3,) \n多次元配列のブロードキャストルールはもう少し複雑です。これについては、あとで行列を扱うときに説明します。"
  },
  {
    "objectID": "programming2025/programming-9.html#インデクシングスライス",
    "href": "programming2025/programming-9.html#インデクシングスライス",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPyの配列は、Pythonのリストと同じように、インデックス参照およびスライス記法によって要素を取得したり、部分配列を取得できます。\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x[5]\n5\n&gt;&gt;&gt; x[-1]\n9\n&gt;&gt;&gt; x[3:7]\narray([3, 4, 5, 6])\n&gt;&gt;&gt; x[:6]\narray([0, 1, 2, 3, 4, 5])\n&gt;&gt;&gt; x[4:]\narray([4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x[::2]\narray([0, 2, 4, 6, 8])\n&gt;&gt;&gt; \n代入文の左辺にインデックス参照やスライス記法を用いることもできますが、左辺と右辺の形状が違う場合はブロードキャストのルールが適用されます。\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; x[4] = 100\n&gt;&gt;&gt; x\narray([  0,   1,   2,   3, 100,   5,   6,   7,   8,   9])\n&gt;&gt;&gt; x[3:6] = [300,400,500]\n&gt;&gt;&gt; x\narray([  0,   1,   2, 300, 400, 500,   6,   7,   8,   9])\n&gt;&gt;&gt; x[3:6] = np.array([10,10])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: could not broadcast input array from shape (2,) into shape (3,)\n上記の最後の例では、3つの要素をもつスライスに2つしか要素を持たないベクトルを代入しようとしたため、エラーが出ました。"
  },
  {
    "objectID": "programming2025/programming-9.html#ビュー",
    "href": "programming2025/programming-9.html#ビュー",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "実は、配列のスライスによって得られるものは、ビュー(view)というNumPy特有のオブジェクトです。ビューは始めて現れる概念だけでなく、理解していないと意図しないデータ操作をしてしまうことになりますので、少し丁寧に解説しておきます。\nたとえば次のようにしてxのスライスを作ってyに代入したとしましょう。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; y = x[2:8:2]\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; y\narray([2, 4, 6])\nNumPy配列は内部に、生の数値データが収められた配列を持っていることを思い出しましょう。上記のようにスライス記法でyを作成すると、yはxと異なるオブジェクトでありながら、数値データの配列はxと共有した状態になります。\n\n\n\nview\n\n\nこれは次のようにして確かめることが出来ます。まず、xとyが異なるオブジェクトであることを確かめておきましょう。\n# %%\nimport numpy as np\nx = np.arange(10)\ny = x[2:8:2]\nprint(\"x:\",x)\nprint(\"y:\",y)\nprint(\"x is y:\",x is y)         # x is y?\nprint(\"x is at\",hex(id(x)))     # xのアドレス\nprint(\"y is at\",hex(id(y)))     # yのアドレス\n# 出力\n\nx: [0 1 2 3 4 5 6 7 8 9]\ny: [2 4 6]\nx is y: False\nx is at 0x7f04b60c5e70\ny is at 0x7f04fc0a8cf0\nNumPy配列は、内部の数値データ配列の情報を直接取得することができるようになっています。この情報は、__array_interface__という属性に辞書の形で収められています。これを出力してみましょう。\n# %%\nprint(\"x:\")\nfor key,value in x.__array_interface__.items():\n    print(' ',key,value)\n\nprint(\"y:\")\nfor key,value in y.__array_interface__.items():\n    print(' ',key,value)\n# 出力\n\nprint(\"x:\")...\nx:\n  data (38235568, False)\n  strides None\n  descr [('', '&lt;i8')]\n  typestr &lt;i8\n  shape (10,)\n  version 3\ny:\n  data (38235584, False)\n  strides (16,)\n  descr [('', '&lt;i8')]\n  typestr &lt;i8\n  shape (3,)\n  version 3\n上記のように__array_interface__属性は6個のエントリーをもつ辞書ですが、特に重要なのは以下のエントリーです。\n\n\n\nキー\n内容\n\n\n\n\ndata\n(データのアドレス,読み出し属性)\n\n\nstrides\nストライド\n\n\ntypestr\n数値データの型\n\n\nshape\n配列の形状\n\n\n\ndataはタプルですが、その１つめの要素はデータ配列のアドレスであり、xとyのアドレスがきっかり16バイト違うことに注目してください。読み出し属性は、Trueなら読み出し専用、Falseなら書き込みもできます。\nnp.int64型のデータは一つの数値で8バイト占有しますので、上記の結果は、yのデータは、xのデータの2区画先から始まっていることを表しています。\n次にstridesですが、これは、ストライド(歩幅)と言って、ビューにおいて隣り合う数値データの間のアドレスの間隔をバイトで表したものです。xのほうはビューではないのでNoneになっています(数値データは隙間なくメモリ上にならんでいます)。一方yのほうは、ストライドが16バイトですので、数値データの間隔は2区画分、つまり一つとばしで並んでいることが分かります。\ntypestrは数値の型を表す文字列ですが、最初の文字&lt;は、リトルエンディアンを表します。もしここが&gt;になっていればビッグエンディアンです。i8は、8バイト(64ビット)整数(integer)を表します。もし浮動小数点数ならばiの代わりにf(floating point number)と表示されます。\n最後にshapeですが、これは要素の数ですので、特に説明はいらないでしょう。\nこのように、xとyは違うNumPy配列オブジェクトでありながら、データを共有していることが分かります。２つの配列オブジェクトがメモリを共有しているかどうかは、numpyモジュールのshares_memory関数で調べることができます。\n&gt;&gt;&gt; np.shares_memory(x,y)\nTrue\nこのように、xとそのビューであるyはデータを共有しているので、yの変更はxに影響を及ぼします。\n&gt;&gt;&gt; y[0] = 100\n&gt;&gt;&gt; x\narray([  0,   1, 100,   3,   4,   5,   6,   7,   8,   9])\nなお、ビューの親となっている元のオブジェクトはビューのbaseという属性に格納されています。\n&gt;&gt;&gt; y.base\narray([  0,   1, 100,   3,   4,   5,   6,   7,   8,   9])\n&gt;&gt;&gt; y.base is x\nTrue\nまたビューのストライドは、stridesという属性にも格納されています。\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; y = x[2:8:2]\n&gt;&gt;&gt; y.strides\n(16,)"
  },
  {
    "objectID": "programming2025/programming-9.html#乱数の生成",
    "href": "programming2025/programming-9.html#乱数の生成",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPyにはrandomという乱数発生用のモジュールが含まれています。randomには、正規乱数や一様乱数など、様々な種類の乱数を生成する関数が定義されており、シミュレーションに重宝しますので、是非活用できるようになってください。以下、それらのごく一部を紹介します。\n\n\n\n関数\n分布\n\n\n\n\nnormal\n正規分布\n\n\nrandom\n区間[0,1)の一様分布\n\n\nuniform\n任意区間の一様分布\n\n\npoisson\nポワソン分布\n\n\nrandint\n離散一様分布\n\n\ngumbel\nガンベル分布\n\n\n\nその他の乱数生成関数や個々の関数の詳しい使い方については、NumPyリファレンスを参照してください。\n例えば、標準正規分布からサイズ20のサンプルを取得するには、次のようにします。\n&gt;&gt;&gt; x = np.random.normal(0,1,20)\n&gt;&gt;&gt; x\narray([ 0.09725553,  2.00971439, -0.58210648,  1.54395503,  0.45286862,  1.11726181, -0.4284753,  0.54515861, -0.87370196,  0.01872232, -0.71166122, -0.91043368, 1.03194197,  1.17382845, -0.11945387, -0.6825217 , 0.62068263,  0.22084924, -0.74841417, -0.65386876])\n&gt;&gt;&gt; len(x)\n20\nnormalの第1引数は期待値、第2引数は標準偏差、第3引数はサンプルサイズです。\nなお、乱数のシード値を具体的に与えない場合は、Pythonを起動するごとに異なった乱数列が得られます。\n&gt;&gt;&gt; np.random.normal(0,1,5)\narray([-1.16956415, -1.10909057,  1.11722481,  0.65070696,  0.66218606])\n&gt;&gt;&gt; np.random.normal(0,1,5)\narray([ 0.81478851, -1.3194389 ,  0.91750309, -0.41069239, -0.52968867])\n&gt;&gt;&gt; np.random.normal(0,1,5)\narray([-0.29362213, -0.82283927,  1.99318359, -0.62032484,  0.12263955])\n毎回必ず決まった乱数列がほしい場合は、以下のようにしてdefault_rng関数を用いて新しい乱数ジェネレータオブジェクトを作成します。\n&gt;&gt;&gt; rng = np.random.default_rng(123)\n&gt;&gt;&gt; type(rng)\n&lt;class 'numpy.random._generator.Generator'&gt;\ndefault_rngに与える引数は整数ならば何でも構いません。戻り値は乱数ジェネレータオブジェクトであり、これはrandomモジュールと同じように使うことができます。\n&gt;&gt;&gt; rng.normal(0,1,10)\narray([-0.98912135, -0.36778665,  1.28792526,  0.19397442,  0.9202309, 0.57710379, -0.63646365,  0.54195222, -0.31659545, -0.32238912])\nなお、配列にはroundという丸めのためのメソッドが備わっています。引数には小数点以下に残す桁数を指定します。\n&gt;&gt;&gt; x = rng.normal(0,1,10)\n&gt;&gt;&gt; x\narray([ 0.09716732, -1.52593041,  1.1921661 , -0.67108968,  1.00026942, 0.13632112,  1.53203308, -0.65996941, -0.31179486,  0.33776913])\n&gt;&gt;&gt; x.round(3)    # 小数点以下3桁に丸める\narray([ 0.097, -1.526,  1.192, -0.671,  1.   ,  0.136,  1.532, -0.66, -0.312,  0.338])"
  },
  {
    "objectID": "programming2025/programming-9.html#記述統計量",
    "href": "programming2025/programming-9.html#記述統計量",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPy配列には、要素の平均や分散などの記述統計量を計算する関数やメソッドが標準で備わっています。\n\n\n\nメソッド\n統計量\n\n\n\n\nmean\n平均\n\n\nvar\n分散\n\n\nstd\n標準偏差\n\n\nsum\n総和\n\n\n\n&gt;&gt;&gt; x = np.random.normal(0,1,10)\n&gt;&gt;&gt; x.mean().round(3)\n0.049\n&gt;&gt;&gt; x.sum().round(3)\n0.495\n&gt;&gt;&gt; x.var().round(3)\n1.292\n&gt;&gt;&gt; x.std().round(3)\n1.137\nただし、arrを配列とすると、arr.var()はデフォルトでは平均との差の二乗和をサンプルサイズlen(arr)で割ったものになるので注意してください(varのマニュアル)。不偏分散がほしいときは、オプション引数ddofに1を設定する必要があります。ddofはDelta Degrees of Freedom(自由度の差分)であり、自由度はlen(arr)-ddofに設定されます(分散=平均との差の二乗和/自由度です)。標準偏差を計算するstdについても同様です。\n&gt;&gt;&gt; x.var(ddof=1).round(3)  # 不偏分散\n1.435\n&gt;&gt;&gt; x.std(ddof=1).round(3)  # 不偏分散の平方根\n1.198\n&gt;&gt;&gt; np.sqrt(x.var(ddof=1)).round(3)\n1.198\nなお、sqrt関数は平方根を計算するNumPyの関数です。"
  },
  {
    "objectID": "programming2025/programming-9.html#線形モデルからのサンプリング",
    "href": "programming2025/programming-9.html#線形モデルからのサンプリング",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "それではいよいよ、線形モデルからサンプリングを行います。この線形モデルでは、xという独立変数と、yという従属変数があるとします。次のようなモデルを考えましょう。\n# %%\ny = b0 + b1 * x + e\nここでb0が定数項(切片)、b1は傾き、eは正規分布に従う期待値0の乱数とします。以下では、このモデルからサンプリングによって得られた擬似的データに単回帰分析を行い、b0およびb1の推定値を求めます。なお、b1の推定値がいわゆる回帰係数となります。\n回帰分析において独立変数は定数として扱われますので、分布は何でも構いませんが、ここでは期待値8、標準偏差2の正規分布を仮定しましょう。また、乱数項の標準偏差は3であると仮定します。\n# %%\nimport numpy as np\nx = np.random.normal(8,2,100)\ne = np.random.normal(0,3,100)\ny = 1 + 2 * x + e\nこれで独立変数値の列x、乱数項の列e、従属変数値の列yが全て配列として得られました。yを求めるときにブロードキャストを利用して定数項とベクトルの演算を行ったことに注意してください。"
  },
  {
    "objectID": "programming2025/programming-9.html#単回帰分析",
    "href": "programming2025/programming-9.html#単回帰分析",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "単回帰分析には、SciPyモジュールを使います。SciPyにはstatsという統計モジュールが含まれていますので、それをインポートしましょう。\n# %%\nfrom scipy import stats\n上記のfrom-import命令では、scipyモジュールのstatsというサブモジュールだけを読み込んでいます。なお、一般に次のように書くことで、モジュールから、特定のサブモジュールや関数、属性(モジュール内のグローバル名前空間で定義されている変数)だけを読み込むことができます。\nfrom module import sub\nここでsubはサブモジュールあるいは関数名や属性名です。\n単回帰分析には、statsモジュール内のlinregress関数を使います。第1引数が独立変数で、第2引数が従属変数です。\n# %%\nres = stats.linregress(x,y)\ntype(res)\n# 出力\n\nscipy.stats._stats_mstats_common.LinregressResult\n上記のように、結果はLinregressionResult型のオブジェクトとして返されます。このオブジェクトは、以下の属性を持っています。\n\n\n\n属性\n意味\n\n\n\n\nslope\n回帰係数のOLS推定値\n\n\nstderr\nslopeの標準誤差\n\n\npvalue\nslopeのP値(両側t検定)\n\n\nrvalue\n相関係数R\n\n\nintercept\n切片のOLS推定値\n\n\nintercept_stderr\ninterceptの標準誤差\n\n\n\nこれらを順番に表示してみましょう。\n# %%\ncoeffs = ['slope','stderr','pvalue','rvalue','intercept','intercept_stderr']\nfor cf in coeffs:\n    value = round(eval(\"res.\" + cf),3)\n    print(cf + \": \",value)\n# 出力\n\nslope:  2.083\nstderr:  0.177\npvalue:  0.0\nrvalue:  0.765\nintercept:  1.058\nintercept_stderr:  1.425\n上記のように、傾きや切片が概ね正しく推定されています。また傾きのP値はほぼ0ですので、傾きが統計的に有意に0から離れていることが分かります。\nなお、linregressが計算するP値は両側検定のP値ですので、片側検定の場合はその半分の値となります。\nなお、上記のモデル、疑似データ、回帰直線をプロットすると、以下の図のようになります。オレンジの線が真のモデル、灰色の線が推定された回帰直線です。\nこうした図を作成する方法については、次回の講義で取り扱います。\n\n\n\nlinregress"
  },
  {
    "objectID": "programming2025/programming-9.html#行列の作成",
    "href": "programming2025/programming-9.html#行列の作成",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "初歩的なデータ解析においても重要になる2次元配列について、少し取り扱っておきたいと思います。\n1次元配列をベクトルであるとすれば、2次元配列は行列です。(matrixという行列を表す特別な型もありますが、本稿では扱いません。)行列を作るには、まず行列のもとになる入れ子になったリストを作成します。\n下図のような行列を作成するとします。\n\n\n\nmatrix\n\n\nこの場合、次のような入れ子のリストを作成します。\n# %%\narr_like = [[0,1,2],[3,4,5],[6,7,8]]\nこのリストにおいて、第1要素が行列の1行目、第2要素が2行目、第3要素が3行目に相当します。このarr_likeリストをNumPyのarray関数に渡すことにより、行列が作成されます。\n# %%\narr2d = np.array(arr_like)\narr2d\n# 出力\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\nもう一つの作り方は、1次元配列を作ってからreshapeメソッドによって行列化することです。\n# %%\narr_nums = np.arange(9).reshape((3,3))\narr_nums\nここでreshapeの引数には、(行数、列数)のタプルを与えます。\n# 出力\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])"
  },
  {
    "objectID": "programming2025/programming-9.html#行列のインデクシング",
    "href": "programming2025/programming-9.html#行列のインデクシング",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "配列の要素にアクセスするときは、行・列のインデックスをコンマでつないで指定します。\n# %%\n# 1行2列の要素\n\nprint(arr2d[1,2])\n# 出力\n5\n1次元のときと同じように、スライス記法も使用可能です。たとえば、0～1行目、1～2列目の部分行列を取り出したいときは、次のようにします。\n# %%\narr2d[0:2,1:3]\n# 出力\n\narray([[1, 2],\n       [4, 5]])\nただし、スライスで得られるのは、1次元配列の場合と同様コピーではなくビューであることに注意してください。\n# %%\narr2d_view = arr2d[0:2,1:3]\nnp.shares_memory(arr2d_view,arr2d)\n# 出力\nTrue\nインデックスを1つだけ指定すると、特定の行を取得できます。\n# %%\narr2d[1]\n# 出力\n\narray([3, 4, 5])\n列を取得するときは行をスライスする必要があります。\n# %%\narr2d[:,1]\n# 出力\narray([1, 4, 7])\nただしこのようにすると、戻されるビューは次元が落ちてしまいます。もとの配列の次元を維持するには、列もスライスにします。\n# %%\narr2d[:,1:2]\narray([[1],\n       [4],\n       [7]])"
  },
  {
    "objectID": "programming2025/programming-9.html#行列演算",
    "href": "programming2025/programming-9.html#行列演算",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "NumPyの行列には、通常の線形代数で用いるような行列演算がサポートされています。\n二つの行列の積をとるときは、演算子@を使います。\n# %%\narr1 = np.array([[1,2],[3,4]])\narr2 = np.array([[1,3],[2,4]])\narr3 = arr1 @ arr2\nprint(\"arr1:\")\nprint(arr1)\nprint(\"\\narr2:\")\nprint(arr2)\nprint(\"\\narr1 @ arr2:\")\nprint(arr3)\n# 出力\n\narr1:\n[[1 2]\n [3 4]]\n\narr2:\n[[1 3]\n [2 4]]\n\narr1 @ arr2:\n[[ 5 11]\n [11 25]]\n行列とベクトルの間の積についても、@が使えます。\n# %%\nvec1 = np.array([-1,5])\nvec2 = arr1 @ vec1\nprint(\"arr1:\")\nprint(arr1)\nprint(\"\\nvec1:\")\nprint(vec1)\nprint(\"\\narr1 @ vec2:\")\nprint(vec2)\n# 出力\narr1:\n[[1 2]\n [3 4]]\n\nvec1:\n[-1  5]\n\narr1 @ vec2:\n[ 9 17]\n行列の転置は、transposeメソッドもしくはT属性を用いることができます。\n# %%\nprint(\"arr1:\")\nprint(arr1)\nprint(\"\\narr1.T\")\nprint(arr1.T)\nprint(\"\\narr1.transpose()\")\nprint(arr1.transpose())\n# 出力\n\narr1:\n[[1 2]\n [3 4]]\n\narr1.T\n[[1 3]\n [2 4]]\n\narr1.transpose()\n[[1 3]\n [2 4]]"
  },
  {
    "objectID": "programming2025/programming-9.html#行列の記述統計量",
    "href": "programming2025/programming-9.html#行列の記述統計量",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "行列についても、記述統計量を計算するメソッドをそのまま使うことができます。たとえば、全ての要素の平均はmeanメソッドによって得られます。\n# %%\narr = np.arange(9).reshape((3,3))\nprint(\"arr:\")\nprint(arr)\nprint(\"\\narr.mean():\")\nprint(arr.mean())\n行ごとの平均、列ごとの平均をとるときは、axis引数を設定します。このとき、axis=0で行方向の平均(つまり列ごとの平均)、axis=1で列方向の平均(つまり行ごとの平均)を計算できます。\n# %%\narr = np.arange(9).reshape((3,3))\nprint(\"arr:\")\nprint(arr)\nprint(\"\\narr.mean(axis=0):\")\nprint(arr.mean(axis=0))\nprint(\"\\narr.mean(axis=1):\")\nprint(arr.mean(axis=1))\n# 出力\n\narr:\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\narr.mean(axis=0):\n[3. 4. 5.]\n\narr.mean(axis=1):\n[1. 4. 7.]\naxisの指定の仕方がRのmarginとは逆なので気を付けてください。Rのmargin=1がNumPy行列のaxis=1、margin=2がaxis=0に相当します。\naxis引数は、他の統計量関連のメソッド(sum、var、stdなど)でも利用可能ですので、調べてみてください。"
  },
  {
    "objectID": "programming2025/programming-9.html#行列のブロードキャスト",
    "href": "programming2025/programming-9.html#行列のブロードキャスト",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "行列においては、ブロードキャストにより、行列とベクトル、行列とスカラーの演算が可能になります。\n行列とスカラーの演算については、ベクトルの場合と同じで、スカラーの方が行列と同じ形状に変換されます。\n一方、行列とベクトルの演算については、ベクトルは、行列の行と同じ形状もしくは列と同じ形状をもつ必要があります。\nたとえば、次のように、ベクトルが行列の行と同じ形状をもつ場合、NumPyは当のベクトルを行方向に複製して行列にキャスト(型変換)します。\n# %%\narr = np.array([[1,2,3],[4,5,6]])\nvec = np.array([2,2,2])\nprint(\"arr:\")\nprint(arr)\nprint(\"\\nvec:\")\nprint(vec)\nprint(\"\\narr + vec:\")\nprint(arr + vec)\n同様に、ベクトルが行列の列と同じ形状を持つ場合は、列方向に複製することで行列にキャストされます。\n# %%\narr = np.array([[1,2,3],[4,5,6]])\nvec = np.array([[2],[2]])\nprint(\"arr:\")\nprint(arr)\nprint(\"\\nvec:\")\nprint(vec)\nprint(\"\\narr + vec:\")\nprint(arr + vec)\n# 出力\narr:\n[[1 2 3]\n [4 5 6]]\n\nvec:\n[[2], [2]]\n\narr + vec:\n[[3 4 5]\n [6 7 8]]"
  },
  {
    "objectID": "programming2025/programming-9.html#行列のデータ構造",
    "href": "programming2025/programming-9.html#行列のデータ構造",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "行列は、概念的には表の形をしていますが、メモリに物理的に格納される際には、1次元の配列として格納されています。\nこの事実は、行列のスライスをとってビューを作成してみると良く分かります。\n# %%\narr_like = [[1,2,3],[4,5,6],[7,8,9]]\narr = np.array(arr_like)\narr2 = arr[0:2,0:2]\n\nprint(\"Original:\")\nprint(arr)\nprint()\n\nfor key,value in arr.__array_interface__.items():\n    print(key,value)\n\nprint(\"\\nView:\")\nprint(arr2)\nprint()\n\nfor key,value in arr2.__array_interface__.items():\n    print(key,value)\n# 出力\n\nOriginal:\n[[0 1 2]\n [3 4 5]\n [6 7 8]]\n\ndata (1882324077584, False)\nstrides None\ndescr [('', '&lt;i4')]\ntypestr &lt;i4\nshape (3, 3)\nversion 3\n\nView:\n[[0 1]\n [3 4]]\n\ndata (1882324077584, False)\nstrides (12, 4)\ndescr [('', '&lt;i4')]\ntypestr &lt;i4\nshape (2, 2)\nversion 3\n重要なのは、ビューのストライドが(12,4)になっていることです。これは、\n\n次の行へ進むときは、12バイト先へ飛んでください\n次の列へ進むときは、4バイト先へ飛んでください\n\nという意味です。また、データの型は&lt;i4ですので、4バイト整数であることが分かります。すなわち、一つの数値で4バイトメモリを占有します。\nこれらを総合すると、データは実際には数のように直線的に格納されていて、それを行列の形に見せているだけだということが分かります。\n\n\n\nmatrixdata\n\n\nこのように、多次元配列構造を1次元的にメモリに保存することは計算機科学ではありふれたことですので、覚えておきましょう。\n(余談ですが、Rでは、FORTRAN型の行列を継承しており、データは列ごとにメモリに格納されますが、NumPyでは、C型の行列を継承しており、データは行ごとにメモリに格納されます。データ解析においては、列を変数、行をオブザベーションとすることがほとんどですので、FORTRAN型行列のほうが自然です。次回紹介するpandasのデータフレームでは、内部でNumPy行列を用いてデータを格納していますが、その際、NumPy行列の行をデータフレームの列として使うことで、FORTRAN型のデータフレームを実現しています。RとPythonがそれぞれ、FOTRANとCからどれだけ多くの物を受け継いでいるか調べてみてください。)"
  },
  {
    "objectID": "programming2025/programming-9.html#配列を作る様々な方法",
    "href": "programming2025/programming-9.html#配列を作る様々な方法",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "配列は様々な方法で作ることができます。配列を作成するNumPy関数の一部を以下に列挙しておきます。全ての配列作成関数についてはNumPyのリファレンスマニュアルを参照してください。\nまずは、形状を(行数、列数)のようにタプルで与える関数です。スカラーを与えると1次元配列になります。\n\n\n\n関数\n意味\n用例\n\n\n\n\nones\n全てが1の配列を作る\nnp.ones((2,3))\n\n\nzeros\n全てが0の配列を作る\nnp.zeros((2,3))\n\n\nfull\n全てが同じ値の配列を作る\nnp.full((2,3),5)\n\n\n\n次に、_like系の関数です。これらについては、ある既存の配列を引数に与えて、それと同じ形状の配列を作ります。\n\n\n\n関数\n意味\n用例\n\n\n\n\nones_like\n全てが1の配列を作る\nnp.ones_like(arr)\n\n\nzeros_like\n全てが0の配列を作る\nnp.zeros(arr)\n\n\nfull_like\n全てが同じ値の配列を作る\nnp.full(arr,5)"
  },
  {
    "objectID": "programming2025/programming-9.html#まとめ",
    "href": "programming2025/programming-9.html#まとめ",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "今回の講義では、以下のことを学びました。\n\nNumPy1次元配列の作成\nベクトル演算\n配列のスライスとビュー\n乱数の生成\n線形モデルのシミュレーション\nSciPyの単回帰分析\n行列の作成・操作\n行列のデータ構造\n記述統計量の計算\n\n分量の都合上、NumPy配列の機能のごく一部しか紹介できませんでした。NumPyのマスターはデータ分析において非常に重要ですので、参考書やNumPyのリファレンスマニュアルを読んで勉強しておいてください。\nまた、SciPyには、linalgというモジュールがあり、NumPy配列のための線形代数ライブラリを提供しています。例えば特異値分解(関数svd)など、多変量解析で不可欠になる機能が多数実装されているので、是非試していただきたいと思います。\n今回、3次元以上のNumPy配列については扱いませんでしたが、深層学習などの分野においては中心的な役割を演じる重要なデータ構造ですので、機会があれば資料に足していきたいと思います。"
  },
  {
    "objectID": "programming2025/programming-9.html#参考書",
    "href": "programming2025/programming-9.html#参考書",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "以下の参考書が、薄くて読みやすくかつ内容も大変充実しています。\n\n『NumPyによるデータ分析入門』(Umit Mert Cakmak, Mert Cuhadaroglu著、山崎 邦子 (翻訳), 山崎 康宏 (翻訳))(2019) オライリージャパン. ISBN-13: 978-4873118871."
  },
  {
    "objectID": "programming2025/programming-9.html#補遺",
    "href": "programming2025/programming-9.html#補遺",
    "title": "第9回 NumPy/SciPy入門",
    "section": "",
    "text": "スライスの代わりに、取り出したい行あるいは列を明示的にリストによって指定するインデクシングの方法をファンシーインデックス参照と言います。たとえば、arr2dから0行目と2行目だけを取り出したい場合は次のようにします。ファンシーインデックス参照を試してみなさい。そのうえで、それが元の配列のビューではなくコピーを作ることを確認し、なぜそのようになっているのか、ストライドの概念を用いて考察してみなさい。\n# %% \n# ファンシーインデックス参照\n# コピーを作る\nx = arr2d[[0,2],:]\nprint(x)\n\n# 見かけ上同じだがスライス記法\n# ビューを作る \ny = arr2d[0::2,:]\nprint(y)\nSciPyのlinalgモジュールを用いて、行列の固有値・固有ベクトルを計算してみなさい。\n以下のように3次元NumPy配列を作成し、それがどのように表示されるか確認しなさい。sumメソッドでAxis0、Axis1、Axis2方向に和をとり、何が起きているのか考察しなさい。\n# %%\narr3d = np.arange(27).reshape((3,3,3))\nsum0 = arr3d.sum(axis=0)\nsum1 = arr3d.sum(axis=1)\nsum2 = arr3d.sum(axis=2)\nndarrayのviewメソッドを用いると、データ型を変えたビューを作成することができます。以下では、array関数の引数dtype='&lt;i2'でリトルエンディアン2バイト整数型の配列xを作った後、viewメソッドのdtype='i1'引数で1バイト整数型のビューyを作っています。なぜyの出力がこのようになるのか、考察してみてください。さらに、yに何らかの演算を施して、xがどのように変化するか観察してみてください。\n# %%\nx = np.array([256,256],dtype='&lt;i2')\ny = x.view(dtype='i1')\nprint(y)\n# 出力\n[0 1 0 1]"
  },
  {
    "objectID": "programming2025/programming-6.html",
    "href": "programming2025/programming-6.html",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力\n\n標準ライブラリとは\nイテラブル\nタプル(tuple)\n文字列(str)\n\n練習1\n\nエンコーディング\nデコーディング\n\n練習2\n\n文字列オブジェクトのメモリ占有\nファイル入出力\n\nreadメソッドによる読み込み\nwriteメソッドによる書き込み\n行ごとの読み書き\nバイナリ編集\n\n文字列のメソッド\n\nreplace(部分文字列の置換)\ntranslate(文字の置換)\nsplit(文字列の分割)\njoin(文字列の結合)\n練習3\n\nまとめ\n参考書\n\n\n\n\n標準ライブラリとは、Pythonをインストールしたときに最初から使うことのできる一連のデータ型、関数、オブジェクトなどを差し、インタープリタに組み込まれているものとモジュールで提供されるものがあります。(ただし、モジュールの中にはビルトインモジュールというインタープリタと切り離せないモジュールもあります。mathやsysがそういった例です。ビルトインは組込みを意味します。)\n今回の講義では、ビルトインデータ型の中でも特に重要なイテラブルなデータ型について学んで行きます。その過程で、文字エンコーディング、ハッシュテーブル、ファイル入出力といったプログラミングにおける重要な事項について学んで行きましょう。\n\n\n\nイテラブルなデータ型とは、Python特有の概念で、大雑把にいうと、forループの繰り返し処理においてループインデックスの範囲指定に用いることができるデータ型のことです。つまり\n# %%\nfor i in index_range:\n    print(i)\nのようなコードでindex_rangeのところに配置できるものです。(イテラブルのより正確な定義はリファレンスマニュアルを参照。)\n組込みデータ型でイテラブルなものには主に次のようなものがあります。\n\nコンテナ\n\nシーケンス\n\nリスト(list)\nタプル(tuple)\nレンジ(range)\n\n集合(set)\n辞書(dict)\n\n文字列(str)\nバイト(bytes)\n\nこれらのデータ型には、ミュータブルなもの・イミュータブルなもの、インデックスやキーによって要素を取得できるもの・できないものといった違いがあります。\n\n\n\n型\nmutable\nindex\nkey\nslice\nhashable\n和・積\n制約\n\n\n\n\nlist\nyes\nyes\nno\nyes\nno\nyes\nno\n\n\ntuple\nno\nyes\nno\nyes\nyes/no\nyes\nno\n\n\nrange\nno\nyes\nno\nyes\nyes\nno\nN/A\n\n\nstr\nno\nyes\nno\nyes\nyes\nyes\nN/A\n\n\nset\nyes\nno\nno\nno\nno\nno\nyes\n\n\ndict\nyes\nno\nyes\nno\nno\nno\nyes\n\n\n\nなお、上記の表の各列は次のような意味です。\n\n\n\n列名\n意味\n\n\n\n\nmutable\nミュータブルかどうか\n\n\nindex\nインデックス参照可能かどうか\n\n\nkey\nキーで値を取得可能かどうか\n\n\nslice\nスライス記法を許すかどうか\n\n\nhashable\nハッシュ可能かどうか\n\n\n和・積\n+、*演算子を受け付けるか\n\n\n制約\n要素の型に制約があるか\n\n\n\nkeyとhashableについては辞書を説明するときに解説します。\nリストやレンジについては前回解説しましたので、今回はそれ以外の型(タプル、文字列、辞書、集合)について説明します。バイト型も重要ですが、時間の都合で詳細な解説を割愛します。\n\n\n\nタプルは以下のような性質をもちます。\n\nイテラブル\nイミュータブル\nインデックス参照可能\nスライス参照可能\n任意のオブジェクトを要素に持てる\n算術演算(和・積)可能\n\nタプルは、リストと同じくシーケンス型に分類されますが、イミュータブルなデータ型です。タプルは、リストをイミュータブルにしたものと考えてほとんど間違いありません。リストと同じく、要素オブジェクトへの参照を格納しています。\nリストと同じくインデックス番号やスライスで要素にアクセスでき、どのようなPythonオブジェクトでも要素に持てます。\nforループにおける使用方法はリストと同じです。\n# 1,2,3と印字\nfor i in (1,2,3):\n    print(i)\nイミュータブルなので、要素への代入操作は禁止されています。\n&gt;&gt;&gt; x = ('foo','bar','baz')\n&gt;&gt;&gt; x[0] = 'Python'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\nタプルの使用において注意しなくてはならないのは、タプルのようなイミュータブルなコンテナ型というのは、要素への参照の変更が禁止されているだけで、参照先の要素オブジェクトの変更は禁止されていないということです。したがって、タプルはイミュータブルですが、次のように要素オブジェクトに変更を加えることは可能です。\n&gt;&gt;&gt; x = ('foo','bar',['baz'])\n&gt;&gt;&gt; x[2].append('BAZ')\n&gt;&gt;&gt; x\n('foo', 'bar', ['baz', 'BAZ'])\nリストと同じくタプルはインデクシングやスライス記法を受け付けます。\n&gt;&gt;&gt; x = (1,2,3,4,5)\n&gt;&gt;&gt; x[1:4]\n(2, 3, 4)\n&gt;&gt;&gt; x[3]\n4\n&gt;&gt;&gt; x[:]\n(1, 2, 3, 4, 5)\nなお、一つしか要素のないタプルを作るためには、次のように、余分なカンマが一つ必要です。\n&gt;&gt;&gt; x = (1,)    # 一つしか要素のないタプル\n&gt;&gt;&gt; x\n(1,)\n&gt;&gt;&gt; type(x)\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; x = (1)     # これだとただの整数\n&gt;&gt;&gt; x\n1\n&gt;&gt;&gt; type(x)\n&lt;class 'int'&gt;\nなおここで用いたtype関数は引数にあたえたオブジェクトの型を調べるビルトイン関数です。\nタプルはリストと同じように+演算子、*演算子を受け付けます。\n&gt;&gt;&gt; x = (1,2) + (3,4)\n&gt;&gt;&gt; x\n(1, 2, 3, 4)\n&gt;&gt;&gt; x = (1,2) * 3\n&gt;&gt;&gt; x\n(1, 2, 1, 2, 1, 2)\nただし、リストと同じで掛け算はシャローコピーですので、やはり次のような挙動には注意しましょう。\n&gt;&gt;&gt; x = ((1,[]),) * 3\n&gt;&gt;&gt; x\n((1, []), (1, []), (1, []))\n&gt;&gt;&gt; x[0][1].append(2)\n&gt;&gt;&gt; x\n((1, [2]), (1, [2]), (1, [2]))\nリストと比べたときのタプルの利点としては、それが辞書のキーとして用いることができるということです。これについては辞書の欄で詳しく述べます。\n\n\n\nPythonの文字列型はRと同じくダブルもしくはシングルクォーテーションによって作成でき、以下のような性質を持ちます。\n\nイテラブル\nイミュータブル\nインデックス参照可能\nスライス参照可能\n算術演算可能\n\nforループで用いると、一文字ずつループインデックスに渡されます。\n# \"HELLO WORLD!\"を一文字ずつ印字\nfor c in \"HELLO WORLD!\":\n    print(c,end='--')\nprint()\n# 結果\nH--E--L--L--O-- --W--O--R--L--D--!--\n文字列は、インデックスで各文字に、スライスで部分文字列にアクセスできます。イミュータブルなので、変更は一切不可能です。\n文字列は+演算子や*演算子を受け付けます。\n&gt;&gt;&gt; x = \"Hello, \" + \"World!\"\n&gt;&gt;&gt; x\n'Hello, World!'\n&gt;&gt;&gt; print(x)\nHello, World!\n&gt;&gt;&gt;\n&gt;&gt;&gt; x = \"knock, \" * 10\n&gt;&gt;&gt; print(x)\nknock, knock, knock, knock, knock, knock, knock, knock, knock, knock,\n\n\n文字列を1文字ずつ処理する練習です。文字列”Hello, World!“を一文字ずつ画面に印字し、’l’の後でのみ改行して出力するPythonコードを作成しなさい。出力は以下のようになります。\n# 出力\nHel\nl\no, Worl\nd!\n\n\n\n\n文字列は、イテラブルですが、コンテナ型ではありません。レンジ以外のビルトインのコンテナ型は、要素オブジェクトへの参照を格納していますが、文字列オブジェクトは、文字への参照ではなく文字そのものを格納した配列を内部にもっています。\n\n\n\nstring\n\n\n文字をメモリ上に格納する為には、文字をバイト列に変換しなくてはなりません。これをエンコーディングと言います。文字をエンコードするには様々な方式があり、そのうち有名なものはutf-8やshift-jisなどがあります。\n\n\n\n文字\nshift_jis\neuc_jp\nutf_8\n\n\n\n\nあ\n0x82a0\n0xa4a2\n0xe38182\n\n\n山\n0x8e52\n0xbbb3\n0xe5b1b1\n\n\n\n文字列が特定のエンコーディングによってどのようなバイト列になるのかは、文字列メソッドのencodeによって確かめることができます。encodeメソッドはバイト型のオブジェクトを返します。\n&gt;&gt;&gt; x = 'あ'.encode('shift-jis')\n&gt;&gt;&gt; x\nb'\\x82\\xa0'\n&gt;&gt;&gt; x.hex()\n'82a0'\nバイト型については解説しませんが、上記のようにhexというメソッドによって、16進数の文字列に変換することができます。\n次のコードは、ひらがなの50音をutf-8のコードで書きだすためのPythonコードです。\n# %%\na = 'あいうえお'\nk = 'かきくけこ'\ns = 'さしすせそ'\nt = 'たちつてと'\nn = 'なにぬねの'\nh = 'はひふへほ'\nm = 'まみむめも'\ny = 'や　ゆ　よ'\nr = 'らりるれろ'\nw = 'わ　　　を'\nnn = 'ん　　　　'\nx = [a,k,s,t,n,h,m,y,r,w,nn]\nfor line in x:\n    print(line,end=' --&gt; ')\n    for char in line:\n        print(char.encode('utf-8').hex(),end=' ')\n    print()\n結果は次のようになります。\n# 出力\nあいうえお --&gt; e38182 e38184 e38186 e38188 e3818a \nかきくけこ --&gt; e3818b e3818d e3818f e38191 e38193 \nさしすせそ --&gt; e38195 e38197 e38199 e3819b e3819d \nたちつてと --&gt; e3819f e381a1 e381a4 e381a6 e381a8 \nなにぬねの --&gt; e381aa e381ab e381ac e381ad e381ae \nはひふへほ --&gt; e381af e381b2 e381b5 e381b8 e381bb \nまみむめも --&gt; e381be e381bf e38280 e38281 e38282 \nや　ゆ　よ --&gt; e38284 e38080 e38286 e38080 e38288 \nらりるれろ --&gt; e38289 e3828a e3828b e3828c e3828d \nわ　　　を --&gt; e3828f e38080 e38080 e38080 e38292 \nん　　　　 --&gt; e38293 e38080 e38080 e38080 e38080 \nこのようにutf-8は全てのひらがなに3バイトを使っています。なお、ここでは、\nchar.encode('utf-8').hex()\nのように、encodeメソッドとhexメソッドをつなげています。これは、一つ目のメソッドの戻り値のオブジェクトであるバイトオブジェクトがもつhexメソッドを呼び出していることに相当します。この記法をメソッドチェーンと呼び、1つめのメソッドの戻り値には関心がない場合に便利な記法です。\nなお、同じエンコーディング方式、同じシンボルでも半角文字と全角文字では異なるバイト列にエンコードされます。プログラミングの初心者にありがちなミスは半角カッコの代わりに全角カッコをつかってしまうことですが、これらがutf-8でどのように異なるのか調べてみましょう。\n# %%\n'('.encode('utf-8').hex()   # 半角カッコ\n'（'.encode('utf-8').hex()  # 全角カッコ\n# 実行結果\n28\nefbc88\nこのように、半角カッコは0x28という1バイトであるのに対し、全角カッコは0xefbc88という3バイトの列です。インタープリタはこれらを違う文字として解釈するので、エラーを出します。\nたとえば、わざと半角カッコの代わりに全角カッコを使ってタプルを作ってみましょう。\n# %%\n# 1つめのカッコが全角になっている\nx = （5,4,3)\n# 出力\n\nx = （5,4,3)\n  File \"&lt;ipython-input-32-7b09692778be&gt;\", line 1\n    x = （5,4,3)\n         ^\nSyntaxError: invalid character in identifier\n\n\n\nエンコーディングの逆の変換、すなわちバイト列を文字列に変換する操作をデコーディングと言います。Pythonでは、バイトオブジェクトのdecodeメソッドを用いて行うことができます。\n&gt;&gt;&gt; thanks_str = 'ありがとう'\n&gt;&gt;&gt; thanks_bytes = thanks_str.encode('utf-8')\n&gt;&gt;&gt; thanks_bytes\nb'\\xe3\\x81\\x82\\xe3\\x82\\x8a\\xe3\\x81\\x8c\\xe3\\x81\\xa8\\xe3\\x81\\x86'\n&gt;&gt;&gt; thanks_bytes.hex()\n'e38182e3828ae3818ce381a8e38186'\n&gt;&gt;&gt; thanks_bytes.decode('utf-8')   # デコーディング\n'ありがとう'\nエンコーディングに用いた方式と異なる方式でテキストをデコードしたときに生じる現象を俗に文字化けと呼びます。文字化けはPython上で引き起こすことが可能です。\nたとえば6文字の文字列’ありがとう！’(全て全角)はutf-8で18バイトになります。\n# %%\nx = 'ありがとう！'.encode('utf-8')\nprint('バイト列 = ',x.hex())\nprint('バイト数 = ',len(x))\n# 出力\nバイト列 =  e38182e3828ae3818ce381a8e38186efbc81\nバイト数 =  18\nこれを1文字2バイトのutf-16の9文字としてデコードしてみましょう(utf-16はBMPと呼ばれる基本的な文字群を2バイトで表します)。\ny = x.decode('utf-16','replace')\nprint('文字列 = ',y)\nprint('文字数 = ',len(y))\nここで第2引数replaceは、デコードできない文字を何らかの適当な文字で置き換えるというオプションです。\n# 出力\n文字列 =  臣誂臣ꢁ臣膼\n文字数 =  9\nこのようにutf-16では予想されたとおり9文字となりましたが、文字化けが生じました。\nなお、デコードできない文字を置き換えるのではなく除去してデコードさせる場合は、decodeメソッドの第2引数にignoreを設定してください。\n\n\nアルファベットの全ての小文字と大文字をutf-8にエンコードして16進数で印字するPythonコードを作成しなさい。出力は以下のようになります。(スペース上の制約のため5文字ごとに改行していますが、これはなくても構いません。)また、結果はasciiコードでも等しいことを確かめなさい。(asciiにエンコードする。)\n# 出力\na:61 b:62 c:63 d:64 e:65\nf:66 g:67 h:68 i:69 j:6a\nk:6b l:6c m:6d n:6e o:6f\np:70 q:71 r:72 s:73 t:74\nu:75 v:76 w:77 x:78 y:79\nz:7a A:41 B:42 C:43 D:44\nE:45 F:46 G:47 H:48 I:49\nJ:4a K:4b L:4c M:4d N:4e\nO:4f P:50 Q:51 R:52 S:53\nT:54 U:55 V:56 W:57 X:58\nY:59 Z:5a \n\n\n\n\n文字列オブジェクトのメモリ消費量はどのくらいになるでしょうか？1バイトでは256通りの状態を表すことができることを思い出しましょう。従って、1文字に1バイトを確保すれば、最大256文字を区別することができます。アルファベットと幾つかの記号くらいなら、これで十分です。\nしかしながら、ひらがなや漢字が混じると、256文字では足りませんので、最低でも2バイトのメモリが必要です。さらに滅多に使わないような記号まで含めると、2バイトでも足りません。\nそれぞれのバイト数で表現できる最大文字数は次の通りです。\n\n\n\nバイト数\n最大文字数\n\n\n\n\n1\n2**8 == 256\n\n\n2\n2**16 == 65,536\n\n\n4\n2**32 == 4,294,967,296\n\n\n\n文字エンコーディングには可変長エンコーディングと固定長エンコーディングがあります。可変長エンコーディングでは文字によってバイト数が異なりますが、固定長エンコーディングでは全ての文字で同じバイト数を使います。実装上の問題で、Pythonの文字列オブジェクトは内部で固定長エンコーディングを用いています。\nさて、1文字のバイト数を小さくするとメモリ消費量は節約できますが、表現できる文字数は小さくなります。一方、1文字のバイト数を大きくすると、表現できる文字数は多くなりますが、メモリ消費量は大きくなってしまいます。\nPythonはこうしたジレンマを解決するため、文字列の種類によって内部で異なるエンコーディングを使い分けています。アルファベットなどのシンプルな文字列は1バイト文字列で、ひらがなや漢字等が入ったより広い範囲の文字列には2バイトあるいは4バイト文字列を使います。\n次のコードは、Python文字列が一文字あたり何バイト使っているかを調べるためのものです。\n# アルファベットaの場合\nimport sys\nchar = \"a\"\nx = \"\"\nfor i in range(10):\n    x += char\n    print(x,end=\" --&gt; \")\n    print(sys.getsizeof(x))\n上のコードで、“x += char”は、“x = x + char”と全く同じ意味で、単なる別表現であることに注意してください。それ以外は、これまで習った知識しか使っていません。\n出力は次のようになります。\n# 出力。オーバーヘッドは49Byte(環境依存)\na --&gt; 50\naa --&gt; 51\naaa --&gt; 52\naaaa --&gt; 53\naaaaa --&gt; 54\naaaaaa --&gt; 55\naaaaaaa --&gt; 56\naaaaaaaa --&gt; 57\naaaaaaaaa --&gt; 58\naaaaaaaaaa --&gt; 59\nひらがなにすると以下のようになります。\n# ひらがな「あ」の場合\nimport sys\nchar = \"あ\"\nx = \"\"\nfor i in range(10):\n    x += char\n    print(x,end=\" --&gt; \")\n    print(sys.getsizeof(x))\n# 出力。オーバーヘッドは74Byte(環境依存)\n# ひらがな「あ」の場合\nあ --&gt; 76\nああ --&gt; 78\nあああ --&gt; 80\nああああ --&gt; 82\nあああああ --&gt; 84\nああああああ --&gt; 86\nあああああああ --&gt; 88\nああああああああ --&gt; 90\nあああああああああ --&gt; 92\nああああああああああ --&gt; 94\nさらに絵文字の場合です。\n# 絵文字の場合\nimport sys\nchar = \"🐼\"\nx = \"\"\nfor i in range(10):\n    x += char\n    print(x,end=\" --&gt; \")\n    print(sys.getsizeof(x))\n# 出力。オーバーヘッドは76Byte(環境依存)\n# 絵文字の場合\n🐼 --&gt; 80\n🐼🐼 --&gt; 84\n🐼🐼🐼 --&gt; 88\n🐼🐼🐼🐼 --&gt; 92\n🐼🐼🐼🐼🐼 --&gt; 96\n🐼🐼🐼🐼🐼🐼 --&gt; 100\n🐼🐼🐼🐼🐼🐼🐼 --&gt; 104\n🐼🐼🐼🐼🐼🐼🐼🐼 --&gt; 108\n🐼🐼🐼🐼🐼🐼🐼🐼🐼 --&gt; 112\n🐼🐼🐼🐼🐼🐼🐼🐼🐼🐼 --&gt; 116\nこのように、文字の種類に応じて1、2、4バイト文字を使い分けていることが分かります。\nしかしながら、通常プログラマはメモリ容量を気にしているのでない限り、こうしたインタープリタ内部でのエンコーディングを気にする必要はありません。プログラマがエンコーディングを気にしなければならないのは、ファイルの読み書きのときです。プログラマは文字をファイルに保存する際に、エンコーディングを自由に選べます。プログラマがエンコーディングを指定しない場合、Pythonはデフォルトでutf-8を用います。\n\n\n\n\n\nここでは、特定のエンコーディングで保存されたテキストファイルを開いて、テキストをPythonの文字列オブジェクトに読み込み、エンコーディングを変えて別のファイルに保存する作業を行ってみましょう。これはPythonの非常に実用的な用途です。\nGitHubディレクトリの下に”change_encoding”というフォルダを作って、その中でVS Codeを開いてください。VS Codeを開いたら、change_encodingフォルダの中に”euc_jp.txt”というファイルを新規作成して開いてください。\nこの状態でVS Codeの画面の右下を見ると、青いバーの上にUTF-8という表示が見られるはずです。\n\n\n\nutf-8\n\n\nこれは、このファイルが現在UTF-8エンコーディングで開かれていることを意味します。この表示をクリックすると、パレットが開き、\n\nエンコード付きで再度開く\nエンコード付きで保存する\n\nのどちらかを選べるようになりますので、1のエンコード付きで再度開くを選びます。すると、エンコードを選択するパレットに変化しますので、euc-jpと入力してリターンします。すると、右下の表記がEUC-JPに変化します。\n\n\n\neuc-jp\n\n\nこれで、現在テキストファイルeuc_jp.txtはeuc_jpエンコードで開かれた状態になりました。この状態で文章を記入して保存すると、euc_jpエンコーディングで保存されることになります。\nどのような文章を入力しても良いのですが、ここでは、\nこの文章のエンコーディングをeuc_jpからshift_jisに変更します。\nと入力して保存しましょう。ファイルを保存したら閉じてください。\nそれでは準備ができたので、いよいよPythonからファイルを開きましょう。VS Code上で、euc_jp.txtと同じフォルダの中に、change_encoding.pyというファイルを作り開いてください。ここに目的のコードを記述して実行しましょう。\nテキストファイルを開くには、ビルトイン関数のopenを使います。openは、with命令と共に使うのが普通ですので、セットで覚えましょう。\n# %%\nwith open('./euc_jp.txt','r',encoding='euc_jp') as file:\n    text = file.read()\nこの構文では、開かれたファイルは、ファイルオブジェクトとしてfileという変数に代入されます。openの第1引数はファイル名、'r'は「読み込み専用」を意味し、encoding引数はファイルのエンコーディングを表します。ここでは'euc_jp'を指定しています。\nファイルオブジェクトにはファイルを操作するためのメソッド群があり、readメソッドはその内容を読み込んで一つの文字列として返します。上記コードではその戻り値をtextという変数に代入しています。\nファイルオブジェクトは、open関数によって開いたら、使い終わったあとにcloseメソッドによって必ず閉じなければなりません。「どうせ必ず閉じるなら、いつ閉じるかを予め指定して開けばいいのでは？」と思うかもしれません。そのために導入されたのがwith命令です。with命令とともにファイルを開くと、withブロックが終了したときに自動的にファイルがクローズします。withを使うとファイルの閉じ忘れがないので、ファイルを使うときは特に理由がない限りwithで開くようにしましょう。\nこれで、変数textに読み込まれたファイル内の文章が文字列オブジェクトとして代入されました。ためしに表示してみましょう。\n# %%\nprint(text)\n# 出力\nこのファイルのエンコーディングをeuc_jpからshift_jisに変更します。\n\n\n\nあとはこれをエンコーディングを指定して別のファイルに保存するだけです。ファイルへの書き込みは次のようにします。\n# %%\nwith open('./shift_jis.txt','w',encoding='shift_jis') as file:\n    file.write(text)\n読み込みのときとよく似ていますが、openの第1引数は新しいファイルの名前です。ここでは'shift_jis.txt'とします。第2引数の'w'は「書き込み」を意味します。最後にencoding引数は'shift_jis'にしておきましょう。\n開いたファイルへ変数textを書き込むには上記のようにwriteメソッドを使います。引数には文字列オブジェクトを与えます。\nそれでは、VS Codeのファイルエクスプローラを見てみましょう。shift_jis.txtというファイルが新しく出来ているはずなので、開いてみてください。中身は\nこのファイルのエンコーディングをeuc_jpからshift_jisに変更します。\nとなっているはずですが、VS Codeの右下のバーを見てみると、表記がShift JISになっているはずです。これはこのファイルがshift_jisでエンコードされていることを表していますので、めでたくエンコーディングの変換ができたことになります。\n\n\n\nshift_jis\n\n\n\n\n\n上では、ファイルの中身を一気に読みだして一つの文字列に格納しましたが、行ごとに読み込む方法もあります。以下のような内容を記述したテキストファイルlines.txtを作成して保存してください。\n昔々、\nある所に\nおじいさんと\nおばあさんが\n住んでいました。\nこのファイルから行ごとにテキストを読み出すには、次のようにします。\n# %%\nwith open('./lines.txt','r') as file:\n  text_lines = file.readlines()\nprint(text_lines)\n結果はリストで得られます。\n# 出力\n['昔々、\\n', 'ある所に\\n', 'おじいさんと\\n', 'おばあさんが\\n', '住んでいました。']\nこのように、readlinesメソッドでは行末の改行記号は除去されません。改行を除去したい場合は、次のように書くことができます。\n# %%\nwith open('./lines.txt','r') as file:\n  text_lines = file.read().splitlines()\nprint(text_lines)\n# 出力\n['昔々、', 'ある所に', 'おじいさんと', 'おばあさんが', '住んでいました。']\nsplitlinesは文字列のメソッドであり、文字列を改行で分割し、得られた行のリストを返します(教科書セクション5.2.8参照)。\nreadlinesの逆の操作、すなわち行のリストをファイルに書き込むときは、次のようにwritelinesメソッドを用います。\n# %%\nwith open('./output_lines.txt','w') as file:\n  file.writelines(text_lines)\nただし、この方法では各行の末尾に改行は追加されません。改行を挿入するにはたとえば次のような方法があります。\n# %%\nwith open('./output_lines.txt','w') as file:\n  file.write(\"\\n\".join(text_lines))\njoinは文字列を結合するメソッドであり、後ほど説明します。\n\n\n\nそれでは、ファイル入出力もマスターしたことですので、ファイルのバイナリ情報(バイト列)を直接編集してみたいと思います。\nこれまでは、文字とバイト列の翻訳をPythonに任せていましたが、今度は、直接コンピュータの言葉であるバイナリ情報をファイルに書き込むということです。ここでは、「こんにちは」という文字列が書かれたテキストをバイナリ編集で作ってみましょう。エンコーディングは何でもいいですが、utf-8にしておきましょう。\nすでに上でひらがなのutf-8コード表をつくりましたので、これを使って「こんにちは」のバイト列を構成しましょう。バイト列を構成するには、バイトの列をリストにしてbytes関数に渡します。ここで、たとえば「こ」は0xe38193ですので、3つのバイトのリスト[0xe3,0x81,0x93]になることに注意してください。\n# %%\nthanks = bytes([0xe3,0x81,0x93,\n0xe3,0x82,0x93,\n0xe3,0x81,0xab,\n0xe3,0x81,0xa1,\n0xe3,0x81,0xaf])\nprint(thanks)\n# 出力\n\nb'\\xe3\\x81\\x93\\xe3\\x82\\x93\\xe3\\x81\\xab\\xe3\\x81\\xa1\\xe3\\x81\\xaf'\n次はこれをファイルに書き込んでいきます。ファイル名は”howareyou.txt”にしましょう。バイナリ情報の書き込みは、モードを”bw”にしてオープンします。’b’がバイナリ、’w’が書き込みを意味します。\n# %%\nwith open('howareyou.txt','bw') as file:\n    file.write(thanks)\n’howareyou.txt’というテキストファイルが出来ているはずですので、開いてみてください。ちゃんと「こんにちは」と書かれていたら成功です。エンコーディングもutf-8になっていることをVS Codeで確認しましょう。\n上記で、バイト列を構成する際も、ファイルをオープンするときも、一切utf-8であるということをPythonに教えなかったことに注意してください。utf-8であるということは、ファイルを開くときに初めてVS Codeに認識されたのです。\nつまるところは、テキストファイルの読み書きとは、こういうものであることを分かって頂ければ幸いです。\n\n\n\n\n文字列オブジェクトは様々なメソッドを備えており、それらを用いて文字列を操作することが可能です。\n\n\nreplaceメソッドを用いると、文字列の中の特定の部分文字列を全て別の部分文字列に置換することができます。たとえば、次のようにすれば、sentence文字列オブジェクトの中の\"パイソン\"を全て\"Python\"で置き換えることができます。\n# %%\nsentence = \"パイソンは言語です。パイソンは動物ではありません。\"\nsetence2 = sentence.replace('パイソン','Python')\nprint(sentence2)\n# 出力\nPythonは言語です。Pythonは動物ではありません。\nさらに、メソッドチェーン(メソッドを繋げる)を用いれば、部分文字列の置換を連続して複数回お行うことができます。たとえば、以下のコードでは、sentence文字列オブジェクトの中の\"パイソン\"を全て\"Python\"で置き換えたあと、句点\"。\"を全角エクスクラメーションマーク\"！\"で置き換えています。\n# %%\nsentence = \"パイソンは言語です。パイソンは動物ではありません。\"\nsetence3 = sentence.replace('パイソン','Python').replace('。','！')\nprint(sentence3)\n# 出力\nPythonは言語です！Pythonは動物ではありません！\n\n\n\nそれではここで、せっかくですので、ここまで学んだことの応用として、多少役に立つコードを作りましょう。Pythonスクリプトを読み込んで、全角括弧を半角括弧に変換するコードを作りたいと思います。\nそのためには、まずどの文字をどの文字に置き換えるのかを示した次のような辞書を作成する必要があります。\n\n\n\n置き換え前\n置き換え後\n\n\n\n\n（\n(\n\n\n）\n)\n\n\n\n分かりにくいですが、置き換え前が全角で、置き換え後が半角です。Pythonで実装してみましょう。Pythonの辞書型については、次回の講義で詳しく解説しますが、たとえば文字’A’を文字’a’に、文字’B’を文字’b’に変換したい場合は、次のように、書きます。\n# 辞書の形式\ntrans_rule = {'A':'a','B':'b'}\n辞書型の用語で、コロンの左側の文字をキー、右側の文字を値と呼びます。上の例では、’A’と’B’がキーで、’a’と’b’が値です。\n同じように、全角括弧’（‘を半角括弧’(‘に、全角括弧’）‘を半角括弧’)’に置き換えたい場合は、次のように書きます。\n# %%\n# 変換ルールを定義する辞書\ntrans_rule = {'（':'(','）':')'}\nさてこれから、文字列オブジェクトのtranslateというメソッドと、上で定義した変換ルール辞書trans_ruleを使って、文字列中の全角括弧を半角括弧に置き換えます。\nまず、全角括弧を使った「悪いコードの例」を作って実行してみましょう。\n# %%\nbad_code = \"print（'Hello, World!'）\"\nexec(bad_code)\nexec関数は、文字列をPythonコードとして実行するための関数です。以下、出力です。\n# 出力\nTraceback (most recent call last):\n\n  --- (中略) ---\n\n  File \"&lt;ipython-input-1-1a4bddd34732&gt;\", line 2, in &lt;module&gt;\n    exec(bad_code)\n\n  File \"&lt;string&gt;\", line 1\n    print（'Hello, World!'）\n         ^\nSyntaxError: invalid character in identifier\n案の定、エラーが出ました。\nそれでは、次に、bad_code内の全角括弧を半角括弧に置換して、正しく動くコードを作りましょう。次のように、文字列型のmaketransメソッドと、translateメソッドという二つのメソッド、および上記で作成した変換用辞書を用います。\n# %%\ntrans = str.maketrans(trans_rule)\ngood_code = bad_code.translate(trans)\nprint(good_code)\nexec(good_code)\nここで、maketransは、変換ルール辞書trans_ruleを、translateメソッドにおいて使用可能な形式に変換するだけのメソッドです。以下は出力です。\n# 出力\nprint('Hello, World!')\nHello, World!\n次は正しく動作しました。\n尚、上記のコードで2点注意事項があります。一つは、maketransメソッドが、文字列オブジェクトではなく、文字列型を意味するstrから呼び出されていることです。このように、オブジェクトからではなく、データ型名から呼び出すことの出来るメソッドを、クラスメソッドと呼びます。それに対して、オブジェクトから呼び出さなくてはならないtranslateのようなメソッドをインスタンスメソッドと呼びます。(クラスやインスタンスといった用語については、後の講義で解説します。)\n2点目は、maketransメソッドの戻り値transです。これを表示してみましょう。\n# %%\nprint(type(trans))\nprint(trans)\n# 出力\n&lt;class 'dict'&gt;\n{65288: '(', 65289: ')'}\nこのように、maketransの戻り値は辞書です。ただ、キーが文字列から数字に置き換えられています。この数字は、もとの文字をUnicodeコードポイントに置き換えたものです。Unicodeコードポイントとは、全てのユニコード文字に付けられた一意な数字で、文字のID番号のようなものです。\nコードポイントと文字を変換するには、関数chrとordを使います。\n\n\n\n関数\n変換方向\n\n\n\n\nchr\nコードポイントから文字\n\n\nord\n文字からコードポイント\n\n\n\n以下のように使います。\n&gt;&gt;&gt; ord('a')\n97\n&gt;&gt;&gt; chr(97)\n'a'\nそれでは、せっかくですから、全ての小文字アルファベットのコードポイントを出力するコードを書いておきましょう。\n# %%\nfor i in range(ord('a'),ord('z')+1):\n    if (i-ord('a'))%5 == 4:\n        end_str = '\\n'\n    else:\n        end_str = '\\t'\n    print(chr(i) + \"/\" + str(i),end=end_str)\nここで、\\tはタブキーを表すエスケープシーケンスです。エスケープシーケンスが分からない人は教科書を読んでおいてください。str(i)は、数字iを文字列に変換しています。\n# 出力\na/97    b/98    c/99    d/100   e/101\nf/102   g/103   h/104   i/105   j/106\nk/107   l/108   m/109   n/110   o/111\np/112   q/113   r/114   s/115   t/116\nu/117   v/118   w/119   x/120   y/121\nz/122\nここで扱ったものの他にも、文字列型には便利なメソッドがたくさんあるので、教科書のセクション5.2を良く読んで調べておいてください。\n\n\n\nテキスト分析を行っていると、文字列を特定の部分文字列が現れる箇所で分割したいことがあります。そのような操作は、splitメソッドで行うことができます。例えば、次のコードは、文字列オブジェクトsentenceを、\"は\"が現れる箇所で分割し、結果をsentence2に代入します。\n# %%\nsentence = \"パイソンは言語です。パイソンは動物ではありません。\"\nsplit_result = sentence.split('は')\nprint(split_result)\n結果はリストで返されます。\n# 出力\n['パイソン', '言語です。パイソン', '動物で', 'ありません。']\nよくある操作は、長いテキストを改行文字('\\n')で分割することによって、段落を取り出したり、句点やピリオドで分割することで文を取り出したりするものです。その際、取り出した文の前後の空白を除去したい場合がありますが、そのような場合には、stripメソッドを用いることができます(教科書のセクション5.2.6を参照)。なお、改行で分割する場合は、splitlinesメソッドを用いることも可能です(教科書セクション5.2.8参照)\n\n\n\nsplitメソッドとセットで覚えて置きたいメソッドは、文字列を結合するjoinメソッドです。joinはsplitの逆変換にあたり、文字列のリストを結合することができます。たとえば、次のコードは、上で作成した文字列のリストsplit_resultを、\"は\"で結合して一つの文字列に戻します。\n# %%\njoin_result = \"は\".join(split_result)\nprint(join_result)\n# 出力\nパイソンは言語です。パイソンは動物ではありません。\nリスト内の文字列を単純に結合したい場合は、空文字列を使って\n# %%\n# 単純にリスト内の文字列を結合\n\"\".join(split_result)\nのようにします。\n\n\n\n以下の文章を’momotaro.txt’というテキストファイルに保存しなさい。\n\n昔々、ある所に、おじいさんと、おばあさんが住んでいました。ある朝、おじいさんは山へ芝刈りに、おばあさんは川へ洗濯に行きました。おばあさんが川で洗濯をしていると、川上から大きな桃が、どんぶらこ、どんぶらこと流れてきました。\n\n上記の文章を読み込んで、読点「、」をコンマ’,‘に、句点「。」をピリオド’.’に置き換えた文章を’momotaro2.txt’に出力するPythonコードを作成しなさい。ただしエンコーディングは’euc_jp’とする。\n\n\n\n\n今回は、以下のことを学びました。\n\nタプルの性質\n文字列の性質\nエンコーディング\nデコーディング\nファイル入出力\n文字列のメソッド\n\nタプルや文字列は非常に重要なデータ型です。教科書を良く読み、どのような操作が可能であるのかを確認しておきましょう。タプルはセクション6.1.17に解説が、文字列はセクション5.2に解説があります。\n\n\n\n\n『プログラマのための文字コード技術入門』第2版（矢野啓介 著）(2019) 技術評論社. ISBN-13: 978-4297102913."
  },
  {
    "objectID": "programming2025/programming-6.html#標準ライブラリとは",
    "href": "programming2025/programming-6.html#標準ライブラリとは",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "標準ライブラリとは、Pythonをインストールしたときに最初から使うことのできる一連のデータ型、関数、オブジェクトなどを差し、インタープリタに組み込まれているものとモジュールで提供されるものがあります。(ただし、モジュールの中にはビルトインモジュールというインタープリタと切り離せないモジュールもあります。mathやsysがそういった例です。ビルトインは組込みを意味します。)\n今回の講義では、ビルトインデータ型の中でも特に重要なイテラブルなデータ型について学んで行きます。その過程で、文字エンコーディング、ハッシュテーブル、ファイル入出力といったプログラミングにおける重要な事項について学んで行きましょう。"
  },
  {
    "objectID": "programming2025/programming-6.html#イテラブル",
    "href": "programming2025/programming-6.html#イテラブル",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "イテラブルなデータ型とは、Python特有の概念で、大雑把にいうと、forループの繰り返し処理においてループインデックスの範囲指定に用いることができるデータ型のことです。つまり\n# %%\nfor i in index_range:\n    print(i)\nのようなコードでindex_rangeのところに配置できるものです。(イテラブルのより正確な定義はリファレンスマニュアルを参照。)\n組込みデータ型でイテラブルなものには主に次のようなものがあります。\n\nコンテナ\n\nシーケンス\n\nリスト(list)\nタプル(tuple)\nレンジ(range)\n\n集合(set)\n辞書(dict)\n\n文字列(str)\nバイト(bytes)\n\nこれらのデータ型には、ミュータブルなもの・イミュータブルなもの、インデックスやキーによって要素を取得できるもの・できないものといった違いがあります。\n\n\n\n型\nmutable\nindex\nkey\nslice\nhashable\n和・積\n制約\n\n\n\n\nlist\nyes\nyes\nno\nyes\nno\nyes\nno\n\n\ntuple\nno\nyes\nno\nyes\nyes/no\nyes\nno\n\n\nrange\nno\nyes\nno\nyes\nyes\nno\nN/A\n\n\nstr\nno\nyes\nno\nyes\nyes\nyes\nN/A\n\n\nset\nyes\nno\nno\nno\nno\nno\nyes\n\n\ndict\nyes\nno\nyes\nno\nno\nno\nyes\n\n\n\nなお、上記の表の各列は次のような意味です。\n\n\n\n列名\n意味\n\n\n\n\nmutable\nミュータブルかどうか\n\n\nindex\nインデックス参照可能かどうか\n\n\nkey\nキーで値を取得可能かどうか\n\n\nslice\nスライス記法を許すかどうか\n\n\nhashable\nハッシュ可能かどうか\n\n\n和・積\n+、*演算子を受け付けるか\n\n\n制約\n要素の型に制約があるか\n\n\n\nkeyとhashableについては辞書を説明するときに解説します。\nリストやレンジについては前回解説しましたので、今回はそれ以外の型(タプル、文字列、辞書、集合)について説明します。バイト型も重要ですが、時間の都合で詳細な解説を割愛します。"
  },
  {
    "objectID": "programming2025/programming-6.html#タプルtuple",
    "href": "programming2025/programming-6.html#タプルtuple",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "タプルは以下のような性質をもちます。\n\nイテラブル\nイミュータブル\nインデックス参照可能\nスライス参照可能\n任意のオブジェクトを要素に持てる\n算術演算(和・積)可能\n\nタプルは、リストと同じくシーケンス型に分類されますが、イミュータブルなデータ型です。タプルは、リストをイミュータブルにしたものと考えてほとんど間違いありません。リストと同じく、要素オブジェクトへの参照を格納しています。\nリストと同じくインデックス番号やスライスで要素にアクセスでき、どのようなPythonオブジェクトでも要素に持てます。\nforループにおける使用方法はリストと同じです。\n# 1,2,3と印字\nfor i in (1,2,3):\n    print(i)\nイミュータブルなので、要素への代入操作は禁止されています。\n&gt;&gt;&gt; x = ('foo','bar','baz')\n&gt;&gt;&gt; x[0] = 'Python'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\nタプルの使用において注意しなくてはならないのは、タプルのようなイミュータブルなコンテナ型というのは、要素への参照の変更が禁止されているだけで、参照先の要素オブジェクトの変更は禁止されていないということです。したがって、タプルはイミュータブルですが、次のように要素オブジェクトに変更を加えることは可能です。\n&gt;&gt;&gt; x = ('foo','bar',['baz'])\n&gt;&gt;&gt; x[2].append('BAZ')\n&gt;&gt;&gt; x\n('foo', 'bar', ['baz', 'BAZ'])\nリストと同じくタプルはインデクシングやスライス記法を受け付けます。\n&gt;&gt;&gt; x = (1,2,3,4,5)\n&gt;&gt;&gt; x[1:4]\n(2, 3, 4)\n&gt;&gt;&gt; x[3]\n4\n&gt;&gt;&gt; x[:]\n(1, 2, 3, 4, 5)\nなお、一つしか要素のないタプルを作るためには、次のように、余分なカンマが一つ必要です。\n&gt;&gt;&gt; x = (1,)    # 一つしか要素のないタプル\n&gt;&gt;&gt; x\n(1,)\n&gt;&gt;&gt; type(x)\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; x = (1)     # これだとただの整数\n&gt;&gt;&gt; x\n1\n&gt;&gt;&gt; type(x)\n&lt;class 'int'&gt;\nなおここで用いたtype関数は引数にあたえたオブジェクトの型を調べるビルトイン関数です。\nタプルはリストと同じように+演算子、*演算子を受け付けます。\n&gt;&gt;&gt; x = (1,2) + (3,4)\n&gt;&gt;&gt; x\n(1, 2, 3, 4)\n&gt;&gt;&gt; x = (1,2) * 3\n&gt;&gt;&gt; x\n(1, 2, 1, 2, 1, 2)\nただし、リストと同じで掛け算はシャローコピーですので、やはり次のような挙動には注意しましょう。\n&gt;&gt;&gt; x = ((1,[]),) * 3\n&gt;&gt;&gt; x\n((1, []), (1, []), (1, []))\n&gt;&gt;&gt; x[0][1].append(2)\n&gt;&gt;&gt; x\n((1, [2]), (1, [2]), (1, [2]))\nリストと比べたときのタプルの利点としては、それが辞書のキーとして用いることができるということです。これについては辞書の欄で詳しく述べます。"
  },
  {
    "objectID": "programming2025/programming-6.html#文字列str",
    "href": "programming2025/programming-6.html#文字列str",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "Pythonの文字列型はRと同じくダブルもしくはシングルクォーテーションによって作成でき、以下のような性質を持ちます。\n\nイテラブル\nイミュータブル\nインデックス参照可能\nスライス参照可能\n算術演算可能\n\nforループで用いると、一文字ずつループインデックスに渡されます。\n# \"HELLO WORLD!\"を一文字ずつ印字\nfor c in \"HELLO WORLD!\":\n    print(c,end='--')\nprint()\n# 結果\nH--E--L--L--O-- --W--O--R--L--D--!--\n文字列は、インデックスで各文字に、スライスで部分文字列にアクセスできます。イミュータブルなので、変更は一切不可能です。\n文字列は+演算子や*演算子を受け付けます。\n&gt;&gt;&gt; x = \"Hello, \" + \"World!\"\n&gt;&gt;&gt; x\n'Hello, World!'\n&gt;&gt;&gt; print(x)\nHello, World!\n&gt;&gt;&gt;\n&gt;&gt;&gt; x = \"knock, \" * 10\n&gt;&gt;&gt; print(x)\nknock, knock, knock, knock, knock, knock, knock, knock, knock, knock,\n\n\n文字列を1文字ずつ処理する練習です。文字列”Hello, World!“を一文字ずつ画面に印字し、’l’の後でのみ改行して出力するPythonコードを作成しなさい。出力は以下のようになります。\n# 出力\nHel\nl\no, Worl\nd!"
  },
  {
    "objectID": "programming2025/programming-6.html#エンコーディング",
    "href": "programming2025/programming-6.html#エンコーディング",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "文字列は、イテラブルですが、コンテナ型ではありません。レンジ以外のビルトインのコンテナ型は、要素オブジェクトへの参照を格納していますが、文字列オブジェクトは、文字への参照ではなく文字そのものを格納した配列を内部にもっています。\n\n\n\nstring\n\n\n文字をメモリ上に格納する為には、文字をバイト列に変換しなくてはなりません。これをエンコーディングと言います。文字をエンコードするには様々な方式があり、そのうち有名なものはutf-8やshift-jisなどがあります。\n\n\n\n文字\nshift_jis\neuc_jp\nutf_8\n\n\n\n\nあ\n0x82a0\n0xa4a2\n0xe38182\n\n\n山\n0x8e52\n0xbbb3\n0xe5b1b1\n\n\n\n文字列が特定のエンコーディングによってどのようなバイト列になるのかは、文字列メソッドのencodeによって確かめることができます。encodeメソッドはバイト型のオブジェクトを返します。\n&gt;&gt;&gt; x = 'あ'.encode('shift-jis')\n&gt;&gt;&gt; x\nb'\\x82\\xa0'\n&gt;&gt;&gt; x.hex()\n'82a0'\nバイト型については解説しませんが、上記のようにhexというメソッドによって、16進数の文字列に変換することができます。\n次のコードは、ひらがなの50音をutf-8のコードで書きだすためのPythonコードです。\n# %%\na = 'あいうえお'\nk = 'かきくけこ'\ns = 'さしすせそ'\nt = 'たちつてと'\nn = 'なにぬねの'\nh = 'はひふへほ'\nm = 'まみむめも'\ny = 'や　ゆ　よ'\nr = 'らりるれろ'\nw = 'わ　　　を'\nnn = 'ん　　　　'\nx = [a,k,s,t,n,h,m,y,r,w,nn]\nfor line in x:\n    print(line,end=' --&gt; ')\n    for char in line:\n        print(char.encode('utf-8').hex(),end=' ')\n    print()\n結果は次のようになります。\n# 出力\nあいうえお --&gt; e38182 e38184 e38186 e38188 e3818a \nかきくけこ --&gt; e3818b e3818d e3818f e38191 e38193 \nさしすせそ --&gt; e38195 e38197 e38199 e3819b e3819d \nたちつてと --&gt; e3819f e381a1 e381a4 e381a6 e381a8 \nなにぬねの --&gt; e381aa e381ab e381ac e381ad e381ae \nはひふへほ --&gt; e381af e381b2 e381b5 e381b8 e381bb \nまみむめも --&gt; e381be e381bf e38280 e38281 e38282 \nや　ゆ　よ --&gt; e38284 e38080 e38286 e38080 e38288 \nらりるれろ --&gt; e38289 e3828a e3828b e3828c e3828d \nわ　　　を --&gt; e3828f e38080 e38080 e38080 e38292 \nん　　　　 --&gt; e38293 e38080 e38080 e38080 e38080 \nこのようにutf-8は全てのひらがなに3バイトを使っています。なお、ここでは、\nchar.encode('utf-8').hex()\nのように、encodeメソッドとhexメソッドをつなげています。これは、一つ目のメソッドの戻り値のオブジェクトであるバイトオブジェクトがもつhexメソッドを呼び出していることに相当します。この記法をメソッドチェーンと呼び、1つめのメソッドの戻り値には関心がない場合に便利な記法です。\nなお、同じエンコーディング方式、同じシンボルでも半角文字と全角文字では異なるバイト列にエンコードされます。プログラミングの初心者にありがちなミスは半角カッコの代わりに全角カッコをつかってしまうことですが、これらがutf-8でどのように異なるのか調べてみましょう。\n# %%\n'('.encode('utf-8').hex()   # 半角カッコ\n'（'.encode('utf-8').hex()  # 全角カッコ\n# 実行結果\n28\nefbc88\nこのように、半角カッコは0x28という1バイトであるのに対し、全角カッコは0xefbc88という3バイトの列です。インタープリタはこれらを違う文字として解釈するので、エラーを出します。\nたとえば、わざと半角カッコの代わりに全角カッコを使ってタプルを作ってみましょう。\n# %%\n# 1つめのカッコが全角になっている\nx = （5,4,3)\n# 出力\n\nx = （5,4,3)\n  File \"&lt;ipython-input-32-7b09692778be&gt;\", line 1\n    x = （5,4,3)\n         ^\nSyntaxError: invalid character in identifier"
  },
  {
    "objectID": "programming2025/programming-6.html#デコーディング",
    "href": "programming2025/programming-6.html#デコーディング",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "エンコーディングの逆の変換、すなわちバイト列を文字列に変換する操作をデコーディングと言います。Pythonでは、バイトオブジェクトのdecodeメソッドを用いて行うことができます。\n&gt;&gt;&gt; thanks_str = 'ありがとう'\n&gt;&gt;&gt; thanks_bytes = thanks_str.encode('utf-8')\n&gt;&gt;&gt; thanks_bytes\nb'\\xe3\\x81\\x82\\xe3\\x82\\x8a\\xe3\\x81\\x8c\\xe3\\x81\\xa8\\xe3\\x81\\x86'\n&gt;&gt;&gt; thanks_bytes.hex()\n'e38182e3828ae3818ce381a8e38186'\n&gt;&gt;&gt; thanks_bytes.decode('utf-8')   # デコーディング\n'ありがとう'\nエンコーディングに用いた方式と異なる方式でテキストをデコードしたときに生じる現象を俗に文字化けと呼びます。文字化けはPython上で引き起こすことが可能です。\nたとえば6文字の文字列’ありがとう！’(全て全角)はutf-8で18バイトになります。\n# %%\nx = 'ありがとう！'.encode('utf-8')\nprint('バイト列 = ',x.hex())\nprint('バイト数 = ',len(x))\n# 出力\nバイト列 =  e38182e3828ae3818ce381a8e38186efbc81\nバイト数 =  18\nこれを1文字2バイトのutf-16の9文字としてデコードしてみましょう(utf-16はBMPと呼ばれる基本的な文字群を2バイトで表します)。\ny = x.decode('utf-16','replace')\nprint('文字列 = ',y)\nprint('文字数 = ',len(y))\nここで第2引数replaceは、デコードできない文字を何らかの適当な文字で置き換えるというオプションです。\n# 出力\n文字列 =  臣誂臣ꢁ臣膼\n文字数 =  9\nこのようにutf-16では予想されたとおり9文字となりましたが、文字化けが生じました。\nなお、デコードできない文字を置き換えるのではなく除去してデコードさせる場合は、decodeメソッドの第2引数にignoreを設定してください。\n\n\nアルファベットの全ての小文字と大文字をutf-8にエンコードして16進数で印字するPythonコードを作成しなさい。出力は以下のようになります。(スペース上の制約のため5文字ごとに改行していますが、これはなくても構いません。)また、結果はasciiコードでも等しいことを確かめなさい。(asciiにエンコードする。)\n# 出力\na:61 b:62 c:63 d:64 e:65\nf:66 g:67 h:68 i:69 j:6a\nk:6b l:6c m:6d n:6e o:6f\np:70 q:71 r:72 s:73 t:74\nu:75 v:76 w:77 x:78 y:79\nz:7a A:41 B:42 C:43 D:44\nE:45 F:46 G:47 H:48 I:49\nJ:4a K:4b L:4c M:4d N:4e\nO:4f P:50 Q:51 R:52 S:53\nT:54 U:55 V:56 W:57 X:58\nY:59 Z:5a"
  },
  {
    "objectID": "programming2025/programming-6.html#文字列オブジェクトのメモリ占有",
    "href": "programming2025/programming-6.html#文字列オブジェクトのメモリ占有",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "文字列オブジェクトのメモリ消費量はどのくらいになるでしょうか？1バイトでは256通りの状態を表すことができることを思い出しましょう。従って、1文字に1バイトを確保すれば、最大256文字を区別することができます。アルファベットと幾つかの記号くらいなら、これで十分です。\nしかしながら、ひらがなや漢字が混じると、256文字では足りませんので、最低でも2バイトのメモリが必要です。さらに滅多に使わないような記号まで含めると、2バイトでも足りません。\nそれぞれのバイト数で表現できる最大文字数は次の通りです。\n\n\n\nバイト数\n最大文字数\n\n\n\n\n1\n2**8 == 256\n\n\n2\n2**16 == 65,536\n\n\n4\n2**32 == 4,294,967,296\n\n\n\n文字エンコーディングには可変長エンコーディングと固定長エンコーディングがあります。可変長エンコーディングでは文字によってバイト数が異なりますが、固定長エンコーディングでは全ての文字で同じバイト数を使います。実装上の問題で、Pythonの文字列オブジェクトは内部で固定長エンコーディングを用いています。\nさて、1文字のバイト数を小さくするとメモリ消費量は節約できますが、表現できる文字数は小さくなります。一方、1文字のバイト数を大きくすると、表現できる文字数は多くなりますが、メモリ消費量は大きくなってしまいます。\nPythonはこうしたジレンマを解決するため、文字列の種類によって内部で異なるエンコーディングを使い分けています。アルファベットなどのシンプルな文字列は1バイト文字列で、ひらがなや漢字等が入ったより広い範囲の文字列には2バイトあるいは4バイト文字列を使います。\n次のコードは、Python文字列が一文字あたり何バイト使っているかを調べるためのものです。\n# アルファベットaの場合\nimport sys\nchar = \"a\"\nx = \"\"\nfor i in range(10):\n    x += char\n    print(x,end=\" --&gt; \")\n    print(sys.getsizeof(x))\n上のコードで、“x += char”は、“x = x + char”と全く同じ意味で、単なる別表現であることに注意してください。それ以外は、これまで習った知識しか使っていません。\n出力は次のようになります。\n# 出力。オーバーヘッドは49Byte(環境依存)\na --&gt; 50\naa --&gt; 51\naaa --&gt; 52\naaaa --&gt; 53\naaaaa --&gt; 54\naaaaaa --&gt; 55\naaaaaaa --&gt; 56\naaaaaaaa --&gt; 57\naaaaaaaaa --&gt; 58\naaaaaaaaaa --&gt; 59\nひらがなにすると以下のようになります。\n# ひらがな「あ」の場合\nimport sys\nchar = \"あ\"\nx = \"\"\nfor i in range(10):\n    x += char\n    print(x,end=\" --&gt; \")\n    print(sys.getsizeof(x))\n# 出力。オーバーヘッドは74Byte(環境依存)\n# ひらがな「あ」の場合\nあ --&gt; 76\nああ --&gt; 78\nあああ --&gt; 80\nああああ --&gt; 82\nあああああ --&gt; 84\nああああああ --&gt; 86\nあああああああ --&gt; 88\nああああああああ --&gt; 90\nあああああああああ --&gt; 92\nああああああああああ --&gt; 94\nさらに絵文字の場合です。\n# 絵文字の場合\nimport sys\nchar = \"🐼\"\nx = \"\"\nfor i in range(10):\n    x += char\n    print(x,end=\" --&gt; \")\n    print(sys.getsizeof(x))\n# 出力。オーバーヘッドは76Byte(環境依存)\n# 絵文字の場合\n🐼 --&gt; 80\n🐼🐼 --&gt; 84\n🐼🐼🐼 --&gt; 88\n🐼🐼🐼🐼 --&gt; 92\n🐼🐼🐼🐼🐼 --&gt; 96\n🐼🐼🐼🐼🐼🐼 --&gt; 100\n🐼🐼🐼🐼🐼🐼🐼 --&gt; 104\n🐼🐼🐼🐼🐼🐼🐼🐼 --&gt; 108\n🐼🐼🐼🐼🐼🐼🐼🐼🐼 --&gt; 112\n🐼🐼🐼🐼🐼🐼🐼🐼🐼🐼 --&gt; 116\nこのように、文字の種類に応じて1、2、4バイト文字を使い分けていることが分かります。\nしかしながら、通常プログラマはメモリ容量を気にしているのでない限り、こうしたインタープリタ内部でのエンコーディングを気にする必要はありません。プログラマがエンコーディングを気にしなければならないのは、ファイルの読み書きのときです。プログラマは文字をファイルに保存する際に、エンコーディングを自由に選べます。プログラマがエンコーディングを指定しない場合、Pythonはデフォルトでutf-8を用います。"
  },
  {
    "objectID": "programming2025/programming-6.html#ファイル入出力",
    "href": "programming2025/programming-6.html#ファイル入出力",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "ここでは、特定のエンコーディングで保存されたテキストファイルを開いて、テキストをPythonの文字列オブジェクトに読み込み、エンコーディングを変えて別のファイルに保存する作業を行ってみましょう。これはPythonの非常に実用的な用途です。\nGitHubディレクトリの下に”change_encoding”というフォルダを作って、その中でVS Codeを開いてください。VS Codeを開いたら、change_encodingフォルダの中に”euc_jp.txt”というファイルを新規作成して開いてください。\nこの状態でVS Codeの画面の右下を見ると、青いバーの上にUTF-8という表示が見られるはずです。\n\n\n\nutf-8\n\n\nこれは、このファイルが現在UTF-8エンコーディングで開かれていることを意味します。この表示をクリックすると、パレットが開き、\n\nエンコード付きで再度開く\nエンコード付きで保存する\n\nのどちらかを選べるようになりますので、1のエンコード付きで再度開くを選びます。すると、エンコードを選択するパレットに変化しますので、euc-jpと入力してリターンします。すると、右下の表記がEUC-JPに変化します。\n\n\n\neuc-jp\n\n\nこれで、現在テキストファイルeuc_jp.txtはeuc_jpエンコードで開かれた状態になりました。この状態で文章を記入して保存すると、euc_jpエンコーディングで保存されることになります。\nどのような文章を入力しても良いのですが、ここでは、\nこの文章のエンコーディングをeuc_jpからshift_jisに変更します。\nと入力して保存しましょう。ファイルを保存したら閉じてください。\nそれでは準備ができたので、いよいよPythonからファイルを開きましょう。VS Code上で、euc_jp.txtと同じフォルダの中に、change_encoding.pyというファイルを作り開いてください。ここに目的のコードを記述して実行しましょう。\nテキストファイルを開くには、ビルトイン関数のopenを使います。openは、with命令と共に使うのが普通ですので、セットで覚えましょう。\n# %%\nwith open('./euc_jp.txt','r',encoding='euc_jp') as file:\n    text = file.read()\nこの構文では、開かれたファイルは、ファイルオブジェクトとしてfileという変数に代入されます。openの第1引数はファイル名、'r'は「読み込み専用」を意味し、encoding引数はファイルのエンコーディングを表します。ここでは'euc_jp'を指定しています。\nファイルオブジェクトにはファイルを操作するためのメソッド群があり、readメソッドはその内容を読み込んで一つの文字列として返します。上記コードではその戻り値をtextという変数に代入しています。\nファイルオブジェクトは、open関数によって開いたら、使い終わったあとにcloseメソッドによって必ず閉じなければなりません。「どうせ必ず閉じるなら、いつ閉じるかを予め指定して開けばいいのでは？」と思うかもしれません。そのために導入されたのがwith命令です。with命令とともにファイルを開くと、withブロックが終了したときに自動的にファイルがクローズします。withを使うとファイルの閉じ忘れがないので、ファイルを使うときは特に理由がない限りwithで開くようにしましょう。\nこれで、変数textに読み込まれたファイル内の文章が文字列オブジェクトとして代入されました。ためしに表示してみましょう。\n# %%\nprint(text)\n# 出力\nこのファイルのエンコーディングをeuc_jpからshift_jisに変更します。\n\n\n\nあとはこれをエンコーディングを指定して別のファイルに保存するだけです。ファイルへの書き込みは次のようにします。\n# %%\nwith open('./shift_jis.txt','w',encoding='shift_jis') as file:\n    file.write(text)\n読み込みのときとよく似ていますが、openの第1引数は新しいファイルの名前です。ここでは'shift_jis.txt'とします。第2引数の'w'は「書き込み」を意味します。最後にencoding引数は'shift_jis'にしておきましょう。\n開いたファイルへ変数textを書き込むには上記のようにwriteメソッドを使います。引数には文字列オブジェクトを与えます。\nそれでは、VS Codeのファイルエクスプローラを見てみましょう。shift_jis.txtというファイルが新しく出来ているはずなので、開いてみてください。中身は\nこのファイルのエンコーディングをeuc_jpからshift_jisに変更します。\nとなっているはずですが、VS Codeの右下のバーを見てみると、表記がShift JISになっているはずです。これはこのファイルがshift_jisでエンコードされていることを表していますので、めでたくエンコーディングの変換ができたことになります。\n\n\n\nshift_jis\n\n\n\n\n\n上では、ファイルの中身を一気に読みだして一つの文字列に格納しましたが、行ごとに読み込む方法もあります。以下のような内容を記述したテキストファイルlines.txtを作成して保存してください。\n昔々、\nある所に\nおじいさんと\nおばあさんが\n住んでいました。\nこのファイルから行ごとにテキストを読み出すには、次のようにします。\n# %%\nwith open('./lines.txt','r') as file:\n  text_lines = file.readlines()\nprint(text_lines)\n結果はリストで得られます。\n# 出力\n['昔々、\\n', 'ある所に\\n', 'おじいさんと\\n', 'おばあさんが\\n', '住んでいました。']\nこのように、readlinesメソッドでは行末の改行記号は除去されません。改行を除去したい場合は、次のように書くことができます。\n# %%\nwith open('./lines.txt','r') as file:\n  text_lines = file.read().splitlines()\nprint(text_lines)\n# 出力\n['昔々、', 'ある所に', 'おじいさんと', 'おばあさんが', '住んでいました。']\nsplitlinesは文字列のメソッドであり、文字列を改行で分割し、得られた行のリストを返します(教科書セクション5.2.8参照)。\nreadlinesの逆の操作、すなわち行のリストをファイルに書き込むときは、次のようにwritelinesメソッドを用います。\n# %%\nwith open('./output_lines.txt','w') as file:\n  file.writelines(text_lines)\nただし、この方法では各行の末尾に改行は追加されません。改行を挿入するにはたとえば次のような方法があります。\n# %%\nwith open('./output_lines.txt','w') as file:\n  file.write(\"\\n\".join(text_lines))\njoinは文字列を結合するメソッドであり、後ほど説明します。\n\n\n\nそれでは、ファイル入出力もマスターしたことですので、ファイルのバイナリ情報(バイト列)を直接編集してみたいと思います。\nこれまでは、文字とバイト列の翻訳をPythonに任せていましたが、今度は、直接コンピュータの言葉であるバイナリ情報をファイルに書き込むということです。ここでは、「こんにちは」という文字列が書かれたテキストをバイナリ編集で作ってみましょう。エンコーディングは何でもいいですが、utf-8にしておきましょう。\nすでに上でひらがなのutf-8コード表をつくりましたので、これを使って「こんにちは」のバイト列を構成しましょう。バイト列を構成するには、バイトの列をリストにしてbytes関数に渡します。ここで、たとえば「こ」は0xe38193ですので、3つのバイトのリスト[0xe3,0x81,0x93]になることに注意してください。\n# %%\nthanks = bytes([0xe3,0x81,0x93,\n0xe3,0x82,0x93,\n0xe3,0x81,0xab,\n0xe3,0x81,0xa1,\n0xe3,0x81,0xaf])\nprint(thanks)\n# 出力\n\nb'\\xe3\\x81\\x93\\xe3\\x82\\x93\\xe3\\x81\\xab\\xe3\\x81\\xa1\\xe3\\x81\\xaf'\n次はこれをファイルに書き込んでいきます。ファイル名は”howareyou.txt”にしましょう。バイナリ情報の書き込みは、モードを”bw”にしてオープンします。’b’がバイナリ、’w’が書き込みを意味します。\n# %%\nwith open('howareyou.txt','bw') as file:\n    file.write(thanks)\n’howareyou.txt’というテキストファイルが出来ているはずですので、開いてみてください。ちゃんと「こんにちは」と書かれていたら成功です。エンコーディングもutf-8になっていることをVS Codeで確認しましょう。\n上記で、バイト列を構成する際も、ファイルをオープンするときも、一切utf-8であるということをPythonに教えなかったことに注意してください。utf-8であるということは、ファイルを開くときに初めてVS Codeに認識されたのです。\nつまるところは、テキストファイルの読み書きとは、こういうものであることを分かって頂ければ幸いです。"
  },
  {
    "objectID": "programming2025/programming-6.html#文字列のメソッド",
    "href": "programming2025/programming-6.html#文字列のメソッド",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "文字列オブジェクトは様々なメソッドを備えており、それらを用いて文字列を操作することが可能です。\n\n\nreplaceメソッドを用いると、文字列の中の特定の部分文字列を全て別の部分文字列に置換することができます。たとえば、次のようにすれば、sentence文字列オブジェクトの中の\"パイソン\"を全て\"Python\"で置き換えることができます。\n# %%\nsentence = \"パイソンは言語です。パイソンは動物ではありません。\"\nsetence2 = sentence.replace('パイソン','Python')\nprint(sentence2)\n# 出力\nPythonは言語です。Pythonは動物ではありません。\nさらに、メソッドチェーン(メソッドを繋げる)を用いれば、部分文字列の置換を連続して複数回お行うことができます。たとえば、以下のコードでは、sentence文字列オブジェクトの中の\"パイソン\"を全て\"Python\"で置き換えたあと、句点\"。\"を全角エクスクラメーションマーク\"！\"で置き換えています。\n# %%\nsentence = \"パイソンは言語です。パイソンは動物ではありません。\"\nsetence3 = sentence.replace('パイソン','Python').replace('。','！')\nprint(sentence3)\n# 出力\nPythonは言語です！Pythonは動物ではありません！\n\n\n\nそれではここで、せっかくですので、ここまで学んだことの応用として、多少役に立つコードを作りましょう。Pythonスクリプトを読み込んで、全角括弧を半角括弧に変換するコードを作りたいと思います。\nそのためには、まずどの文字をどの文字に置き換えるのかを示した次のような辞書を作成する必要があります。\n\n\n\n置き換え前\n置き換え後\n\n\n\n\n（\n(\n\n\n）\n)\n\n\n\n分かりにくいですが、置き換え前が全角で、置き換え後が半角です。Pythonで実装してみましょう。Pythonの辞書型については、次回の講義で詳しく解説しますが、たとえば文字’A’を文字’a’に、文字’B’を文字’b’に変換したい場合は、次のように、書きます。\n# 辞書の形式\ntrans_rule = {'A':'a','B':'b'}\n辞書型の用語で、コロンの左側の文字をキー、右側の文字を値と呼びます。上の例では、’A’と’B’がキーで、’a’と’b’が値です。\n同じように、全角括弧’（‘を半角括弧’(‘に、全角括弧’）‘を半角括弧’)’に置き換えたい場合は、次のように書きます。\n# %%\n# 変換ルールを定義する辞書\ntrans_rule = {'（':'(','）':')'}\nさてこれから、文字列オブジェクトのtranslateというメソッドと、上で定義した変換ルール辞書trans_ruleを使って、文字列中の全角括弧を半角括弧に置き換えます。\nまず、全角括弧を使った「悪いコードの例」を作って実行してみましょう。\n# %%\nbad_code = \"print（'Hello, World!'）\"\nexec(bad_code)\nexec関数は、文字列をPythonコードとして実行するための関数です。以下、出力です。\n# 出力\nTraceback (most recent call last):\n\n  --- (中略) ---\n\n  File \"&lt;ipython-input-1-1a4bddd34732&gt;\", line 2, in &lt;module&gt;\n    exec(bad_code)\n\n  File \"&lt;string&gt;\", line 1\n    print（'Hello, World!'）\n         ^\nSyntaxError: invalid character in identifier\n案の定、エラーが出ました。\nそれでは、次に、bad_code内の全角括弧を半角括弧に置換して、正しく動くコードを作りましょう。次のように、文字列型のmaketransメソッドと、translateメソッドという二つのメソッド、および上記で作成した変換用辞書を用います。\n# %%\ntrans = str.maketrans(trans_rule)\ngood_code = bad_code.translate(trans)\nprint(good_code)\nexec(good_code)\nここで、maketransは、変換ルール辞書trans_ruleを、translateメソッドにおいて使用可能な形式に変換するだけのメソッドです。以下は出力です。\n# 出力\nprint('Hello, World!')\nHello, World!\n次は正しく動作しました。\n尚、上記のコードで2点注意事項があります。一つは、maketransメソッドが、文字列オブジェクトではなく、文字列型を意味するstrから呼び出されていることです。このように、オブジェクトからではなく、データ型名から呼び出すことの出来るメソッドを、クラスメソッドと呼びます。それに対して、オブジェクトから呼び出さなくてはならないtranslateのようなメソッドをインスタンスメソッドと呼びます。(クラスやインスタンスといった用語については、後の講義で解説します。)\n2点目は、maketransメソッドの戻り値transです。これを表示してみましょう。\n# %%\nprint(type(trans))\nprint(trans)\n# 出力\n&lt;class 'dict'&gt;\n{65288: '(', 65289: ')'}\nこのように、maketransの戻り値は辞書です。ただ、キーが文字列から数字に置き換えられています。この数字は、もとの文字をUnicodeコードポイントに置き換えたものです。Unicodeコードポイントとは、全てのユニコード文字に付けられた一意な数字で、文字のID番号のようなものです。\nコードポイントと文字を変換するには、関数chrとordを使います。\n\n\n\n関数\n変換方向\n\n\n\n\nchr\nコードポイントから文字\n\n\nord\n文字からコードポイント\n\n\n\n以下のように使います。\n&gt;&gt;&gt; ord('a')\n97\n&gt;&gt;&gt; chr(97)\n'a'\nそれでは、せっかくですから、全ての小文字アルファベットのコードポイントを出力するコードを書いておきましょう。\n# %%\nfor i in range(ord('a'),ord('z')+1):\n    if (i-ord('a'))%5 == 4:\n        end_str = '\\n'\n    else:\n        end_str = '\\t'\n    print(chr(i) + \"/\" + str(i),end=end_str)\nここで、\\tはタブキーを表すエスケープシーケンスです。エスケープシーケンスが分からない人は教科書を読んでおいてください。str(i)は、数字iを文字列に変換しています。\n# 出力\na/97    b/98    c/99    d/100   e/101\nf/102   g/103   h/104   i/105   j/106\nk/107   l/108   m/109   n/110   o/111\np/112   q/113   r/114   s/115   t/116\nu/117   v/118   w/119   x/120   y/121\nz/122\nここで扱ったものの他にも、文字列型には便利なメソッドがたくさんあるので、教科書のセクション5.2を良く読んで調べておいてください。\n\n\n\nテキスト分析を行っていると、文字列を特定の部分文字列が現れる箇所で分割したいことがあります。そのような操作は、splitメソッドで行うことができます。例えば、次のコードは、文字列オブジェクトsentenceを、\"は\"が現れる箇所で分割し、結果をsentence2に代入します。\n# %%\nsentence = \"パイソンは言語です。パイソンは動物ではありません。\"\nsplit_result = sentence.split('は')\nprint(split_result)\n結果はリストで返されます。\n# 出力\n['パイソン', '言語です。パイソン', '動物で', 'ありません。']\nよくある操作は、長いテキストを改行文字('\\n')で分割することによって、段落を取り出したり、句点やピリオドで分割することで文を取り出したりするものです。その際、取り出した文の前後の空白を除去したい場合がありますが、そのような場合には、stripメソッドを用いることができます(教科書のセクション5.2.6を参照)。なお、改行で分割する場合は、splitlinesメソッドを用いることも可能です(教科書セクション5.2.8参照)\n\n\n\nsplitメソッドとセットで覚えて置きたいメソッドは、文字列を結合するjoinメソッドです。joinはsplitの逆変換にあたり、文字列のリストを結合することができます。たとえば、次のコードは、上で作成した文字列のリストsplit_resultを、\"は\"で結合して一つの文字列に戻します。\n# %%\njoin_result = \"は\".join(split_result)\nprint(join_result)\n# 出力\nパイソンは言語です。パイソンは動物ではありません。\nリスト内の文字列を単純に結合したい場合は、空文字列を使って\n# %%\n# 単純にリスト内の文字列を結合\n\"\".join(split_result)\nのようにします。\n\n\n\n以下の文章を’momotaro.txt’というテキストファイルに保存しなさい。\n\n昔々、ある所に、おじいさんと、おばあさんが住んでいました。ある朝、おじいさんは山へ芝刈りに、おばあさんは川へ洗濯に行きました。おばあさんが川で洗濯をしていると、川上から大きな桃が、どんぶらこ、どんぶらこと流れてきました。\n\n上記の文章を読み込んで、読点「、」をコンマ’,‘に、句点「。」をピリオド’.’に置き換えた文章を’momotaro2.txt’に出力するPythonコードを作成しなさい。ただしエンコーディングは’euc_jp’とする。"
  },
  {
    "objectID": "programming2025/programming-6.html#まとめ",
    "href": "programming2025/programming-6.html#まとめ",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "今回は、以下のことを学びました。\n\nタプルの性質\n文字列の性質\nエンコーディング\nデコーディング\nファイル入出力\n文字列のメソッド\n\nタプルや文字列は非常に重要なデータ型です。教科書を良く読み、どのような操作が可能であるのかを確認しておきましょう。タプルはセクション6.1.17に解説が、文字列はセクション5.2に解説があります。"
  },
  {
    "objectID": "programming2025/programming-6.html#参考書",
    "href": "programming2025/programming-6.html#参考書",
    "title": "第6回 標準ライブラリ(1)ータプル、文字列、ファイル入出力",
    "section": "",
    "text": "『プログラマのための文字コード技術入門』第2版（矢野啓介 著）(2019) 技術評論社. ISBN-13: 978-4297102913."
  },
  {
    "objectID": "programming2025/geeks.html",
    "href": "programming2025/geeks.html",
    "title": "ちょっと細かいはなし",
    "section": "",
    "text": "ここに書かれていることは、CPythonのテクニカルな詳細であって、全く理解する必要ありませんが、知っていればよりPythonの理解が深まります。\n\n\n\nCPythonソースツリー検索ツール\n\n\n\n\n\n\nCPythonのリストはlistobject.hとlistobject.cで実装されています。\n以下のように、listobject.hを見ると、リストがCの構造体PyListObjectとして定義されているのが分かります。\n// listobject.hより\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\nごちゃごちゃ書いてありますが、ほとんどコメントです。とても分かりやすく、以下のように、「ob_itemはリストの要素へのポインタのベクトルです」と書いてあります。\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\nつまり、Pythonのリストの本体は、C言語のポインタ配列です。64ビット処理系ではポインタは8バイトで、メモリのアドレスを格納します。ただしC言語のポインタはアドレスを格納するだけでなく、演算が定義されており、参照されるオブジェクトの型の情報も付帯されています。これはC言語の整数が値を格納するだけではなくて演算が定義されているのと同じです。\nまた、その次のコメントを見てみると、\n/* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\nこれも非常に明解で、ob_sizeは実際に使われている要素の数であって、割り当てられているメモリのサイズallocated以下になる、と書かれています。len関数の出力はob_sizeであるとも書かれています。\n\n\n\n以下はlistobject.cから取ったPyList_Newという新しいリストを作るCの関数です。\n// listobject.cより\nPyObject *\nPyList_New(Py_ssize_t size)\n{\n    if (size &lt; 0) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n\n    struct _Py_list_state *state = get_list_state();\n    PyListObject *op;\n#ifdef Py_DEBUG\n    // PyList_New() must not be called after _PyList_Fini()\n    assert(state-&gt;numfree != -1);\n#endif\n    if (state-&gt;numfree) {\n        state-&gt;numfree--;\n        op = state-&gt;free_list[state-&gt;numfree];\n        _Py_NewReference((PyObject *)op);\n    }\n    else {\n        op = PyObject_GC_New(PyListObject, &PyList_Type);\n        if (op == NULL) {\n            return NULL;\n        }\n    }\n    if (size &lt;= 0) {\n        op-&gt;ob_item = NULL;\n    }\n    else {\n        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *));\n        if (op-&gt;ob_item == NULL) {\n            Py_DECREF(op);\n            return PyErr_NoMemory();\n        }\n    }\n    Py_SET_SIZE(op, size);\n    op-&gt;allocated = size;\n    _PyObject_GC_TRACK(op);\n    return (PyObject *) op;\n}\nこちらを見ると下から12行目くらいに\nop-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *));\nと書いてありますが、ここで、Pythonオブジェクトのポインタに必要なサイズ(64bitなら8バイト)をsize個分確保して、そのポインタ配列へのポインタを属性ob_itemに代入しています。\nオブジェクトの「サイズ」は下から5行目の\n Py_SET_SIZE(op, size);\nで設定されています。このサイズは割当メモリサイズではなく実際に格納されている要素の個数です。Py_SET_SIZE関数はobject.hで次のように定義されています。\nstatic inline void _Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    ob-&gt;ob_size = size;\n}\n#define Py_SET_SIZE(ob, size) _Py_SET_SIZE(_PyVarObject_CAST(ob), size)\nこれを見ると分かるように単にオブジェクトのob_sizeをsizeに設定しているだけです。さらにob_sizeはというと、PyVarObject構造体のメンバで、同じくobject.hで定義されています。\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n\n\nさらに、PyList_New関数の下から4行目で\nop-&gt;allocated = size;\nという操作によって、allocateされた区画の数をallocated属性に格納しています。これは一般にop-&gt;ob_sizeと同じかより大きいですが、リストを新規作成した場合はこの２つが同じ値になっていることが分かります。言い換えると、リストの新規作成では、余分なメモリ領域を確保しません。講義資料本編の実験で、リストのメモリ占有量が要素の個数と線形の関係を持っていたのはそのためです。\n問題は__sizeof__メソッドで返されるメモリサイズの方ですが、こちらはlistobject.cのlist__sizeof__impl関数で定義されています。\n/*[clinic input]\nlist.__sizeof__\nReturn the size of the list in memory, in bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nlist___sizeof___impl(PyListObject *self)\n/*[clinic end generated code: output=3417541f95f9a53e input=b8030a5d5ce8a187]*/\n{\n    Py_ssize_t res;\n\n    res = _PyObject_SIZE(Py_TYPE(self)) + self-&gt;allocated * sizeof(void*);\n    return PyLong_FromSsize_t(res);\n}\nself-&gt;allocated * sizeof(void*)は、割り当てられたメモリサイズですが、その他に、_PyObject_SIZE(Py_TYPE(self))というのが足されています。これがリスト構造のサイズであり、オーバーヘッドに相当します。\n_PyObject_SIZEはというと、objimpl.hで定義されています。\n#define _PyObject_SIZE(typeobj) ( (typeobj)-&gt;tp_basicsize )\n\n/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a\n   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The\n   value is rounded up to the closest multiple of sizeof(void *), in order to\n   ensure that pointer fields at the end of the object are correctly aligned\n   for the platform (this is of special importance for subclasses of, e.g.,\n   str or int, so that pointers can be stored after the embedded data).\n   Note that there's no memory wastage in doing this, as malloc has to\n   return (at worst) pointer-aligned memory anyway.\n*/\nこれは単に与えられたデータ型typeobjの基本サイズ(tp_basicsize)を返すだけのようです。\nここはまだ未完成なので、今後も書き足して行きます。"
  },
  {
    "objectID": "programming2025/geeks.html#リンク",
    "href": "programming2025/geeks.html#リンク",
    "title": "ちょっと細かいはなし",
    "section": "",
    "text": "CPythonソースツリー検索ツール"
  },
  {
    "objectID": "programming2025/geeks.html#cpythonのリストのメモリ利用",
    "href": "programming2025/geeks.html#cpythonのリストのメモリ利用",
    "title": "ちょっと細かいはなし",
    "section": "",
    "text": "CPythonのリストはlistobject.hとlistobject.cで実装されています。\n以下のように、listobject.hを見ると、リストがCの構造体PyListObjectとして定義されているのが分かります。\n// listobject.hより\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\nごちゃごちゃ書いてありますが、ほとんどコメントです。とても分かりやすく、以下のように、「ob_itemはリストの要素へのポインタのベクトルです」と書いてあります。\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\nつまり、Pythonのリストの本体は、C言語のポインタ配列です。64ビット処理系ではポインタは8バイトで、メモリのアドレスを格納します。ただしC言語のポインタはアドレスを格納するだけでなく、演算が定義されており、参照されるオブジェクトの型の情報も付帯されています。これはC言語の整数が値を格納するだけではなくて演算が定義されているのと同じです。\nまた、その次のコメントを見てみると、\n/* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\nこれも非常に明解で、ob_sizeは実際に使われている要素の数であって、割り当てられているメモリのサイズallocated以下になる、と書かれています。len関数の出力はob_sizeであるとも書かれています。\n\n\n\n以下はlistobject.cから取ったPyList_Newという新しいリストを作るCの関数です。\n// listobject.cより\nPyObject *\nPyList_New(Py_ssize_t size)\n{\n    if (size &lt; 0) {\n        PyErr_BadInternalCall();\n        return NULL;\n    }\n\n    struct _Py_list_state *state = get_list_state();\n    PyListObject *op;\n#ifdef Py_DEBUG\n    // PyList_New() must not be called after _PyList_Fini()\n    assert(state-&gt;numfree != -1);\n#endif\n    if (state-&gt;numfree) {\n        state-&gt;numfree--;\n        op = state-&gt;free_list[state-&gt;numfree];\n        _Py_NewReference((PyObject *)op);\n    }\n    else {\n        op = PyObject_GC_New(PyListObject, &PyList_Type);\n        if (op == NULL) {\n            return NULL;\n        }\n    }\n    if (size &lt;= 0) {\n        op-&gt;ob_item = NULL;\n    }\n    else {\n        op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *));\n        if (op-&gt;ob_item == NULL) {\n            Py_DECREF(op);\n            return PyErr_NoMemory();\n        }\n    }\n    Py_SET_SIZE(op, size);\n    op-&gt;allocated = size;\n    _PyObject_GC_TRACK(op);\n    return (PyObject *) op;\n}\nこちらを見ると下から12行目くらいに\nop-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *));\nと書いてありますが、ここで、Pythonオブジェクトのポインタに必要なサイズ(64bitなら8バイト)をsize個分確保して、そのポインタ配列へのポインタを属性ob_itemに代入しています。\nオブジェクトの「サイズ」は下から5行目の\n Py_SET_SIZE(op, size);\nで設定されています。このサイズは割当メモリサイズではなく実際に格納されている要素の個数です。Py_SET_SIZE関数はobject.hで次のように定義されています。\nstatic inline void _Py_SET_SIZE(PyVarObject *ob, Py_ssize_t size) {\n    ob-&gt;ob_size = size;\n}\n#define Py_SET_SIZE(ob, size) _Py_SET_SIZE(_PyVarObject_CAST(ob), size)\nこれを見ると分かるように単にオブジェクトのob_sizeをsizeに設定しているだけです。さらにob_sizeはというと、PyVarObject構造体のメンバで、同じくobject.hで定義されています。\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n\n\nさらに、PyList_New関数の下から4行目で\nop-&gt;allocated = size;\nという操作によって、allocateされた区画の数をallocated属性に格納しています。これは一般にop-&gt;ob_sizeと同じかより大きいですが、リストを新規作成した場合はこの２つが同じ値になっていることが分かります。言い換えると、リストの新規作成では、余分なメモリ領域を確保しません。講義資料本編の実験で、リストのメモリ占有量が要素の個数と線形の関係を持っていたのはそのためです。\n問題は__sizeof__メソッドで返されるメモリサイズの方ですが、こちらはlistobject.cのlist__sizeof__impl関数で定義されています。\n/*[clinic input]\nlist.__sizeof__\nReturn the size of the list in memory, in bytes.\n[clinic start generated code]*/\n\nstatic PyObject *\nlist___sizeof___impl(PyListObject *self)\n/*[clinic end generated code: output=3417541f95f9a53e input=b8030a5d5ce8a187]*/\n{\n    Py_ssize_t res;\n\n    res = _PyObject_SIZE(Py_TYPE(self)) + self-&gt;allocated * sizeof(void*);\n    return PyLong_FromSsize_t(res);\n}\nself-&gt;allocated * sizeof(void*)は、割り当てられたメモリサイズですが、その他に、_PyObject_SIZE(Py_TYPE(self))というのが足されています。これがリスト構造のサイズであり、オーバーヘッドに相当します。\n_PyObject_SIZEはというと、objimpl.hで定義されています。\n#define _PyObject_SIZE(typeobj) ( (typeobj)-&gt;tp_basicsize )\n\n/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a\n   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The\n   value is rounded up to the closest multiple of sizeof(void *), in order to\n   ensure that pointer fields at the end of the object are correctly aligned\n   for the platform (this is of special importance for subclasses of, e.g.,\n   str or int, so that pointers can be stored after the embedded data).\n   Note that there's no memory wastage in doing this, as malloc has to\n   return (at worst) pointer-aligned memory anyway.\n*/\nこれは単に与えられたデータ型typeobjの基本サイズ(tp_basicsize)を返すだけのようです。\nここはまだ未完成なので、今後も書き足して行きます。"
  },
  {
    "objectID": "programming2025/programming-2.html",
    "href": "programming2025/programming-2.html",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "第2回 VS Code/仮想環境入門\n\nVS Codeを起動する\nVS Code ショートカット\nプロキシの設定(VS Code)\n各種エクステンションのインストール\nVS Codeインターラクティブモード\n\n練習1\n\nEmacsキーバインディング\n\n練習2\n\nマークダウン入門\n\n構文\n\n練習3\n\n目次をつける\nPDFへの出力\n図の作成\nスライドの作成\n\nAnacondaとは\nプロキシの設定(Anaconda)\nAnaconda仮想環境\n仮想環境の状態チェック\n仮想環境の構築\nVS Codeで特定の仮想環境を使う\nまとめ\n参考書\n補足事項\n\nコマンドプロンプトからVS Codeが起動しないときは?\n『実行』ボタンで『condaが見つからない』エラーが出るときは?\nREPLで変なエラーが出るようになったときは?\nPythonのバージョン3.8をmyenv環境にインストールするには?\nRのバージョン3.6をmyenv環境にインストールするには?(Windowsの場合)\nRのバージョン4.1をmyenv環境にインストールするには?(Macの場合)\nRをVS Code上で起動できるようにするには?\nCコンパイラとアセンブラをenvC環境にインストールするには?\n\n\n\n\n\nプログラマにとって、ソースコードやスクリプトを編集するためのエディタは、とても重要なものです。プログラミングの学習においては、エディタの研究にもしっかりと時間を割きましょう。本講義では、Visual Studio Code(VS Code)という、Microsoftが開発したフリーのエディタを用いることにします。\nそれでは早速VS Codeを起動してみましょう。ホームパス下にGitHubという名前のフォルダを作ってください。（注；本講義では、「フォルダー」と「ディレクトリ」をほとんど同じ意味で用います。）Windowsユーザーの人は、ドキュメントフォルダーの下に作るのが良いでしょう。Anaconda promptやコマンドプロンプトで次のように入力して得られるパスです。\necho %HOMEPATH%\nGitHubフォルダの場所はあまり重要ではないので、ホームパスがよくわからない人は、自分が分かりやすい場所に作っても構いません。GitHubフォルダを作ったら、その中にさらにmy_first_codeという名前のフォルダーを作りましょう。\nmy_first_codeの中身（からっぽ）をWindowsエクスプローラで表示し、右クリックすると「Codeで開く」という選択肢がありますので、それを選ぶと、VS Codeが起動します(下図)。「Codeで開く」が見つからない場合は、フォルダをVS Codeのショートカットアイコンにドラッグ&ドロップしてください。\n\nとりあえず覚えなくてはならないのは、左上のエクスプローラーと、それを開閉するボタンです。エクスプローラーでは、現在いるフォルダmy_first_codeの中にどのようなファイルがあるかを示しています。VS Codeのエクスプローラーの詳しい使い方については、『独習Python』のp30-31を読んでください。\n\n\n\nVS Codeを使うに当たって、覚えたほうが良いショートカットが3つあります。\n\nCtrl-Shift-P: コマンドパレットを開きます。VS Codeの諸々の操作は、このコマンドパレットに望みの操作に関連するキーワードを入力し、出てきた操作リストの中から望みの操作を選択するという形で行います。\nCtrl-Shift-X: 拡張機能検索ウィンドウとインストール済み拡張機能の一覧を表示します。邪魔な拡張機能を無効にしたり、新しい拡張機能を探してインストールするのに使います。\nCtrl-,: 設定項目検索ウィンドウを開きます。注)設定ファイルを直接編集するときは、コマンドパレットにsettings.jsonと入力してください。\n\n\n\n\nこの設定が必要なのは、大学の有線LANに接続する場合だけです。それ以外の方は、この項目は読み飛ばしてください!\nVS Codeを快適に使うためには、インターネット経由で様々なエクステンション(拡張機能)をインストールする必要があります。大学内の有線LANに接続してエクステンション（拡張機能）をインストールするためには、プロキシの設定が必要です。\nCtrl-,と叩くと、設定のための検索窓が立ち上がりますので、proxyと入力しましょう。すると、\nHttp: Proxy\n使用するプロキシ設定。設定されていない場合は、'http_proxy' および &gt;'https_proxy' の環境変数から継承されます。\n[                                        ]\nというproxy設定パネルが現れますので、次のように大学のプロキシサーバーとポート番号を入力しましょう。ただし、ここで、http://proxy-server-addr:????の箇所は、大学のプロキシサーバーの正しいURLとポート番号に置き換えてください。正しいURLとポート番号はMoodle(KUTLMS)に記載してあります。\nHttp: Proxy\n使用するプロキシ設定。設定されていない場合は、'http_proxy' および 'https_proxy' の環境変数から継承されます。\n[http://proxy-server-addr:????            ]\n\n\n\n\nプロキシの設定ができましたので、各種エクステンションがインストールできます。エクステンション（拡張機能）をインストールするには、Ctrl-Shift-Xを叩きます。現れた検索ウィンドウにエクステンション名を入力すれば、候補をリストアップしてくれますので、望みのものを選んでインストールボタンを押しましょう。\n以下のエクステンションが必要ですので、インストールしましょう。\n\nJapanese Language Pack for VS Code (VS Codeを日本語化)\nPython(Microsoftのもの)\nJupyter(インターラクティブモード)\nAwesome Emacs Keymap (Emacsキーバインディング)\nMarkdown All in One (マークダウン便利ツール集)\nmarkdownlint (Markdownの構文チェッカー)\nMarkdown PDF (MarkdownファイルをPDFやHTMLに変換)\n\n\n\n\n\n\n\nそれでは大体の準備ができたので、いよいよVS Codeでプログラミングしてみましょう。Pythonのプログラミングを行うときは、インターラクティブモードという、VS Codeの内部でJupyterを起動する方法が便利です。\nVS Codeのエクスプローラからmy_first_code.pyというファイルを作成し、開いてください(教科書pp.30-31参照)。1行目に次のように入力してください。\n#%%\nもし編集画面が次のように変化すればインターラクティブモードの起動に成功したことを表します。\n\n\n\ninteractive\n\n\n尚、初回は「インタープリタが未選択」という通知が出る場合があります。 これは、後述するように、一つのパソコンに複数のPythonがインストールされている可能性があるので、どのPythonを使うのか定められていないということです。その時は、通知内容にしたがって、インタープリタを選択します。“Python 3.x.x xx-bit (‘base’: conda)”を選択してください。(xは各自の環境に依存します。)正しいインタープリタが選択されていれば、画面の右下に、“Python 3.x.x xx-bit (‘base’: conda)”の表記が表示されます。正しいインタープリタが選択されていない場合は、「VS Codeで特定の仮想環境を使う」の欄の記述に従って、選択を行ってください。\n\n\n\nselect_base_interpreter.PNG\n\n\nためしに、簡単な計算を行ってみましょう。“#%%”記号のすぐ下に計算式を書いてShift-Enterと叩いてみましょう。すると次のように編集画面が変化します。\n\n\n\ninteractive_opo\n\n\nこの編集画面で”#%%“記号と青線に挟まれた部分はセルと呼ばれ、この部分に記述されたPythonコードは、Shift-Enterによってまとめて実行されます。\n一方、セルを実行して得られた結果は、画面右のインターラクティブウィンドウに表示されます。\n\n\n\ninterative_opo2\n\n\n上図で右側がインターラクティブウィンドウです。1+1の結果である2が表示されています。\n\n\nVS Codeインターラクティブモードを用いて、以下のような様々な計算を行ってみなさい。なお、以降の講義では、VS Code上のコードを# %%、REPL上のコードを&gt;&gt;&gt;で表すことにします。注)&gt;&gt;&gt;記号はプロンプトなので、入力する必要はありません。\n# %%\nx = 1\ny = 2\nprint(x + y)\n# %%\nz = x + y\nprint(y ** z)\n# %%\nprint(\"Hello, World!\")\nいくつかセルが出来たら、“# %%”記号の横にある”Run Cell”、“Run Above”、“Run Below”などをクリックしてみましょう。何が起きたか分かりますか？(“Run Debug”は難しいのでクリックしないように。)\n\n\n\n\nこれで自由にPythonコードを実行できるようになりました。ここで、ついでにEmacsキーバインディングの練習をしましょう。まず、上で説明した手順にしたがって、Awesome Emacs Keymapエクステンションをインストールしてください。\nAwesome Emacs Keymapエクステンションをインストールすると、Emacsキーバインディングが使えるようになります。 my_first_code.pyを開き、コードの任意の箇所にカーソルを置いて、Ctrl-nと叩いてみましょう。カーソルが次の行に移動したらキーバインディングが正常に機能しています。Ctrl-pと叩けばカーソルが前の行に移動するはずです。このように、キーバインドを使うと、マウスを使わずにカーソルを移動できます。\n主なEmacsキーバインディングは以下の通りです。\n\n\n\nキー操作\n動作\n\n\n\n\nCtrl-n\n次の行に移動\n\n\nCtrl-p\n前の行に移動\n\n\nCtrl-b\n前の文字に移動\n\n\nCtrl-f\n次の文字に移動\n\n\nCtrl-a\n行頭へ移動\n\n\nCtrl-e\n行末へ移動\n\n\nCtrl-v\n次のページへ移動\n\n\nAlt-v\n前のページへ移動\n\n\nCtrl-k\n現在の行のカーソル以降を削除\n\n\nCtrl-d\n前方一文字削除\n\n\nCtrl-h\n後方一文字削除\n\n\nCtrl-s\n順方向検索\n\n\nCtrl-r\n逆方向検索\n\n\nCtrl-x Ctrl-s\n保存\n\n\nCtrl-x Ctrl-u\nアンドゥ\n\n\nCtrl-space\nマーク設定\n\n\nCtrl-w\nマーク設定地点からカーソル位置までをカット\n\n\nCtrl-y\n貼り付け\n\n\nCtrl-x Ctrl-c\nエディター終了\n\n\n\nこれらのキーバインドを駆使して、可能な限りマウスに触らないでコーディングするように練習してください。\nタッチタイピングで視線の移動を減らし、Emacsキーバインディングで手の移動を減らして、ストレスのないプログラミング生活を楽しみましょう。上記の他にも多数の便利なキー操作がありますので、インターネット等で調べてみてください。また、ここでは説明しませんが、VS Codeはキーバインドを細かくカスタマイズすることもできます。気になる人は、インターネットでカスタマイズの方法を調べてみましょう。\n\n\nmy_first_code.pyの上で、上の表に上げたキーバインドを一つずつ試してみましょう。\n\n\n\n\n\n\n次に、簡単なマークダウンファイルを作成してみましょう。マークダウンとは、HTMLのようなマークアップ言語の一種で、プレーンテキスト文書に書式を付けて文書を整形するための言語です。ホームページを記述するためのHTML(HyperText Markup Language)については皆さんご存知かとおもいますが、Markdownは、HTMLよりももっと機能を限定して簡略化したようなものです。(ちなみに本講義資料も全てマークダウンで記述しました。)\nHTMLでは、たとえば見出しや段落を作るとき、次のようなテキスト文書をつくります。\n&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;見出し&lt;/h1&gt;\n    &lt;h2&gt;これは小見出し&lt;/h2&gt;\n    &lt;p&gt;\n        これは段落。これは&lt;b&gt;太字&lt;/b&gt;。\n        &lt;ul&gt;\n            &lt;li&gt;これは項目&lt;/li&gt;\n            &lt;li&gt;これも項目&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n        これも段落。\n    &lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nしかし、HTMLには次のような欠点があります。\n\n書くのが面倒\n読みにくい\nソースと表示が大きくことなる\n\nそこで、スタイルなどの細かい微調整は諦めてもっと簡潔に書式を記述できるようにしたのがマークダウンです。マークダウンでは上記と同じ文書が次のようになります。\n# これは見出し\n\n## これは小見出し\n\nこれは段落。これは**太字**。\n\n- これは項目\n- これも項目\n\nこれも段落。\nHTMLに比べると非常に簡潔であることが分かると思います。\nマークダウン文書を作成するまえに、以下のエクステンションをインストールする必要があります。\n\nMarkdown All in One (マークダウン便利ツール集)\nmarkdownlint (Markdownの構文チェッカー)\nMarkdown PDF (MarkdownファイルをPDFやHTMLに変換)\n\nそのほか、図やスライドを作るには、以下のエクステンションが必要です。\n\nDraw.io Integration (図の作成)\nMarp for VS Code (スライドの作成)\n\nエクステンションがインストールできたら、早速マークダウンを書いてみましょう。VS Codeのエクスプローラで、my_first_markdown.mdというファイルを作成し、開いてください。(マークダウン文書の拡張子は必ず.mdにします。)文書を開いたら、Emacsキーバインドなどを活用しつつ、上述のマークダウン文書を打ち込んでいきましょう。\n\n\n\nmarkdown\n\n\n上図で、画面の左がソースファイルの編集画面、右側にはプレビューが表示されます。ソースとプレビューを比較すると分かるように、両者に大きな違いがないことが分かります。これがマークダウンの最大の特徴です。\n\n\n\n\n\n\n\n\n記法\n解説\n出力\n\n\n\n\n# 見出し\n# + 半角スペース +　見出し文字列\n大見出し(タイトル)\n\n\n## 見出し\n## + 半角スペース +　見出し文字列\n中見出し(セクション)\n\n\n### 見出し\n### + 半角スペース +　見出し文字列\n小見出し\n\n\n**文字**\n** + 太字にしたい文字列 + **\n太字\n\n\n- 項目\nマイナス記号 + 半角スペース + 箇条書き項目\n箇条書き\n\n\n1. 項目\n数字 + ピリオド + 半角スペース + 箇条書き項目\n数字付き箇条書き\n\n\n----\nハイフン三つ以上\n水平線\n\n\n[ハイパーリンク](https://homepage.com)\n[文字列](URL)\nハイパーリンク\n\n\n\n見出しは#記号の数が多いほど小さくなります。見出しの前後は必ず1行の空行を入れます。\n# 見出し1\n\n## 見出し2\n\n### 見出し3\n\n#### 見出し4\nなお、入れ子の箇条書きをVS Codeで作る時はタブキーで字下げをすると入れ子になります。(ちなみに、Shift+Tabで字下げを元に戻せます。)\n1. 項目1\n  1. 項目1-1\n  2. 項目1-2\n2. 項目2\n表は次のように作ります。\n|商品|個数|値段|\n|--|--|--|\n|りんご|2個|200円|\n|みかん|8個|350円|\n|バナナ|1房|100円|\n\n\nmy_first_markdown.mdに上記の見出し、入れ子の箇条書き、表の例を記述し、プレビューを確認しなさい。以下のようになりましたか？\n\n\n\nmarkdown_practice\n\n\nなお、URLリンクの挿入は以下のようにします。\nプログラミングのHPは[こちら](https://kut-econ.github.io/programming2021/)。\nコード断片の挿入は以下のようにします。\n```python\n# %%\nx = 1\ny = 1\nz = x + y\nprint(z)\n```\n上記のpythonの部分には、markdown、R、C、bashなど、言語の名前を指定します。\n\n\n\n\nMarkdown All in Oneがインストールしてあれば、簡単に目次をつけることができます。この目次は、文書を変更すると、その内容を自動的に反映してくれる便利な目次です。一度挿入すれば、二度とマニュアルで編集する必要はありません。\n文書の先頭、大見出しのすぐ下にカーソルをもっていき、Ctrl-Shift-Pを叩いてコマンドパレットを出してください。Create tableと入力すると、Markdown All in One: Create Table of Contentsという選択肢が出てきますので、これを選択すると、目次が挿入されます。\n\n\n\n拡張機能Markdown PDFをインストールすれば、マークダウンファイルをPDFに出力できます。\nCtrl-Shift-Pでコマンドパレットを起動し、exportと入力してください。幾つか選択肢が出てきますが、その中からMarkdown PDF: Export (pdf)を選択します。これだけで、現在開いているマークダウンファイルが同じディレクトリにPDF形式で出力されます。\n\n\n\nVS Codeで図を作成するには、Draw.io Integrationという拡張機能をインストールする必要があります。Ctrl-Shift-XでDraw.io Integrationを検索し、インストールしてください。\nVS Codeで、.drawio.pngという拡張子のファイルを作ってください。たとえばfilename.drawio.pngのような名前にします。これをクリックすると、ドローイングツールのDrawioが起動して、図を作成できるようになります。\n図を作成したら、次のようにして、マークダウン中に挿入できます。\n![sample-img](filename.drawio.png)\nここで、URLリンクとは違って、最初に!マークが入っていることに注意してください。\n\n\n\nマークダウンでスライドを作るには、拡張機能のMarp for VS Codeをインストールします。\nMarpがインストールできたら、VS Codeでマークダウンファイルを新たに作成してください。ファイル名は何でも構いませんが、slide.mdにしておきましょう。\nslide.mdを開いて、ファイルの先頭に、次のように記述してください。\n---\nmarp: true\n---\n&lt;!--\nheadingDivider: 2\n--&gt;\nmarp:とtrueの間に一つスペースを入れるのを忘れないようにしてください。これで、レベル2の見出しがスライド頁の区切りになります。\nたとえば、以下のように入力してみてください。プレビューがスライドになるはずです。\n---\nmarp: true\n---\n&lt;!--\nheadingDivider: 2\n--&gt;\n\n# Marpで楽しくスライド作り\n\n1234567 工科太郎\n\n## これは頁タイトルになる\n\nここは2ページ目である。\n\n1. 番号付き箇条書き項目である\n2. 番号付き箇条書き項目である\n3. 番号付き箇条書き項目である\nPDFに出力することも簡単にできますので試してみてください(編集画面の上のほうにある三角マークからできます)。\nVS Codeの話は上記でおしまいです。VS Codeには他にも様々な拡張機能があるので、色々探してみてください。\n\n\n\n\nAnacondaとは、Pythonを中心として、データサイエンスを実践する上で便利なソフトウェアを多数まとめたものです。最初からPythonを使って様々な作業を行うための環境が整っているので、初心者でもPythonを始めやすい特徴があります。また、仮想環境を自由に作成することができ、仮想環境ごとに異なるバージョンのPythonをインストールしたり、追加パッケージをインストールすることができるという便利さがあります。近年の入門書の多くがAnacondaを推奨していることを鑑み、本講義でもAnacondaを用いることにします。\nAnacondaを使用するうえで最初に理解しなければならないことは、一つのパソコンには複数のPythonがインストールされている場合があるので、今自分がどのPythonを使っているのかいつも意識すべきであるということです。\n下の図のように、パソコンにPythonが直接インストールされている場合がありますし、Anaconda仮想環境のそれぞれにPythonがインストールされている場合もありますが、これらは全て別のものです。自分が思っているのと違うPythonを気づかずに使っていると、「思っていたのと挙動が違う!」というトラブルにハマってしまうことになるので、注意しましょう。慣れないうちは、Anacondaのbase仮想環境にインストールされているPythonを使用するようにしましょう。\n\n\n\nanaconda.drawio.PNG\n\n\n\n\n\nこの設定が必要なのは、大学の有線LANに接続する場合だけです。それ以外の方は、この項目は読み飛ばしてください!\nここからはAnacondaの解説をします。大学の有線LANに繋がっている研究室のパソコン等でAnacondaを使用する場合、プロキシの設定が必要です。\nWindowsスタートメニューから、Anaconda Promptを起動し、次のように入力すると、プロキシの設定が表示されます。\n(base) C:\\Users\\hoge&gt;conda config --show proxy_servers\nproxy_servers: {}\n上記のようにproxy_serversの項目が空欄になっていたら、プロキシが設定されていません。その場合は、以下のように順次入力してhttpとhttpsの両方にnocのプロキシサーバーを設定しましょう。\n(base) C:\\Users\\hoge&gt;conda config --set proxy_servers.http http://proxy-server-addr:????\n(base) C:\\Users\\hoge&gt;conda config --set proxy_servers.https http://proxy-server-addr:????\nここで、proxy-server.addrは正しいプロキシサーバーのアドレス(Moodleに記載)に、????は正しいポート番号に置き換えてください。\nもう一度設定を表示して、プロキシが正しく設定されているか確認しましょう。\n(base) C:\\Users\\hoge&gt;conda config --show proxy_servers\nproxy_servers:\n  http: http://proxy-server-addr:????\n  https: http://proxy-server-addr:????\n上記の用に表示されれば正しく設定されています。\n\n\n\n大学のPCでは、Anacondaに追加機能をインストールすることはできません。Anacondaに追加機能をインストールするには、Windowsの管理者権限が必要だからです。また、管理者権限があったとしても、Anacondaを直接いじるのは不安です。良く分からない追加機能をインストールして、Anaconda全体に不具合が生じるかもしれないからです。\nこのような問題を解決するために、Anacondaには仮想環境という仕組みが備わっています。仮想環境とは、新しくPythonがインストールされていて、自由にパッケージのインストール・アンインストールを行うことができる自分専用の環境のことです。(解説はしませんが、Anacondaがない場合はvenvモジュールによって仮想環境を作ることができます。)\nPythonを使っていると、必ず近いうちに複数のバージョンのPythonを使い分けなくてはならない時がやってきます。その時のために、今から仮想環境に慣れましょう。\n\n\n\nAnacondaをインストールすると、baseという名前のデフォルトの仮想環境が作成されます。Anaconda promptを起動すると、base環境が起動している状態になります。試しに次のようにして、base環境を停止してみましょう。\n(base) C:\\Users\\hoge&gt;conda deactivate\n\nC:\\Users\\hoge&gt;\nプロンプトから(base)という文字列が無くなりました。この状態では、全ての仮想環境がストップしています。再びbaseを起動するために、次のように入力しましょう。\nC:\\Users\\hoge&gt;conda activate\n\n(base) C:\\Users\\hoge&gt;\n次に、現在存在している仮想環境をcondaコマンドでチェックしておきましょう。以下のように打ち込みます。\n(base) C:\\Users\\hoge&gt;conda env list\n# conda environments:\n#\nbase                  *  E:\\ProgramData\\Anaconda3\n最初は仮想環境がbaseしか存在しないので、#のある行を除けば1行しか出力されません。アスタリスク(*)は、現在自分のいる仮想環境がbaseであることを示しており、そのあとのパスはbaseがインストールされているディレクトリを表しています。全く同じ出力は、次のようにしても得られます。\n(base) C:\\Users\\hoge&gt;conda info --envs\n# conda environments:\n#\nbase                  *  E:\\ProgramData\\Anaconda3\nPythonでデータ解析を行うためには、様々なパッケージをインストールする必要があります。パッケージは仮想環境ごとに異なるものをインストールすることが出来ますが、baseには最初から多くのパッケージがインストールされています。baseにインストールされているパッケージのリストを取得してみましょう。\n(base) C:\\Users\\hoge&gt;conda list\n# packages in environment at E:\\ProgramData\\Anaconda3:\n#\n# Name                    Version                   Build  Channel\n_anaconda_depends         2020.07                  py38_0\n_ipyw_jlab_nb_ext_conf    0.1.0                    py38_0\nalabaster                 0.7.12             pyhd3eb1b0_0\nanaconda                  custom                   py38_1\nanaconda-client           1.7.2                    py38_0\n\n...（中略）...\n\nxz                        5.2.5                h62dcd97_0\nyaml                      0.2.5                he774522_0\nyapf                      0.31.0             pyhd3eb1b0_0\nzeromq                    4.3.3                ha925a31_3\nzfp                       0.5.5                hd77b12b_6\nzict                      2.0.0              pyhd3eb1b0_0\nzipp                      3.4.1              pyhd3eb1b0_0\nzlib                      1.2.11               h62dcd97_4\nzope                      1.0                      py38_1\nzope.event                4.5.0                    py38_0\nzope.interface            5.3.0            py38h2bbff1b_0\nzstd                      1.4.5                h04227a9_0\nものすごく長い出力が得られたと思いますが、これらが全て予めインストールされているパッケージです。非常に多くのパッケージが既にインストール済みですので、データ解析では、多くの場合base環境だけで事足ります。しかしながら、例えば実験プログラミング用パッケージであるotreeはインストールされていませんので、こういったパッケージをインストールする場合には、新たな仮想環境の構築が必須になります。\n\n\n\nそれではいよいよ、仮想環境を作ってみましょう。たとえばmyenvという名前の仮想環境を作るには次のようにします。\n(base) C:\\Users\\hoge&gt;conda create -n myenv\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: E:\\ProgramData\\Anaconda3\\envs\\myenv\n\nProceed ([y]/n)?\nenvironmental location:の所に出てくるパスに仮想環境が構築されることになりますが、具体的なパスは人によって異なります。(パスを変更することもできますが、ここでは説明を省略します。)\n以下のように’y’と入力すると、仮想環境が構築されます。\nProceed ([y]/n)? y\n\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\n#\n# To activate this environment, use\n#\n#     $ conda activate myenv\n#\n# To deactivate an active environment, use\n#\n#     $ conda deactivate\n\n\n(base) C:\\Users\\hoge&gt;\nちゃんと環境ができているかチェックしましょう。\n(base) C:\\Users\\hoge&gt;conda info -e\n# conda environments:\n#\nbase                  *  E:\\ProgramData\\Anaconda3\nmyenv                    E:\\ProgramData\\Anaconda3\\envs\\myenv\nたしかにmyenvという環境が出来ているようですが、アスタリスク記号*はbaseについており、myenvは起動していないことが分かります。myenvを起動するには、次のようにします。\n(base) C:\\Users\\hoge&gt;conda activate myenv\n\n(myenv) C:\\Users\\hoge&gt;\nプロンプトが(base)から(myenv)に変わり、myenv環境が起動しました。myenv環境にインストールされているパッケージのリストを表示してみましょう。\n(myenv) C:\\Users\\hoge&gt;conda list\n# packages in environment at E:\\ProgramData\\Anaconda3\\envs\\myenv:\n#\n# Name                    Version                   Build  Channel\n\n(myenv) C:\\Users\\hoge&gt;\n全くパッケージが入っていないことが分かります。Pythonすら入っていません。たとえばPythonのバージョン3.8をこの環境にインストールするには、次のようにします。\n(myenv) C:\\Users\\hoge&gt;conda install python=3.8\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: E:\\ProgramData\\Anaconda3\\envs\\myenv\n\n  added / updated specs:\n    - python=3.8\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    python-3.8.8               |       hdbf39b2_5        15.8 MB\n    ------------------------------------------------------------\n                                           Total:        15.8 MB\n\nThe following NEW packages will be INSTALLED:\n\n  ca-certificates    pkgs/main/win-64::ca-certificates-2021.4.13-haa95532_1\n  certifi            pkgs/main/win-64::certifi-2020.12.5-py38haa95532_0\n  openssl            pkgs/main/win-64::openssl-1.1.1k-h2bbff1b_0\n  pip                pkgs/main/win-64::pip-21.0.1-py38haa95532_0\n  python             pkgs/main/win-64::python-3.8.8-hdbf39b2_5\n  setuptools         pkgs/main/win-64::setuptools-52.0.0-py38haa95532_0\n  sqlite             pkgs/main/win-64::sqlite-3.35.4-h2bbff1b_0\n  vc                 pkgs/main/win-64::vc-14.2-h21ff451_1\n  vs2015_runtime     pkgs/main/win-64::vs2015_runtime-14.27.29016-h5e58377_2\n  wheel              pkgs/main/noarch::wheel-0.36.2-pyhd3eb1b0_0\n  wincertstore       pkgs/main/win-64::wincertstore-0.2-py38_0\n\n\nProceed ([y]/n)?\nyを入力して続行すると、pythonをインストールできます。(しばらく時間がかかります。)実際にインストールされたかどうか確かめて見ましょう。\n(myenv) C:\\Users\\hoge&gt;conda list\n# packages in environment at E:\\ProgramData\\Anaconda3\\envs\\myenv:\n#\n# Name                    Version                   Build  Channel\nca-certificates           2021.4.13            haa95532_1\ncertifi                   2020.12.5        py38haa95532_0\nopenssl                   1.1.1k               h2bbff1b_0\npip                       21.0.1           py38haa95532_0\npython                    3.8.8                hdbf39b2_5\nsetuptools                52.0.0           py38haa95532_0\nsqlite                    3.35.4               h2bbff1b_0\nvc                        14.2                 h21ff451_1\nvs2015_runtime            14.27.29016          h5e58377_2\nwheel                     0.36.2             pyhd3eb1b0_0\nwincertstore              0.2                      py38_0\n\n(myenv) C:\\Users\\hoge&gt;\nちゃんとPythonがインストールされていることが分かります。REPLを起動してみましょう。\n(myenv) C:\\Users\\hoge&gt;python\nPython 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\nパッケージをインストールしたいときは、\nconda install package_name\nのように入力します。package_nameはパッケージ名です。パッケージのバージョンまで指定したいときは、\nconda install package_name=ver_num\nとします。ver_numはバージョン番号です。\nたとえば、次のようにすればデータ解析パッケージのpandasをインストールできます。注)myenv環境に、Rのバージョン3.6やCのコンパイラ、アセンブラ等を入れておいてください。やり方はFAQを参照。\nconda install pandas\nmyenv環境を停止してbaseに戻る時は、\nconda deactivate\nと入力します。\n最後にcondaコマンドをまとめておきましょう。\n\n\n\n\n\n\n\nコマンド\n動作\n\n\n\n\nconda --help\ncondaコマンドのヘルプを表示\n\n\nconda command --help\nコマンドcommandのヘルプを表示\n\n\nconda config --show\n全てのパラメータを表示\n\n\nconda config --show par\nパラメータparの設定を表示\n\n\nconda config --set par value\nパラメータparの値をvalueに設定\n\n\nconda config --remove-key par\nパラメータparの設定を消去\n\n\nconda info --envs\n全ての仮想環境を表示\n\n\nconda info -e\n同上\n\n\nconda env list\n同上\n\n\nconda create -n env_name\n仮想環境env_nameを作成\n\n\nconda list\n現環境のインストール済みパッケージをリストアップ\n\n\nconda install package\nパッケージpackageを現在環境にインストール\n\n\nconda install package=ver\nパッケージpackageのバージョンverを現環境にインストール\n\n\nconda remove package\nパッケージpackageを現環境からアンインストール\n\n\nconda remove -n env_name --all\n仮想環境env_nameを削除\n\n\n\n\n\n\n新しく作成した仮想環境myenvをVS Codeで呼び出すためには、その仮想環境にipykernelパッケージをインストールする必要があります。また、コード補完を行うためには、pyreadlineのインストールも必要です。\nconda activate myenv\nconda install ipykernel\n次にVS Codeを起動し、my_first_code.pyを開きましょう。この状態でCtrl-Shift-Pをたたいてコマンドパレットを呼び出し、selectと入力します。幾つか候補が出てきますが、その中からPython: Select Interpreterを選びます。すると、仮想環境のリストが表示されるので、正しい仮想環境を選びましょう。myenvがリストにない場合は、パレットにmyenvと入力するとリストに現れます。\n新環境myenvを選ぶと、VS Codeの画面下にある青い帯のところに、‘myenv’:condaと表示されます。\n\n\n\nmyenv\n\n\nこれで、インターラクティブモードで実行したPythonコードはすべて仮想環境myenvにインストールしたインタープリタによって実行されます。\n仮想環境をbaseに戻したいときは、同じようにコマンドパレットからbaseを呼び出しましょう。\n\n\n\n\n今回の講義では、次の点について学びました。\n\nVS Codeの設定\nVS Codeのインタラクティブモード\nEmacsキーバインド\nマークダウン記法\nAnacondaの設定\n仮想環境の構築\n\nエディターを使いこなすことはプログラミングの習得において大変重要です。VS Codeを自分のパソコンや研究室のパソコンにインストールし、Pythonコードやマークダウン文書の作成を通してEmacsキーバインドに慣れるようにしましょう。\n\n\n\n\n『Markdownライティング入門』(藤原 惟)(2018) インプレスR&D. ISBN-13:978-4844398363.\n\n\n\n\n\n\n\nこれはVS Codeのパスを環境変数PATHに追加することで解決します。VS Codeのショートカットを右クリックして、プロパティを選択し、「リンク先」に書いてあるパスをユーザー環境変数のPATHに追加します(システム環境変数ではありません)。実行ファイル名”Code.exe”はパスに含めないでください。これによってGitからも起動できるようになります。\n\n\n\nVS CodeのPythonスクリプト上で右上の実行ボタン(緑色の矢印)を押すと\n\nconda : 用語 ‘conda’ は、コマンドレット、関数、スクリプト ファイル、または操作可能なプログラムの名前として認 識されません。名前が正しく記述されていることを確認し、・・・\n\nというエラーが出ることがあります。これはcondaコマンドのあるディレクトリにパスを通すことで解決します。\nAnaconda Promptで、\nwhere conda\nと入力してcondaコマンドのパスを調べてください。そのパスを、windowsの環境変数PATHに加えれば解決します。複数出た場合は全部加えてください。\n\n\n\nREPLで日本語文字を使うと、それ以降\n\nUnicodeDecodeError: ‘cp932’ codec can’t decode byte 0x82 in position 96: illegal multibyte sequence\n\nというエラーが出るようになることがあります。これは大した問題ではありません。Anaconda Promptを起動したときのディレクトリにある.python_historyというファイルを削除すれば解決します。見つからない場合は、Windowsの設定で隠しファイルを表示しないモードになっているか、もしくは別のディレクトリに同ファイルがある可能性があります。Anaconda Promptで\necho %HOME%\nと叩いて表示されるディレクトリを探してみてください。Windowsで隠しファイル(ピリオドからはじまるファイル名)を表示しないモードになっていると見つからないのでご注意ください。\n\n\n\nmyenv環境をactivateしてから、次を実行します(以下のコマンドは、VSCode上で対話的にpythonを実行するためのパッケージipykernelも同時にインストールします)。\nconda install python=3.8 ipykernel\n\n\n\nmyenv環境をactivateしてから、次を実行します(以下のコマンドはrtools、cpp11、pryrも同時にインストールします)。\nconda install -c conda-forge r-base=3.6 rtools r-cpp11 r-pryr\nRがインストールできましたら、Rと入力して起動してください。\n\n\n\nmyenv環境をactivateしてから、次を実行します(以下のコマンドはcpp11、pryrも同時にインストールします)。Macではrtoolsは必要ありませんのでインストール不要です。MacではRのバージョン3.6が公開されていないように見受けられますので、とりあえずバージョン4.1で代用してください。\nconda install -c conda-forge r-base=4.1 r-cpp11 r-pryr\nRがインストールできましたら、Rと入力して起動してください。\n\n\n\nVS Codeの3つの設定項目\n\nR: Rterm\nR: Rpath\nR: Interpreter Path\n\nを設定します。\nmyenv環境でRをインストールしたら、RがインストールされているPathを調べてください。Anaconda Promptでmyenvを起動し、次のように入力すると表示されます。\nwhere R\nMacの場合はwhich Rになります。このPathを、上記の3つの設定項目すべてにコピーしてください。設定項目はCtrl-,で検索できます。\n\n\n\n次のようにして自身のAnaconda仮想環境にGNU Cコンパイラ、NASMアセンブラ、makeコマンドをインストールできます。なお、Cコンパイラをインストールする環境は、Rをインストールする環境とは別に(たとえばenvCという名前で)作成することをおすすめします。\nenvC環境にこれらをインストールする場合は、envCをactivateしてから、次のように入力します。\nconda install m2w64-gcc\nconda install -c anaconda nasm\nconda install -c conda-forge make"
  },
  {
    "objectID": "programming2025/programming-2.html#vs-codeを起動する",
    "href": "programming2025/programming-2.html#vs-codeを起動する",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "プログラマにとって、ソースコードやスクリプトを編集するためのエディタは、とても重要なものです。プログラミングの学習においては、エディタの研究にもしっかりと時間を割きましょう。本講義では、Visual Studio Code(VS Code)という、Microsoftが開発したフリーのエディタを用いることにします。\nそれでは早速VS Codeを起動してみましょう。ホームパス下にGitHubという名前のフォルダを作ってください。（注；本講義では、「フォルダー」と「ディレクトリ」をほとんど同じ意味で用います。）Windowsユーザーの人は、ドキュメントフォルダーの下に作るのが良いでしょう。Anaconda promptやコマンドプロンプトで次のように入力して得られるパスです。\necho %HOMEPATH%\nGitHubフォルダの場所はあまり重要ではないので、ホームパスがよくわからない人は、自分が分かりやすい場所に作っても構いません。GitHubフォルダを作ったら、その中にさらにmy_first_codeという名前のフォルダーを作りましょう。\nmy_first_codeの中身（からっぽ）をWindowsエクスプローラで表示し、右クリックすると「Codeで開く」という選択肢がありますので、それを選ぶと、VS Codeが起動します(下図)。「Codeで開く」が見つからない場合は、フォルダをVS Codeのショートカットアイコンにドラッグ&ドロップしてください。\n\nとりあえず覚えなくてはならないのは、左上のエクスプローラーと、それを開閉するボタンです。エクスプローラーでは、現在いるフォルダmy_first_codeの中にどのようなファイルがあるかを示しています。VS Codeのエクスプローラーの詳しい使い方については、『独習Python』のp30-31を読んでください。"
  },
  {
    "objectID": "programming2025/programming-2.html#vs-code-ショートカット",
    "href": "programming2025/programming-2.html#vs-code-ショートカット",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "VS Codeを使うに当たって、覚えたほうが良いショートカットが3つあります。\n\nCtrl-Shift-P: コマンドパレットを開きます。VS Codeの諸々の操作は、このコマンドパレットに望みの操作に関連するキーワードを入力し、出てきた操作リストの中から望みの操作を選択するという形で行います。\nCtrl-Shift-X: 拡張機能検索ウィンドウとインストール済み拡張機能の一覧を表示します。邪魔な拡張機能を無効にしたり、新しい拡張機能を探してインストールするのに使います。\nCtrl-,: 設定項目検索ウィンドウを開きます。注)設定ファイルを直接編集するときは、コマンドパレットにsettings.jsonと入力してください。"
  },
  {
    "objectID": "programming2025/programming-2.html#プロキシの設定vs-code",
    "href": "programming2025/programming-2.html#プロキシの設定vs-code",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "この設定が必要なのは、大学の有線LANに接続する場合だけです。それ以外の方は、この項目は読み飛ばしてください!\nVS Codeを快適に使うためには、インターネット経由で様々なエクステンション(拡張機能)をインストールする必要があります。大学内の有線LANに接続してエクステンション（拡張機能）をインストールするためには、プロキシの設定が必要です。\nCtrl-,と叩くと、設定のための検索窓が立ち上がりますので、proxyと入力しましょう。すると、\nHttp: Proxy\n使用するプロキシ設定。設定されていない場合は、'http_proxy' および &gt;'https_proxy' の環境変数から継承されます。\n[                                        ]\nというproxy設定パネルが現れますので、次のように大学のプロキシサーバーとポート番号を入力しましょう。ただし、ここで、http://proxy-server-addr:????の箇所は、大学のプロキシサーバーの正しいURLとポート番号に置き換えてください。正しいURLとポート番号はMoodle(KUTLMS)に記載してあります。\nHttp: Proxy\n使用するプロキシ設定。設定されていない場合は、'http_proxy' および 'https_proxy' の環境変数から継承されます。\n[http://proxy-server-addr:????            ]"
  },
  {
    "objectID": "programming2025/programming-2.html#各種エクステンションのインストール",
    "href": "programming2025/programming-2.html#各種エクステンションのインストール",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "プロキシの設定ができましたので、各種エクステンションがインストールできます。エクステンション（拡張機能）をインストールするには、Ctrl-Shift-Xを叩きます。現れた検索ウィンドウにエクステンション名を入力すれば、候補をリストアップしてくれますので、望みのものを選んでインストールボタンを押しましょう。\n以下のエクステンションが必要ですので、インストールしましょう。\n\nJapanese Language Pack for VS Code (VS Codeを日本語化)\nPython(Microsoftのもの)\nJupyter(インターラクティブモード)\nAwesome Emacs Keymap (Emacsキーバインディング)\nMarkdown All in One (マークダウン便利ツール集)\nmarkdownlint (Markdownの構文チェッカー)\nMarkdown PDF (MarkdownファイルをPDFやHTMLに変換)"
  },
  {
    "objectID": "programming2025/programming-2.html#vs-codeインターラクティブモード",
    "href": "programming2025/programming-2.html#vs-codeインターラクティブモード",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "それでは大体の準備ができたので、いよいよVS Codeでプログラミングしてみましょう。Pythonのプログラミングを行うときは、インターラクティブモードという、VS Codeの内部でJupyterを起動する方法が便利です。\nVS Codeのエクスプローラからmy_first_code.pyというファイルを作成し、開いてください(教科書pp.30-31参照)。1行目に次のように入力してください。\n#%%\nもし編集画面が次のように変化すればインターラクティブモードの起動に成功したことを表します。\n\n\n\ninteractive\n\n\n尚、初回は「インタープリタが未選択」という通知が出る場合があります。 これは、後述するように、一つのパソコンに複数のPythonがインストールされている可能性があるので、どのPythonを使うのか定められていないということです。その時は、通知内容にしたがって、インタープリタを選択します。“Python 3.x.x xx-bit (‘base’: conda)”を選択してください。(xは各自の環境に依存します。)正しいインタープリタが選択されていれば、画面の右下に、“Python 3.x.x xx-bit (‘base’: conda)”の表記が表示されます。正しいインタープリタが選択されていない場合は、「VS Codeで特定の仮想環境を使う」の欄の記述に従って、選択を行ってください。\n\n\n\nselect_base_interpreter.PNG\n\n\nためしに、簡単な計算を行ってみましょう。“#%%”記号のすぐ下に計算式を書いてShift-Enterと叩いてみましょう。すると次のように編集画面が変化します。\n\n\n\ninteractive_opo\n\n\nこの編集画面で”#%%“記号と青線に挟まれた部分はセルと呼ばれ、この部分に記述されたPythonコードは、Shift-Enterによってまとめて実行されます。\n一方、セルを実行して得られた結果は、画面右のインターラクティブウィンドウに表示されます。\n\n\n\ninterative_opo2\n\n\n上図で右側がインターラクティブウィンドウです。1+1の結果である2が表示されています。\n\n\nVS Codeインターラクティブモードを用いて、以下のような様々な計算を行ってみなさい。なお、以降の講義では、VS Code上のコードを# %%、REPL上のコードを&gt;&gt;&gt;で表すことにします。注)&gt;&gt;&gt;記号はプロンプトなので、入力する必要はありません。\n# %%\nx = 1\ny = 2\nprint(x + y)\n# %%\nz = x + y\nprint(y ** z)\n# %%\nprint(\"Hello, World!\")\nいくつかセルが出来たら、“# %%”記号の横にある”Run Cell”、“Run Above”、“Run Below”などをクリックしてみましょう。何が起きたか分かりますか？(“Run Debug”は難しいのでクリックしないように。)"
  },
  {
    "objectID": "programming2025/programming-2.html#emacsキーバインディング",
    "href": "programming2025/programming-2.html#emacsキーバインディング",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "これで自由にPythonコードを実行できるようになりました。ここで、ついでにEmacsキーバインディングの練習をしましょう。まず、上で説明した手順にしたがって、Awesome Emacs Keymapエクステンションをインストールしてください。\nAwesome Emacs Keymapエクステンションをインストールすると、Emacsキーバインディングが使えるようになります。 my_first_code.pyを開き、コードの任意の箇所にカーソルを置いて、Ctrl-nと叩いてみましょう。カーソルが次の行に移動したらキーバインディングが正常に機能しています。Ctrl-pと叩けばカーソルが前の行に移動するはずです。このように、キーバインドを使うと、マウスを使わずにカーソルを移動できます。\n主なEmacsキーバインディングは以下の通りです。\n\n\n\nキー操作\n動作\n\n\n\n\nCtrl-n\n次の行に移動\n\n\nCtrl-p\n前の行に移動\n\n\nCtrl-b\n前の文字に移動\n\n\nCtrl-f\n次の文字に移動\n\n\nCtrl-a\n行頭へ移動\n\n\nCtrl-e\n行末へ移動\n\n\nCtrl-v\n次のページへ移動\n\n\nAlt-v\n前のページへ移動\n\n\nCtrl-k\n現在の行のカーソル以降を削除\n\n\nCtrl-d\n前方一文字削除\n\n\nCtrl-h\n後方一文字削除\n\n\nCtrl-s\n順方向検索\n\n\nCtrl-r\n逆方向検索\n\n\nCtrl-x Ctrl-s\n保存\n\n\nCtrl-x Ctrl-u\nアンドゥ\n\n\nCtrl-space\nマーク設定\n\n\nCtrl-w\nマーク設定地点からカーソル位置までをカット\n\n\nCtrl-y\n貼り付け\n\n\nCtrl-x Ctrl-c\nエディター終了\n\n\n\nこれらのキーバインドを駆使して、可能な限りマウスに触らないでコーディングするように練習してください。\nタッチタイピングで視線の移動を減らし、Emacsキーバインディングで手の移動を減らして、ストレスのないプログラミング生活を楽しみましょう。上記の他にも多数の便利なキー操作がありますので、インターネット等で調べてみてください。また、ここでは説明しませんが、VS Codeはキーバインドを細かくカスタマイズすることもできます。気になる人は、インターネットでカスタマイズの方法を調べてみましょう。\n\n\nmy_first_code.pyの上で、上の表に上げたキーバインドを一つずつ試してみましょう。"
  },
  {
    "objectID": "programming2025/programming-2.html#マークダウン入門",
    "href": "programming2025/programming-2.html#マークダウン入門",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "次に、簡単なマークダウンファイルを作成してみましょう。マークダウンとは、HTMLのようなマークアップ言語の一種で、プレーンテキスト文書に書式を付けて文書を整形するための言語です。ホームページを記述するためのHTML(HyperText Markup Language)については皆さんご存知かとおもいますが、Markdownは、HTMLよりももっと機能を限定して簡略化したようなものです。(ちなみに本講義資料も全てマークダウンで記述しました。)\nHTMLでは、たとえば見出しや段落を作るとき、次のようなテキスト文書をつくります。\n&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;見出し&lt;/h1&gt;\n    &lt;h2&gt;これは小見出し&lt;/h2&gt;\n    &lt;p&gt;\n        これは段落。これは&lt;b&gt;太字&lt;/b&gt;。\n        &lt;ul&gt;\n            &lt;li&gt;これは項目&lt;/li&gt;\n            &lt;li&gt;これも項目&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n        これも段落。\n    &lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nしかし、HTMLには次のような欠点があります。\n\n書くのが面倒\n読みにくい\nソースと表示が大きくことなる\n\nそこで、スタイルなどの細かい微調整は諦めてもっと簡潔に書式を記述できるようにしたのがマークダウンです。マークダウンでは上記と同じ文書が次のようになります。\n# これは見出し\n\n## これは小見出し\n\nこれは段落。これは**太字**。\n\n- これは項目\n- これも項目\n\nこれも段落。\nHTMLに比べると非常に簡潔であることが分かると思います。\nマークダウン文書を作成するまえに、以下のエクステンションをインストールする必要があります。\n\nMarkdown All in One (マークダウン便利ツール集)\nmarkdownlint (Markdownの構文チェッカー)\nMarkdown PDF (MarkdownファイルをPDFやHTMLに変換)\n\nそのほか、図やスライドを作るには、以下のエクステンションが必要です。\n\nDraw.io Integration (図の作成)\nMarp for VS Code (スライドの作成)\n\nエクステンションがインストールできたら、早速マークダウンを書いてみましょう。VS Codeのエクスプローラで、my_first_markdown.mdというファイルを作成し、開いてください。(マークダウン文書の拡張子は必ず.mdにします。)文書を開いたら、Emacsキーバインドなどを活用しつつ、上述のマークダウン文書を打ち込んでいきましょう。\n\n\n\nmarkdown\n\n\n上図で、画面の左がソースファイルの編集画面、右側にはプレビューが表示されます。ソースとプレビューを比較すると分かるように、両者に大きな違いがないことが分かります。これがマークダウンの最大の特徴です。\n\n\n\n\n\n\n\n\n記法\n解説\n出力\n\n\n\n\n# 見出し\n# + 半角スペース +　見出し文字列\n大見出し(タイトル)\n\n\n## 見出し\n## + 半角スペース +　見出し文字列\n中見出し(セクション)\n\n\n### 見出し\n### + 半角スペース +　見出し文字列\n小見出し\n\n\n**文字**\n** + 太字にしたい文字列 + **\n太字\n\n\n- 項目\nマイナス記号 + 半角スペース + 箇条書き項目\n箇条書き\n\n\n1. 項目\n数字 + ピリオド + 半角スペース + 箇条書き項目\n数字付き箇条書き\n\n\n----\nハイフン三つ以上\n水平線\n\n\n[ハイパーリンク](https://homepage.com)\n[文字列](URL)\nハイパーリンク\n\n\n\n見出しは#記号の数が多いほど小さくなります。見出しの前後は必ず1行の空行を入れます。\n# 見出し1\n\n## 見出し2\n\n### 見出し3\n\n#### 見出し4\nなお、入れ子の箇条書きをVS Codeで作る時はタブキーで字下げをすると入れ子になります。(ちなみに、Shift+Tabで字下げを元に戻せます。)\n1. 項目1\n  1. 項目1-1\n  2. 項目1-2\n2. 項目2\n表は次のように作ります。\n|商品|個数|値段|\n|--|--|--|\n|りんご|2個|200円|\n|みかん|8個|350円|\n|バナナ|1房|100円|\n\n\nmy_first_markdown.mdに上記の見出し、入れ子の箇条書き、表の例を記述し、プレビューを確認しなさい。以下のようになりましたか？\n\n\n\nmarkdown_practice\n\n\nなお、URLリンクの挿入は以下のようにします。\nプログラミングのHPは[こちら](https://kut-econ.github.io/programming2021/)。\nコード断片の挿入は以下のようにします。\n```python\n# %%\nx = 1\ny = 1\nz = x + y\nprint(z)\n```\n上記のpythonの部分には、markdown、R、C、bashなど、言語の名前を指定します。\n\n\n\n\nMarkdown All in Oneがインストールしてあれば、簡単に目次をつけることができます。この目次は、文書を変更すると、その内容を自動的に反映してくれる便利な目次です。一度挿入すれば、二度とマニュアルで編集する必要はありません。\n文書の先頭、大見出しのすぐ下にカーソルをもっていき、Ctrl-Shift-Pを叩いてコマンドパレットを出してください。Create tableと入力すると、Markdown All in One: Create Table of Contentsという選択肢が出てきますので、これを選択すると、目次が挿入されます。\n\n\n\n拡張機能Markdown PDFをインストールすれば、マークダウンファイルをPDFに出力できます。\nCtrl-Shift-Pでコマンドパレットを起動し、exportと入力してください。幾つか選択肢が出てきますが、その中からMarkdown PDF: Export (pdf)を選択します。これだけで、現在開いているマークダウンファイルが同じディレクトリにPDF形式で出力されます。\n\n\n\nVS Codeで図を作成するには、Draw.io Integrationという拡張機能をインストールする必要があります。Ctrl-Shift-XでDraw.io Integrationを検索し、インストールしてください。\nVS Codeで、.drawio.pngという拡張子のファイルを作ってください。たとえばfilename.drawio.pngのような名前にします。これをクリックすると、ドローイングツールのDrawioが起動して、図を作成できるようになります。\n図を作成したら、次のようにして、マークダウン中に挿入できます。\n![sample-img](filename.drawio.png)\nここで、URLリンクとは違って、最初に!マークが入っていることに注意してください。\n\n\n\nマークダウンでスライドを作るには、拡張機能のMarp for VS Codeをインストールします。\nMarpがインストールできたら、VS Codeでマークダウンファイルを新たに作成してください。ファイル名は何でも構いませんが、slide.mdにしておきましょう。\nslide.mdを開いて、ファイルの先頭に、次のように記述してください。\n---\nmarp: true\n---\n&lt;!--\nheadingDivider: 2\n--&gt;\nmarp:とtrueの間に一つスペースを入れるのを忘れないようにしてください。これで、レベル2の見出しがスライド頁の区切りになります。\nたとえば、以下のように入力してみてください。プレビューがスライドになるはずです。\n---\nmarp: true\n---\n&lt;!--\nheadingDivider: 2\n--&gt;\n\n# Marpで楽しくスライド作り\n\n1234567 工科太郎\n\n## これは頁タイトルになる\n\nここは2ページ目である。\n\n1. 番号付き箇条書き項目である\n2. 番号付き箇条書き項目である\n3. 番号付き箇条書き項目である\nPDFに出力することも簡単にできますので試してみてください(編集画面の上のほうにある三角マークからできます)。\nVS Codeの話は上記でおしまいです。VS Codeには他にも様々な拡張機能があるので、色々探してみてください。"
  },
  {
    "objectID": "programming2025/programming-2.html#anacondaとは",
    "href": "programming2025/programming-2.html#anacondaとは",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "Anacondaとは、Pythonを中心として、データサイエンスを実践する上で便利なソフトウェアを多数まとめたものです。最初からPythonを使って様々な作業を行うための環境が整っているので、初心者でもPythonを始めやすい特徴があります。また、仮想環境を自由に作成することができ、仮想環境ごとに異なるバージョンのPythonをインストールしたり、追加パッケージをインストールすることができるという便利さがあります。近年の入門書の多くがAnacondaを推奨していることを鑑み、本講義でもAnacondaを用いることにします。\nAnacondaを使用するうえで最初に理解しなければならないことは、一つのパソコンには複数のPythonがインストールされている場合があるので、今自分がどのPythonを使っているのかいつも意識すべきであるということです。\n下の図のように、パソコンにPythonが直接インストールされている場合がありますし、Anaconda仮想環境のそれぞれにPythonがインストールされている場合もありますが、これらは全て別のものです。自分が思っているのと違うPythonを気づかずに使っていると、「思っていたのと挙動が違う!」というトラブルにハマってしまうことになるので、注意しましょう。慣れないうちは、Anacondaのbase仮想環境にインストールされているPythonを使用するようにしましょう。\n\n\n\nanaconda.drawio.PNG"
  },
  {
    "objectID": "programming2025/programming-2.html#プロキシの設定anaconda",
    "href": "programming2025/programming-2.html#プロキシの設定anaconda",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "この設定が必要なのは、大学の有線LANに接続する場合だけです。それ以外の方は、この項目は読み飛ばしてください!\nここからはAnacondaの解説をします。大学の有線LANに繋がっている研究室のパソコン等でAnacondaを使用する場合、プロキシの設定が必要です。\nWindowsスタートメニューから、Anaconda Promptを起動し、次のように入力すると、プロキシの設定が表示されます。\n(base) C:\\Users\\hoge&gt;conda config --show proxy_servers\nproxy_servers: {}\n上記のようにproxy_serversの項目が空欄になっていたら、プロキシが設定されていません。その場合は、以下のように順次入力してhttpとhttpsの両方にnocのプロキシサーバーを設定しましょう。\n(base) C:\\Users\\hoge&gt;conda config --set proxy_servers.http http://proxy-server-addr:????\n(base) C:\\Users\\hoge&gt;conda config --set proxy_servers.https http://proxy-server-addr:????\nここで、proxy-server.addrは正しいプロキシサーバーのアドレス(Moodleに記載)に、????は正しいポート番号に置き換えてください。\nもう一度設定を表示して、プロキシが正しく設定されているか確認しましょう。\n(base) C:\\Users\\hoge&gt;conda config --show proxy_servers\nproxy_servers:\n  http: http://proxy-server-addr:????\n  https: http://proxy-server-addr:????\n上記の用に表示されれば正しく設定されています。"
  },
  {
    "objectID": "programming2025/programming-2.html#anaconda仮想環境",
    "href": "programming2025/programming-2.html#anaconda仮想環境",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "大学のPCでは、Anacondaに追加機能をインストールすることはできません。Anacondaに追加機能をインストールするには、Windowsの管理者権限が必要だからです。また、管理者権限があったとしても、Anacondaを直接いじるのは不安です。良く分からない追加機能をインストールして、Anaconda全体に不具合が生じるかもしれないからです。\nこのような問題を解決するために、Anacondaには仮想環境という仕組みが備わっています。仮想環境とは、新しくPythonがインストールされていて、自由にパッケージのインストール・アンインストールを行うことができる自分専用の環境のことです。(解説はしませんが、Anacondaがない場合はvenvモジュールによって仮想環境を作ることができます。)\nPythonを使っていると、必ず近いうちに複数のバージョンのPythonを使い分けなくてはならない時がやってきます。その時のために、今から仮想環境に慣れましょう。"
  },
  {
    "objectID": "programming2025/programming-2.html#仮想環境の状態チェック",
    "href": "programming2025/programming-2.html#仮想環境の状態チェック",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "Anacondaをインストールすると、baseという名前のデフォルトの仮想環境が作成されます。Anaconda promptを起動すると、base環境が起動している状態になります。試しに次のようにして、base環境を停止してみましょう。\n(base) C:\\Users\\hoge&gt;conda deactivate\n\nC:\\Users\\hoge&gt;\nプロンプトから(base)という文字列が無くなりました。この状態では、全ての仮想環境がストップしています。再びbaseを起動するために、次のように入力しましょう。\nC:\\Users\\hoge&gt;conda activate\n\n(base) C:\\Users\\hoge&gt;\n次に、現在存在している仮想環境をcondaコマンドでチェックしておきましょう。以下のように打ち込みます。\n(base) C:\\Users\\hoge&gt;conda env list\n# conda environments:\n#\nbase                  *  E:\\ProgramData\\Anaconda3\n最初は仮想環境がbaseしか存在しないので、#のある行を除けば1行しか出力されません。アスタリスク(*)は、現在自分のいる仮想環境がbaseであることを示しており、そのあとのパスはbaseがインストールされているディレクトリを表しています。全く同じ出力は、次のようにしても得られます。\n(base) C:\\Users\\hoge&gt;conda info --envs\n# conda environments:\n#\nbase                  *  E:\\ProgramData\\Anaconda3\nPythonでデータ解析を行うためには、様々なパッケージをインストールする必要があります。パッケージは仮想環境ごとに異なるものをインストールすることが出来ますが、baseには最初から多くのパッケージがインストールされています。baseにインストールされているパッケージのリストを取得してみましょう。\n(base) C:\\Users\\hoge&gt;conda list\n# packages in environment at E:\\ProgramData\\Anaconda3:\n#\n# Name                    Version                   Build  Channel\n_anaconda_depends         2020.07                  py38_0\n_ipyw_jlab_nb_ext_conf    0.1.0                    py38_0\nalabaster                 0.7.12             pyhd3eb1b0_0\nanaconda                  custom                   py38_1\nanaconda-client           1.7.2                    py38_0\n\n...（中略）...\n\nxz                        5.2.5                h62dcd97_0\nyaml                      0.2.5                he774522_0\nyapf                      0.31.0             pyhd3eb1b0_0\nzeromq                    4.3.3                ha925a31_3\nzfp                       0.5.5                hd77b12b_6\nzict                      2.0.0              pyhd3eb1b0_0\nzipp                      3.4.1              pyhd3eb1b0_0\nzlib                      1.2.11               h62dcd97_4\nzope                      1.0                      py38_1\nzope.event                4.5.0                    py38_0\nzope.interface            5.3.0            py38h2bbff1b_0\nzstd                      1.4.5                h04227a9_0\nものすごく長い出力が得られたと思いますが、これらが全て予めインストールされているパッケージです。非常に多くのパッケージが既にインストール済みですので、データ解析では、多くの場合base環境だけで事足ります。しかしながら、例えば実験プログラミング用パッケージであるotreeはインストールされていませんので、こういったパッケージをインストールする場合には、新たな仮想環境の構築が必須になります。"
  },
  {
    "objectID": "programming2025/programming-2.html#仮想環境の構築",
    "href": "programming2025/programming-2.html#仮想環境の構築",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "それではいよいよ、仮想環境を作ってみましょう。たとえばmyenvという名前の仮想環境を作るには次のようにします。\n(base) C:\\Users\\hoge&gt;conda create -n myenv\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: E:\\ProgramData\\Anaconda3\\envs\\myenv\n\nProceed ([y]/n)?\nenvironmental location:の所に出てくるパスに仮想環境が構築されることになりますが、具体的なパスは人によって異なります。(パスを変更することもできますが、ここでは説明を省略します。)\n以下のように’y’と入力すると、仮想環境が構築されます。\nProceed ([y]/n)? y\n\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\n#\n# To activate this environment, use\n#\n#     $ conda activate myenv\n#\n# To deactivate an active environment, use\n#\n#     $ conda deactivate\n\n\n(base) C:\\Users\\hoge&gt;\nちゃんと環境ができているかチェックしましょう。\n(base) C:\\Users\\hoge&gt;conda info -e\n# conda environments:\n#\nbase                  *  E:\\ProgramData\\Anaconda3\nmyenv                    E:\\ProgramData\\Anaconda3\\envs\\myenv\nたしかにmyenvという環境が出来ているようですが、アスタリスク記号*はbaseについており、myenvは起動していないことが分かります。myenvを起動するには、次のようにします。\n(base) C:\\Users\\hoge&gt;conda activate myenv\n\n(myenv) C:\\Users\\hoge&gt;\nプロンプトが(base)から(myenv)に変わり、myenv環境が起動しました。myenv環境にインストールされているパッケージのリストを表示してみましょう。\n(myenv) C:\\Users\\hoge&gt;conda list\n# packages in environment at E:\\ProgramData\\Anaconda3\\envs\\myenv:\n#\n# Name                    Version                   Build  Channel\n\n(myenv) C:\\Users\\hoge&gt;\n全くパッケージが入っていないことが分かります。Pythonすら入っていません。たとえばPythonのバージョン3.8をこの環境にインストールするには、次のようにします。\n(myenv) C:\\Users\\hoge&gt;conda install python=3.8\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: E:\\ProgramData\\Anaconda3\\envs\\myenv\n\n  added / updated specs:\n    - python=3.8\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    python-3.8.8               |       hdbf39b2_5        15.8 MB\n    ------------------------------------------------------------\n                                           Total:        15.8 MB\n\nThe following NEW packages will be INSTALLED:\n\n  ca-certificates    pkgs/main/win-64::ca-certificates-2021.4.13-haa95532_1\n  certifi            pkgs/main/win-64::certifi-2020.12.5-py38haa95532_0\n  openssl            pkgs/main/win-64::openssl-1.1.1k-h2bbff1b_0\n  pip                pkgs/main/win-64::pip-21.0.1-py38haa95532_0\n  python             pkgs/main/win-64::python-3.8.8-hdbf39b2_5\n  setuptools         pkgs/main/win-64::setuptools-52.0.0-py38haa95532_0\n  sqlite             pkgs/main/win-64::sqlite-3.35.4-h2bbff1b_0\n  vc                 pkgs/main/win-64::vc-14.2-h21ff451_1\n  vs2015_runtime     pkgs/main/win-64::vs2015_runtime-14.27.29016-h5e58377_2\n  wheel              pkgs/main/noarch::wheel-0.36.2-pyhd3eb1b0_0\n  wincertstore       pkgs/main/win-64::wincertstore-0.2-py38_0\n\n\nProceed ([y]/n)?\nyを入力して続行すると、pythonをインストールできます。(しばらく時間がかかります。)実際にインストールされたかどうか確かめて見ましょう。\n(myenv) C:\\Users\\hoge&gt;conda list\n# packages in environment at E:\\ProgramData\\Anaconda3\\envs\\myenv:\n#\n# Name                    Version                   Build  Channel\nca-certificates           2021.4.13            haa95532_1\ncertifi                   2020.12.5        py38haa95532_0\nopenssl                   1.1.1k               h2bbff1b_0\npip                       21.0.1           py38haa95532_0\npython                    3.8.8                hdbf39b2_5\nsetuptools                52.0.0           py38haa95532_0\nsqlite                    3.35.4               h2bbff1b_0\nvc                        14.2                 h21ff451_1\nvs2015_runtime            14.27.29016          h5e58377_2\nwheel                     0.36.2             pyhd3eb1b0_0\nwincertstore              0.2                      py38_0\n\n(myenv) C:\\Users\\hoge&gt;\nちゃんとPythonがインストールされていることが分かります。REPLを起動してみましょう。\n(myenv) C:\\Users\\hoge&gt;python\nPython 3.8.8 (default, Apr 13 2021, 15:08:03) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\nパッケージをインストールしたいときは、\nconda install package_name\nのように入力します。package_nameはパッケージ名です。パッケージのバージョンまで指定したいときは、\nconda install package_name=ver_num\nとします。ver_numはバージョン番号です。\nたとえば、次のようにすればデータ解析パッケージのpandasをインストールできます。注)myenv環境に、Rのバージョン3.6やCのコンパイラ、アセンブラ等を入れておいてください。やり方はFAQを参照。\nconda install pandas\nmyenv環境を停止してbaseに戻る時は、\nconda deactivate\nと入力します。\n最後にcondaコマンドをまとめておきましょう。\n\n\n\n\n\n\n\nコマンド\n動作\n\n\n\n\nconda --help\ncondaコマンドのヘルプを表示\n\n\nconda command --help\nコマンドcommandのヘルプを表示\n\n\nconda config --show\n全てのパラメータを表示\n\n\nconda config --show par\nパラメータparの設定を表示\n\n\nconda config --set par value\nパラメータparの値をvalueに設定\n\n\nconda config --remove-key par\nパラメータparの設定を消去\n\n\nconda info --envs\n全ての仮想環境を表示\n\n\nconda info -e\n同上\n\n\nconda env list\n同上\n\n\nconda create -n env_name\n仮想環境env_nameを作成\n\n\nconda list\n現環境のインストール済みパッケージをリストアップ\n\n\nconda install package\nパッケージpackageを現在環境にインストール\n\n\nconda install package=ver\nパッケージpackageのバージョンverを現環境にインストール\n\n\nconda remove package\nパッケージpackageを現環境からアンインストール\n\n\nconda remove -n env_name --all\n仮想環境env_nameを削除"
  },
  {
    "objectID": "programming2025/programming-2.html#vs-codeで特定の仮想環境を使う",
    "href": "programming2025/programming-2.html#vs-codeで特定の仮想環境を使う",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "新しく作成した仮想環境myenvをVS Codeで呼び出すためには、その仮想環境にipykernelパッケージをインストールする必要があります。また、コード補完を行うためには、pyreadlineのインストールも必要です。\nconda activate myenv\nconda install ipykernel\n次にVS Codeを起動し、my_first_code.pyを開きましょう。この状態でCtrl-Shift-Pをたたいてコマンドパレットを呼び出し、selectと入力します。幾つか候補が出てきますが、その中からPython: Select Interpreterを選びます。すると、仮想環境のリストが表示されるので、正しい仮想環境を選びましょう。myenvがリストにない場合は、パレットにmyenvと入力するとリストに現れます。\n新環境myenvを選ぶと、VS Codeの画面下にある青い帯のところに、‘myenv’:condaと表示されます。\n\n\n\nmyenv\n\n\nこれで、インターラクティブモードで実行したPythonコードはすべて仮想環境myenvにインストールしたインタープリタによって実行されます。\n仮想環境をbaseに戻したいときは、同じようにコマンドパレットからbaseを呼び出しましょう。"
  },
  {
    "objectID": "programming2025/programming-2.html#まとめ",
    "href": "programming2025/programming-2.html#まとめ",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "今回の講義では、次の点について学びました。\n\nVS Codeの設定\nVS Codeのインタラクティブモード\nEmacsキーバインド\nマークダウン記法\nAnacondaの設定\n仮想環境の構築\n\nエディターを使いこなすことはプログラミングの習得において大変重要です。VS Codeを自分のパソコンや研究室のパソコンにインストールし、Pythonコードやマークダウン文書の作成を通してEmacsキーバインドに慣れるようにしましょう。"
  },
  {
    "objectID": "programming2025/programming-2.html#参考書",
    "href": "programming2025/programming-2.html#参考書",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "『Markdownライティング入門』(藤原 惟)(2018) インプレスR&D. ISBN-13:978-4844398363."
  },
  {
    "objectID": "programming2025/programming-2.html#補足事項",
    "href": "programming2025/programming-2.html#補足事項",
    "title": "第2回 VS Code/仮想環境入門",
    "section": "",
    "text": "これはVS Codeのパスを環境変数PATHに追加することで解決します。VS Codeのショートカットを右クリックして、プロパティを選択し、「リンク先」に書いてあるパスをユーザー環境変数のPATHに追加します(システム環境変数ではありません)。実行ファイル名”Code.exe”はパスに含めないでください。これによってGitからも起動できるようになります。\n\n\n\nVS CodeのPythonスクリプト上で右上の実行ボタン(緑色の矢印)を押すと\n\nconda : 用語 ‘conda’ は、コマンドレット、関数、スクリプト ファイル、または操作可能なプログラムの名前として認 識されません。名前が正しく記述されていることを確認し、・・・\n\nというエラーが出ることがあります。これはcondaコマンドのあるディレクトリにパスを通すことで解決します。\nAnaconda Promptで、\nwhere conda\nと入力してcondaコマンドのパスを調べてください。そのパスを、windowsの環境変数PATHに加えれば解決します。複数出た場合は全部加えてください。\n\n\n\nREPLで日本語文字を使うと、それ以降\n\nUnicodeDecodeError: ‘cp932’ codec can’t decode byte 0x82 in position 96: illegal multibyte sequence\n\nというエラーが出るようになることがあります。これは大した問題ではありません。Anaconda Promptを起動したときのディレクトリにある.python_historyというファイルを削除すれば解決します。見つからない場合は、Windowsの設定で隠しファイルを表示しないモードになっているか、もしくは別のディレクトリに同ファイルがある可能性があります。Anaconda Promptで\necho %HOME%\nと叩いて表示されるディレクトリを探してみてください。Windowsで隠しファイル(ピリオドからはじまるファイル名)を表示しないモードになっていると見つからないのでご注意ください。\n\n\n\nmyenv環境をactivateしてから、次を実行します(以下のコマンドは、VSCode上で対話的にpythonを実行するためのパッケージipykernelも同時にインストールします)。\nconda install python=3.8 ipykernel\n\n\n\nmyenv環境をactivateしてから、次を実行します(以下のコマンドはrtools、cpp11、pryrも同時にインストールします)。\nconda install -c conda-forge r-base=3.6 rtools r-cpp11 r-pryr\nRがインストールできましたら、Rと入力して起動してください。\n\n\n\nmyenv環境をactivateしてから、次を実行します(以下のコマンドはcpp11、pryrも同時にインストールします)。Macではrtoolsは必要ありませんのでインストール不要です。MacではRのバージョン3.6が公開されていないように見受けられますので、とりあえずバージョン4.1で代用してください。\nconda install -c conda-forge r-base=4.1 r-cpp11 r-pryr\nRがインストールできましたら、Rと入力して起動してください。\n\n\n\nVS Codeの3つの設定項目\n\nR: Rterm\nR: Rpath\nR: Interpreter Path\n\nを設定します。\nmyenv環境でRをインストールしたら、RがインストールされているPathを調べてください。Anaconda Promptでmyenvを起動し、次のように入力すると表示されます。\nwhere R\nMacの場合はwhich Rになります。このPathを、上記の3つの設定項目すべてにコピーしてください。設定項目はCtrl-,で検索できます。\n\n\n\n次のようにして自身のAnaconda仮想環境にGNU Cコンパイラ、NASMアセンブラ、makeコマンドをインストールできます。なお、Cコンパイラをインストールする環境は、Rをインストールする環境とは別に(たとえばenvCという名前で)作成することをおすすめします。\nenvC環境にこれらをインストールする場合は、envCをactivateしてから、次のように入力します。\nconda install m2w64-gcc\nconda install -c anaconda nasm\nconda install -c conda-forge make"
  },
  {
    "objectID": "programming2025/programming-5.html",
    "href": "programming2025/programming-5.html",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "第5回 データ型と制御構文\n\nリストのしくみ\nリスト要素の修正\n再帰的リスト\nリストのコピー\n要素の参照をウォッチする\n\n練習1(シャローコピーその1)\n練習2(シャローコピーその2)\n\nディープコピー\n\n練習3(ディープコピー)\n\nスライス記法\nリストの変形と演算\nループ処理\n\n練習4(ループ処理その1)\n\nrangeオブジェクト\n\n練習5(ループ処理その2)\n\nリストの占有メモリサイズ\n条件分岐\nブレークポイントの編集\nより望ましいコーディング\n字下げの注意\nその他の制御構文\n\nwhileループ\n二重ループ\nbreak文\nfor-else文\nelif型条件分岐\n\n論理演算子\n\nand\nor\nnot\n練習6(not inを使わない方法)\n\nまとめ\n参考書\n補遺\n\nsys.getsizeofと__sizeof__\nリストのメモリ利用に関する注釈\n\n\n\n\n\n今回の講義では、Pythonのデータ型の代表格であるリストをじっくりと研究してみましょう。リストを研究することで、Pythonのデータ構造の特徴がより一層深く理解できるようになります。また、リストを研究していく過程で、ループ処理や条件分岐といった制御構文について学んでいきましょう。\nまず、次のように長さ5のリストを作成してxに代入すると何が起きるか考えてみましょう。\nx = [120,-3,'Py','thon','foo']\n筆者の環境で上記を実行すると、Pythonは、リストオブジェクトを保存するための96バイトのメモリ領域を確保して、それにxという名前をつけます。この96バイトのメモリ領域がリストオブジェクトの正体です(具体的なバイト数は処理系やPythonのバージョンにより異なります)。\nオブジェクトが占有するメモリ領域のサイズは、sysモジュールのgetsizeof関数によって調べることができます。ここでモジュールについて簡単に説明しておきます。モジュールというのは、通常Pythonの関数や特殊な変数を定義したファイルです。たとえば、module_nameという名前のモジュールで定義されたfunction_nameという関数を用いる場合は、次のように記述します。\n# %%\nimport module_name  #　モジュール読み込み\nmodule_name.function_name()   # 関数呼び出し\nあるいは、関数function_nameだけを読み込みたい場合は、次のようなfrom ... import文を用いることができます。\n# %%\nfrom module_name import function_name\nfunction_name()\nこのようにして読み込んだ場合、モジュール名module_name.を頭に付けることなく関数function_nameを呼び出すことができるようになりますが、モジュールmodule_name内のそれ以外の関数は呼び出せません。モジュールについては、後の講義で詳しく取り上げます。\nさてsysモジュールは、ビルトインモジュールという特殊なモジュールであり、ファイルとしては存在しておらず、Pythonインタープリタに埋め込まれ(built-in)ています。sysの関数群を用いると、Pythonの非常に基本的な機能にアクセスすることができます。ここでは、getsizeofという、引数に与えたオブジェクトの占有メモリサイズをバイト単位で返してくれる関数を使いましょう。\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getsizeof([120,-3,'Py','thon','foo'])\n96\n96バイトのうち56バイトには、参照カウンタやら何やらが保存されており、からっぽのリストにすら存在する領域で、オーバーヘッドと呼ばれることもあります。オーバーヘッドの具体的なサイズはPythonのバージョンや環境によって若干異なりますので、各自調べてみましょう(getsizeofの注釈参照)。\nオーバーヘッドの容量は空のリストのサイズを調べることにより確かめられます。\n&gt;&gt;&gt; sys.getsizeof([])\n56\nメモリの効率的利用について研究しているのでないかぎり、オーバーヘッドの機能を意識することはあまり重要ではありません。重要なのは残り40バイトの配列と呼ばれる部分です。\n\n\n\nlist structure\n\n\nこの合計40バイトの配列はメモリ上で一続きになっており、各8バイトの5つの区画に分かれています。それぞれの区画には、リストの要素になっているオブジェクトのアドレスが格納されています。(第1回の講義で学んだように、64ビット処理系ではメモリアドレスを8バイト数値で表すことに注意しましょう。リストのメモリ利用に関する注釈参照。)\nたとえば第1要素である120という整数オブジェクトは、メモリ上の9604番地に存在します（実際にはアドレスはもっと大きな整数ですが、面倒なので下4桁だけ使っています）が、それに対応して、リストオブジェクトの配列の第1番目の区画には、オブジェクト120のアドレスである9604が書き込んであります。他の要素についても同じで、配列の第k番目の区画には、リストの第k番目の要素であるオブジェクトのアドレスが格納されています。\nこのように、リストオブジェクトは、その要素そのものを直に格納しているのではなく、要素オブジェクトのアドレスを格納しています。このおかげで、リストオブジェクトには、整数、小数、文字列などの様々なデータ型のPythonオブジェクトを好きな順番で詰め込めるようになっています。なぜなら、どんなオブジェクトでも、アドレスは8バイトの数値だからです。\nリストが要素オブジェクトそのものを含んでいないことは、getsizeofを使っても間接的に確かめることができます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = [1,2,[3,4,5,6]]\n&gt;&gt;&gt; z = [1,2,[3,4,5,6,7,8,9,10]]\n&gt;&gt;&gt; sys.getsizeof(x)\n80\n&gt;&gt;&gt; sys.getsizeof(y)\n80\n&gt;&gt;&gt; sys.getsizeof(z)\n80\n上のコードでは、x、y、zが含んでいる要素の数はすべて異なるように見えますが、実際にはどのリストもオブジェクト三つ分の参照しかもっていないので、占有するメモリの大きさは同じになっています。もしリストが要素オブジェクトそのものを含んでいるとしたら、メモリの占有サイズは\nx &lt; y &lt; z\nとなることが期待されますが、そうはなっていません。\nなお、上記の性質は、リストだけでなく、より広いコンテナというクラスのデータ型の多くに当てはまる性質です。これから論じることは、多くが他のコンテナ型のデータ型に当てはまります。コンテナ型については教科書のセクション6に詳しいので、良く読んでおいてください。\nたとえば\n&gt;&gt;&gt; x = [120,-3,'Py','thon','foo']\n&gt;&gt;&gt; x[1]\n-3\n&gt;&gt;&gt; \nのように入力するときPythonは、xというリストオブジェクトの中にある配列領域のインデックス1の要素に書いてあるアドレスをチェックして、次にそのアドレスに行ってどんなオブジェクトがあるのかチェックします。するとそこには-3という整数オブジェクトがあったので、それを出力してくれています。\n\n\n\nでは次に、リストの要素の書き換えについて考えてみます。たとえば第2インデックス要素を’Py’から’bar’に書き換えたいとします。この場合、次のように書きます。\nx[2] = 'bar'\nするとPythonは何をするかというと、’bar’という文字列オブジェクトをメモリ上に作成して、そのアドレス0800をリストxの配列の第2インデックス要素に上書きで格納します。これによって、オブジェクト’Py’はリストxからは忘れ去られ、代わりに'bar'がリストのメンバーとして参入します。\n\n\n\nlist change element\n\n\nここで重要なのは、もともと'Py'が存在していた5782番地の内容が書き換えられるわけではないということです。そうではなく、単にリストxが覚えているアドレスが付け替えられるだけです。\nこのように、x[2]という表記は、第3要素オブジェクトへの参照として機能します。言い変えると、x[2]='bar'という代入は、ハコ型代入ではなくラベル型代入になっているということです。Pythonリストは、要素オブジェクトへの参照を格納していると考えることができ、通常Pythonのコミュニティーはそのような表現を好んで使います。\n\n\n\nPythonリストが格納しているのは要素オブジェクトそのものではなく要素オブジェクトへの参照であることから、リストは自分自身を要素にもつという奇妙なことができてしまいます。次のようにしてみましょう。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x[2] = x\n&gt;&gt;&gt; x\n[1, 2, [...]]\nここでは、リストxを作成したあと、その第3要素に自分自身を代入しています。これにより、xの内部にある配列の最後の要素には、x自身の参照が格納されることになります。最後の[...]という表現は、仮に自分自身をここに表示すると無限に入れ子になったリストを表示することになってしまうので、それを避けるために導入された略記表現です。\nこうした自分自身への参照を要素にもつ再帰的リストを積極的に作るべき場面はすこし思いつきませんが、似たような状況はPythonプログラミングにおいて容易に生じ得ます。それは、複数のリストオブジェクトが互いに相手への参照を要素にもつ以下のような場合です。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = [4,5,6]\n&gt;&gt;&gt; x[2] = y\n&gt;&gt;&gt; x\n[1, 2, [4, 5, 6]]\n&gt;&gt;&gt; y[2] = x\n&gt;&gt;&gt; x\n[1, 2, [4, 5, [...]]]\n&gt;&gt;&gt; y\n[4, 5, [1, 2, [...]]]\n詳しくは解説しませんが、このような循環参照はガベージコレクションというメモリ管理において重要なトピックとなります。興味がある人はインターネット等で調べてみてください。\n\n\n\nPythonにはRのCopy on modifyがないため、リストの複製を作るためには、明示的にプログラマが複製操作を行う必要があります。\nPythonでは、それぞれのデータ型は、それを操作するための専用の一連の関数をもっています。このような関数群を、そのデータ型のメソッドと呼びます。(メソッドについては、後の講義で詳しく解説します。)\nたとえば、リスト型がどのようなメソッドを持つかを調べたいときは、REPLにおいてlist.と入力してタブキーを叩くと一覧が表示されます(もし1回で駄目なら2回叩いてください)。\n&gt;&gt;&gt; list.\nlist.append(  list.copy(    list.extend(  list.insert(  list.pop(     list.reverse(\nlist.clear(   list.count(   list.index(   list.mro(     list.remove(  list.sort(\nもしくはVS Code上でlist.と入力してしばらく待つと、メソッド一覧が表示されます(ただし少なくともpyreadlineモジュールがインストールされている必要がありますし、もしかしたらインテリセンスという拡張機能も必要かもしれません)。\n上記のリストのメソッド一覧の中に、copyという自身の複製を作成するメソッドが有ります。これを呼び出すには、次のようにします。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x.copy()    # xの複製を作ってyに代入\n&gt;&gt;&gt; x\n[1, 2, 3]\n&gt;&gt;&gt; y\n[1, 2, 3]\n&gt;&gt;&gt; x is y    # xとyは異なるオブジェクト\nFalse\n&gt;&gt;&gt; id(x)\n2510581312768\n&gt;&gt;&gt; id(y)\n2510581325056\n確かに、xのコピーが作成され、yに代入されています。xとyは異なるアドレスを指しており、異なるオブジェクトを参照していることが分かります。\n注意しなくてはならないのは、copyメソッドを呼び出すと、実際にコピーされるのは、要素オブジェクトへの参照であって、要素オブジェクト自体はコピーされないということです。参照がコピーされるということは、アドレスがコピーされるということです。xとyは、それ自体はメモリの違う場所にありながら、全く同じ要素オブジェクトを参照していることになります。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x.copy()\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[0] is y[0]    # 第1要素を共有\nTrue\n&gt;&gt;&gt; x[1] is y[1]    # 第2要素を共有\nTrue\n&gt;&gt;&gt; x[2] is y[2]    # 第3要素を共有\nTrue\nこうした性質をもったコピーをpythonではシャローコピー(shallow copy)と呼びます。シャローコピーは、要素がイミュータブルな場合には全く問題になりません。シャローコピーが問題になるのは、リストがミュータブルな要素を持つときです。\nたとえば次の例を考えてみましょう。ここでは、zというリストを作成したうえで、リストxの第2要素にzへの参照を持たせています。さらにxのコピーを作ってyに代入すると、xとyは異なるオブジェクトとなりましたが、当然第2要素のzを共有したままです。従って、x[2]の要素を変更すると、yにまで影響が及びます。\n&gt;&gt;&gt; z = [1,2,3]\n&gt;&gt;&gt; x = [120,-3,z,'thon','foo']\n&gt;&gt;&gt; y = x.copy()\n&gt;&gt;&gt; x\n[120, -3, [1, 2, 3], 'thon', 'foo']\n&gt;&gt;&gt; y\n[120, -3, [1, 2, 3], 'thon', 'foo']\n&gt;&gt;&gt; x is y  # xとyは異なるオブジェクト\nFalse\n&gt;&gt;&gt; x[2] is y[2]  # だがzオブジェクトを共有\nTrue\n&gt;&gt;&gt; x[2][1] = 5   # x経由でzに修正を加える\n&gt;&gt;&gt; x\n[120, -3, [1, 5, 3], 'thon', 'foo']\n&gt;&gt;&gt; y             # yも変わってしまった\n[120, -3, [1, 5, 3], 'thon', 'foo']\nこれは図に書くと何が起きているのか分かりやすいでしょう。\n\n\n\nlist_shallow_copy\n\n\n\n\n\n上の例が示すように、リストの各要素がメモリのどこを参照しているのかを逐一把握するのは大変です。\nそこで、ここでは、リストの各要素のアドレス(id関数の出力)の下位2バイトを出力する関数を定義しておきます。\ndef sid(obj):\n    return hex(id(obj)&0xffff)\n\ndef lid(obj):\n    if type(obj) is list:\n        return [sid(el) for el in obj]\n    else:\n        return sid(obj)\nsidは、オブジェクトのアドレスの下位2バイトを返します。一方lidは、リストが引数に与えられたとき、要素の参照を要素として持つリストを返します。リスト以外を引数に与えたときはsidの戻り値を返します。\n\n\n上記のコードを実行する際にリアルタイムで何が起きているのかをデバッグモードで確かめることにします。GitHub/varsディレクトリの下に適当なファイル(たとえば”shallow.py”)を作成し、上のsid、lidのコードをコピー＆ペーストした上で、その下に次のコードを記述しなさい。\nz = [1,2,3]\nx = [120,-3,z,'thon','foo']\ny = x.copy()\nx[2][1] = 5   # x経由でzに修正を加える\npass\n次の8式をウォッチ式に設定しなさい。\n\nsid(x)\nsid(y)\nx is y\nlid(x)\nlid(y)\nx[2] is y[2]\nlid(x[2])\nlid(y[2])\n\nデバッグを実行し、ステップインによってウォッチ式と各変数の値がどのように変化するか観察しなさい。\n\n\n\n次の2つのコードについて、xの変更(ともに3行目)はyに影響を及ぼすか?結果を予想してからデバッグモードで確かめなさい。\n# コード1\nx = [1,[4,5,6],3]\ny = x.copy()\nx[1] = [7,8,9]\npass\n# コード2\nx = [1,[4,5,6],3]\ny = x.copy()\nx[1][:] = [7,8,9]\npass\nただし、以下のウォッチ式を設定すること。\n\nsid(x)\nsid(y)\nx is y\nlid(x)\nlid(y)\nx[1] is y[1]\nlid(x[1])\nlid(y[1])\n\n\n\n\n\nこのようにシャローコピーは、意図せぬ挙動を引き起こす可能性がありますので、それを避けたい場合はディープコピーという操作を行います。ディープコピーをすると、参照だけでなく要素オブジェクトも再帰的にコピーされます。ディープコピーは、copyモジュールによって提供されるdeepcopy関数で行うことができます。\n&gt;&gt;&gt; import copy\n&gt;&gt;&gt; x = [1,[4,5,6],3]\n&gt;&gt;&gt; y = copy.deepcopy(x)\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[1] is y[1]\nFalse\nただし、次のコードで分かるように、何もかもコピーされてしまうわけではありません。“末端”のイミュータブルオブジェクトなど、オリジナルと複製で共有しても問題が起きないような場合は、複製を行いません。\n&gt;&gt;&gt; x = [1000,[4000,5000,6000],3000]\n&gt;&gt;&gt; y = copy.deepcopy(x)\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[1] is y[1]\nFalse\n&gt;&gt;&gt; x[0] is y[0]\nTrue\n&gt;&gt;&gt; x[1][0] is y[1][0]\nTrue\n従って、特に入れ子の構造がないオブジェクトでは、シャローコピーとディープコピーの動作は全く同じです。\n\n\n次のコードをデバッグモードで実行し、単なる代入、シャローコピー、ディープコピーの違いを観察しなさい。\nimport copy\nx = [1,2,[3,4,[5,6]]]\ny = x\ny = x.copy()\ny = copy.deepcopy(x)\npass\nただしウォッチ式は以下とすること。\n\nsid(x)\nsid(y)\nx is y\nlid(x)\nlid(y)\nx[2] is y[2]\nlid(x[2])\nlid(y[2])\nx[2][2] is y[2][2]\nlid(x[2][2])\nlid(y[2][2])\n\n\n\n\n\nシャローコピーはスライス記法によっても行うことができます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x[:]\n&gt;&gt;&gt; x is y\nFalse\nこのように、スライス記法は通常はシャローコピーとなりますが、代入の左辺で使うときは意味合いが異なりますので注意が必要です。前回の講義でも論じたように、左辺で使うと、コピーを作るのではなく、オリジナルのリストオブジェクトを変更することになります。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x[:] = [4,5,6]\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y\n[4, 5, 6]\n&gt;&gt;&gt; x is y\nTrue\nこのように、代入の左辺で使うスライス記法とそれ以外のスライスは分けて考えた方が良いでしょう。なお、これはスライス記法だけでなく、x[0]と言ったような、単一要素のインデクシングでも同じことが言えます。\nちなみに、スライス記法は、リストの1部分のシャローコピーを作るのにも使えます。下では、xの第1インデックス～第3インデックス要素のコピーをyに代入しています。\n&gt;&gt;&gt; x = [1000,2000,3000,4000,5000]\n&gt;&gt;&gt; y = x[1:4]      # スライスによるコピー\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[1] is y[0]\nTrue\n&gt;&gt;&gt; x[2] is y[1]\nTrue\n&gt;&gt;&gt; x[3] is y[2]\nTrue\nここで、x[1:4]という表現は、xの第1インデックス要素から第3インデックス要素までを取り出す表現ですが、これはなれないと分かりにくいかと思います。まず基本的な事項として、リストのインデックスは0からはじまることに注意しましょう。たとえば上の場合ですと、インデックスと要素オブジェクトの対応は次のようになります。\n\n\n\nインデックス\n0\n1\n2\n3\n4\n\n\n\n\n要素オブジェクト\n1000\n2000\n3000\n4000\n5000\n\n\nx[1:4]\n\n始点\n–&gt;\n終点\n\n\n\nx[0:3]\n始点\n–&gt;\n終点\n\n\n\n\nx[:2]\n始点\n終点\n\n\n\n\n\nx[2:]\n\n\n始点\n–&gt;\n終点\n\n\n\nx[i:j]という表現では、インデックスiからj-1の位置までスライスすることになります。上の表には幾つかの例を挙げておきました。リストの先頭要素が始点の場合、始点を指定するインデックス0は省略できます。同様に、リストの末尾要素が終点の場合、終点を指定するインデックス(この場合5)は省略することができます。\nさて部分的なスライスを代入の左辺で使うと、やはりオブジェクト本体の変更になります。なお、左辺のスライスの長さと右辺のリストの長さは違っても構いません。\n&gt;&gt;&gt; x = [1,2,3,4,5]\n&gt;&gt;&gt; x[1:4] = ['foo','bar']\n&gt;&gt;&gt; x\n[1, 'foo', 'bar', 5]\n&gt;&gt;&gt; x = [1,2,3,4,5]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x[1:5] = ['foo','bar']\n&gt;&gt;&gt; x\n[1, 'foo', 'bar']\n&gt;&gt;&gt; y\n[1, 'foo', 'bar']\n&gt;&gt;&gt; x is y\nTrue\n\n\n\nリストは様々なメソッドを搭載しており、要素の編集を行うことができます。たとえばappendメソッドは、リストの末尾に要素を追加します。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x.append(4)\n&gt;&gt;&gt; x\n[1, 2, 3, 4]\nここでは、xの末尾に4という値を付け足しています。\nその逆に、popメソッドはリストから要素を取り出すことができます。\n&gt;&gt;&gt; x = [1,2,3,4,5]\n&gt;&gt;&gt; y = x.pop()         # 末尾から取り出す\n&gt;&gt;&gt; x\n[1, 2, 3, 4]\n&gt;&gt;&gt; y\n5\n&gt;&gt;&gt; y = x.pop(1)    # インデックス1から取り出す\n&gt;&gt;&gt; x\n[1, 3, 4]\n&gt;&gt;&gt; y\n2\nそのほか、+演算子を用いて複数のリストを結合することが可能です。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x + [4,5,6]\n&gt;&gt;&gt; y\n[1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; x\n[1, 2, 3]\nただし、この場合はappendメソッドと違って、もとのオブジェクトx自体は変更されていないことに注意してください。\nリストを*演算子で掛け算することもできます。\n&gt;&gt;&gt; x = [1]*10\n&gt;&gt;&gt; x\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nただし、*演算子は対象リストをシャローコピーして繋げるだけであることに注意しなくてはなりません(教科書のp.212参照)。つまり、次のようなことが起きます。\n&gt;&gt;&gt; x = [[1,2]]*5\n&gt;&gt;&gt; x\n[[1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]\n&gt;&gt;&gt; x[0][1] = 5   # 第1の要素だけ変更したつもり\n&gt;&gt;&gt; x   # だが全ての要素が変わってしまった\n[[1, 5], [1, 5], [1, 5], [1, 5], [1, 5]]\nリストについてはこれ以上の説明は省略しますが、教科書のセクション6.1に様々な操作が載っていますので、よく読んでおいてください。\n\n\n\nそれではここで、リストオブジェクトが占有するメモリのサイズが、要素の数とともにどのように増加していくか調べてみましょう。理論的予測に基づけば、1つの要素オブジェクトあたり、オブジェクトの参照を格納するのに8バイト使います。従って、要素の数をnとすれば、リストの占有メモリサイズは(オーバーヘッド容量)+8nとなるはずです。\nこの実験を行うために、繰り返しのための制御構文であるforループを使ってみましょう。皆さんはRのforループをすでにご存じだと思います。次のような構文でしたね。\n# 1:10はベクトルc(1,2,3,4,5,6,7,8,9,10)と同じ意味\n\nfor (i in 1:10) {\n  print(i)  #forブロック\n}\nprint('End')\n上記のコードは、1から10までの整数を画面に出力したあと、最後に’End’と出力するRコードです。中括弧の中身はforブロックと呼ばれ、ここに記述された内容が繰り返されます。iはループカウンタと呼ばれる変数で、ループが1回実行されるごとに1ずつ増加していきます。iの初期値と最終的な値はinの後に記述されたベクトル1:10が決定します。この場合は、初期値がi=1、最後のループではi=10となります。\nPythonのforループもよく似ているので、Rのforを知っている皆さんならば即座に理解できます。\n# ループはi=0からi=3まで繰り返して欲しい\nindex_range = [0,1,2,3]\n\nfor i in index_range:\n    print(i)        # \n    print('FOO')    # ここは\n    print('BAR')    # 全部\n    print('BAZ')    # forブロック\n    print('')       #\n\nprint('End')\n上記のPythonコードは0から3までの整数を画面に印字します(ついでに’FOO’、‘BAR’、’BAZ’も印字します)。\nRとの違いをまとめると、次のようになります。\n\nforブロックが中括弧ではなくインデント(字下げ)によって表現される。\n先頭行の行末にコロン(:)が必要。\nforのあとの丸カッコは必要ない。\n\nなかでも重要なのは1です。print(i)やprint('FOO')のまえにタブキー1つ分の字下げが入っていることに注意してください。これによって、print(i)やprint('FOO')はforブロックの中の要素であるとPythonインタープリタによって解釈されます。一方、print('End')は字下げしていないので、ブロックの外にあると見なされ、繰り返されることはありません。\nそれでは上記のコードをVS Codeのインターラクティブモードで実行してみてください。\n0\nFOO\nBAR\nBAZ\n\n1\nFOO\nBAR\nBAZ\n\n2\nFOO\nBAR\nBAZ\n\n3\nFOO\nBAR\nBAZ\n\nEnd\n\n\n上記のコードの最初の行をブレークポイントに設定して、デバッグモードで起動してください。ステップインを繰り返し、どのようにiの値が変化していくか、どういう順番でコードが実行されていくかをよく観察してください。\nforループについては、教科書のセクション4.2.3に詳しく解説されていますので、良く読んでおいてください。\n\n\n\n\nPythonにはRのように1:10といった連続整数値のベクトルを表す簡便な表記がありません。Pythonでは代わりに、もっと性能の良いrangeオブジェクトという特殊なオブジェクトを用います。\nrangeオブジェクトは、リストではありませんが、forループにおいて連続する数値のリストと同じ働きをするオブジェクトです(こういったオブジェクトをイテラブルと言います)。rangeオブジェクトを用いると、先のコードは次のようになります。\n# %%\n# range(4)は[0,1,2,3]と同じように機能する\n\nfor i in range(4):    # rangeオブジェクトを使った\n    print(i)        \n    print('FOO')    \n    print('BAR')    \n    print('BAZ')    \n    print('')       \n\nprint('End')\n上のコードにおいて、rangeはrangeオブジェクトを生成する関数であり、range(4)は0から3までの連続する整数のリストと全く同じように機能します。一般に、0からnまでの連続する整数を表したいときはrange(n+1)と書きます。\nrangeオブジェクトから、リストを作成することも可能です。そのためには、次のように関数listを使います。\n&gt;&gt;&gt; x = list(range(4))\n&gt;&gt;&gt; x\n[0, 1, 2, 3]\nrange関数については、教科書のセクション4.2.4に詳しく解説されていますので、良く読んでおいてください。\n\n\n次のように、0から9までの全ての整数について、2乗した値を出力するプログラムrange関数を使って書きなさい。\n# 結果\n\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n\n\n\n\nそれでは、forループを使ってリストのサイズと占有メモリサイズの関係を調べましょう。以下のプログラムはリストのサイズを0(空っぽ)から50まで変化させたときに、リストの占有メモリサイズがどのように変化するかを調べるためのものです。\n# リストのサイズが0から50まで変化するとき\n# メモリの占有サイズはどう変化するか?\n\nimport sys\n\nfor i in range(51):\n    temp_l = list(range(i))             # リストを作成\n    s_temp_l = sys.getsizeof(temp_l)    # サイズ計算\n    print(s_temp_l,end=' --&gt; ')         # 結果の出力\nforブロックの中を1行ずつ見ていきましょう。\nまず1行目ですが、\ntemp_l = list(range(i))\nこれは、0で始まりi-1で終わるリスト[0,1,2,3,...,i-1]を作成してtemp_lという変数に代入しています。iはループインデックスですので、k回目のループでは、長さkのリストが作成されることに注意しましょう。よってforブロックが1回実行されるごとに、作成されるリストの長さは要素1個ぶん長くなります。\nちなみに、最初のループではi=0です。したがって最初のループでは\ntemp_l = list(range(0))\nを実行していることになりますが、これは空のリストを作成することに注意してください。\n2行目は、\ns_temp_l = sys.getsizeof(temp_l)\nですが、これは先ほど作成したtemp_lのサイズを計算してs_temp_lという変数に代入しています。最後に、\nprint(s_temp_l,end=' --&gt; ')\nですが、これは上記で計算したメモリサイズs_temp_lを出力しています。print関数は、デフォルトで改行するようになっていますが、オプション引数endによって改行以外の文字を出力することができます。ここでは、サイズを出力したあとに、’ –&gt; ’という文字列を出力しています。\nそれでは、VS Codeで上記のコードを実行してみましょう。\n56 --&gt; 64 --&gt; 72 --&gt; 80 --&gt; 88 --&gt; 96 --&gt; 104 --&gt; 112 --&gt; 120 --&gt; 128 --&gt; 136 --&gt; 144 --&gt; 152 --&gt; 160 --&gt; 168 --&gt; 176 --&gt; 184 --&gt; 192 --&gt; 200 --&gt; 208 --&gt; 216 --&gt; 224 --&gt; 232 --&gt; 240 --&gt; 248 --&gt; 256 --&gt; 264 --&gt; 272 --&gt; 280 --&gt; 288 --&gt; 296 --&gt; 304 --&gt; 312 --&gt; 320 --&gt; 328 --&gt; 336 --&gt; 344 --&gt; 352 --&gt; 360 --&gt; 368 --&gt; 376 --&gt; 384 --&gt; 392 --&gt; 400 --&gt; 408 --&gt; 416 --&gt; 424 --&gt; 432 --&gt; 440 --&gt; 448 --&gt; 456 --&gt; \nたしかに、オーバーヘッド容量からはじまって、リストの長さが1増加するごとにメモリサイズが8バイト増加していることが分かります。\n\n\n\nところで、上記の”実験”プログラムは、出力が’–&gt;’記号で終わっていて美しくありません。この最後の矢印を消す方法を考えてみましょう。\nforブロックの最後の文で、print関数を用いていますが、そのオプション引数endを、forブロックが最後に実行される時以外は’ –&gt; ’に設定し、最後の実行のときだけは改行に設定すれば良さそうです。\nこれを言葉で書くと次のようになるでしょう。\nもし i &lt; 50 ならば、end_str = ' --&gt; '\nさもなくば、end_str = 改行文字\nただしend_strはprint関数のend引数に与える文字列です。\nところで、Rでの条件分岐を覚えているでしょうか?代表的な条件分岐の構文であるif-else文を思い出してみましょう。\nif (i &lt; 50) {\n  end_str &lt;- ' --&gt; '   # ifブロック\n} else {\n  end_str &lt;- '\\n'      # elseブロック\n}\n上記のコードで、’’は様々なプログラミング言語で改行文字を表す記号です。このようなバックスラッシュを使ってあらわされる特殊文字をエスケープシーケンスと呼びます。エスケープシーケンスについては、教科書のセクション2.2.7に詳しく説明されているので、良く読んでおいてください。\nさて、ifの後の中括弧に挟まれたコード領域はifブロックと呼ばれ、丸カッコの中の条件がTRUEの場合のみ実行されます。一方elseの後の中括弧に挟まれたコード領域はelseブロックと呼ばれ、条件がFALSEの場合のみ実行されます。従って、上記Rコードは、\nもし i &lt; 50 ならば、end_str = ' --&gt; '\nさもなくば、end_str = '\\n'\nとなり、意図した通りのコードになっています。\n全く同じことをPythonで書くと、次のようになります。\nif i &lt; 50:\n    end_str = ' --&gt; ' # ifブロック\nelse:\n    end_str = '\\n'    # elseブロック\nRでのif-elseと比べると、次の違いがあります。\n\nifブロック、elseブロックが字下げによって表現される\nif行とelse行はコロン(:)で終わる\n条件節を囲む丸カッコは必要ない\n\nここでもやはり1が最も重要です。条件分岐でも、やはりコードブロックは字下げによって表現されます。\nなおRと同様に、else:節は必須ではありません。else:節を省略すると、条件が不成立の場合には何もしません。したがって、たとえば次のように書いても、結果は同じになります。\n# 先にend_strを' --&gt; 'に設定し、\n# 最後のループだけend_str = '\\n'に再設定する\nend_str = ' --&gt; '\n\nif i == 50:\n    end_str = '\\n' # ifブロック\nそれでは条件分岐を用いて、メモリサイズ計算プログラムを改良しましょう。\nimport sys\n\nfor i in range(51):\n    temp_l = list(range(i))\n    s_temp_l = sys.getsizeof(temp_l)\n    if i &lt; 50:\n        end_str = ' --&gt; '\n    else:\n        end_str = '\\n'\n    print(s_temp_l,end=end_str)\nなお、実際にはもっとパフォーマンスの良い書き方はありますが、ここでは条件分岐の説明のために上記のコーディングを採用しました。\n\n\n\nここでは、上記のfor文の中でif-else構文がどのように機能しているのかを見るため、やや高度なブレークポイントを設定してみます。\nforブロックの1行目にブレークポイントを設定してください。ブレークポイントの赤いマークを右クリックし、『ブレークポイントの編集』を選びます。\n\n\n\nconditional_break\n\n\n『式：式がtrueと評価される場合に中断します。』と表示されるので、i==48と入力してEnterしましょう。\n\n\n\nconditional_break\n\n\nこれで、iが48に等しいときにのみストップするブレークポイントになります。(『式』ではなく『ヒットカウント』を選んで49を入力しても効果は同じです。)\nウォッチ式には、i &lt; 50を設定しましょう。\nこれでデバッグを実行すると、forループの49回目でストップしますので、そこからステップインを繰り返し、ウォッチ式i &lt; 50の値に応じて、ifブロックとelseブロックのどちらが実行されるか観察してください。\n\n\n\nところで、上記のコードでは、50や51といった具体的な値がコードのなかに埋め込まれています。これでは、値を変更したくなったときに一々50と51の両方を修正しなくてはなりません。また、もっとプログラムが大きくなると、どこの値を修正すれば良いのか分からなくなりそうです。従って、具体的な数値をソースコードの途中に色々と書き込むのは良くなさそうです。\n具体的な値は、次のように、ソースコードの最初のほうで変数に置き換えてしまうのが望ましいです。ついでに、以下の改良を付け加えてみましょう。\n\n結果が見やすいように5つごとに改行\nオーバーヘッド分を差し引く\n\nimport sys\n\nmax_size = 50   # max_sizeは最大のリスト長\noverhead = sys.getsizeof([]) # オーバーヘッド計算\n\nfor i in range(max_size+1):\n    temp_l = list(range(i))\n    s_temp_l = sys.getsizeof(temp_l)\n    if i &lt; max_size:\n        end_str = ' --&gt; '\n    else:\n        end_str = '\\n'\n    print(s_temp_l-overhead,end=end_str) # オーバーヘッド除去\n    if i%5 == 4:  # 5つごとに改行\n        print()\nこれを実行すると以下のようになります。ずいぶんと結果が分かりやすくなりました。\n0 --&gt; 8 --&gt; 16 --&gt; 24 --&gt; 32 --&gt; \n40 --&gt; 48 --&gt; 56 --&gt; 64 --&gt; 72 --&gt; \n80 --&gt; 88 --&gt; 96 --&gt; 104 --&gt; 112 --&gt; \n120 --&gt; 128 --&gt; 136 --&gt; 144 --&gt; 152 --&gt; \n160 --&gt; 168 --&gt; 176 --&gt; 184 --&gt; 192 --&gt; \n200 --&gt; 208 --&gt; 216 --&gt; 224 --&gt; 232 --&gt; \n240 --&gt; 248 --&gt; 256 --&gt; 264 --&gt; 272 --&gt; \n280 --&gt; 288 --&gt; 296 --&gt; 304 --&gt; 312 --&gt; \n320 --&gt; 328 --&gt; 336 --&gt; 344 --&gt; 352 --&gt; \n360 --&gt; 368 --&gt; 376 --&gt; 384 --&gt; 392 --&gt; \n400\n\n\n\nPythonでは、字下げによってコードブロックを表現するという、他の言語にはない際だった特徴があります。このおかげで、Pythonは非常に見やすいコードを書くことが可能になっています。ただ、インデントの幅を間違えるだけで、全く異なる意味になることがあるので注意が必要です。\nたとえば次のような三つのコードを考えてみましょう。\nfor i in range(10):\n    if i%2 == 0:\n        print(i) \nprint(\"Hello, World!\")  # ブロックの外\nfor i in range(10):\n    if i%2 == 0:\n        print(i) \n    print(\"Hello, World!\") # forブロックの中\nfor i in range(10):\n    if i%2 == 0:\n        print(i) \n        print(\"Hello, World!\")　# ifブロックの中\nこれらのコードは、3行目のインデントが異なるだけでそれ以外は全く同じですが、全て全く異なる挙動をします。3行目の所属するブロックが異なるからです。やっかいなのは、どれもエラーがでないことです。\nこのように、forやifブロックがあると、コーディング中にうっかりタブキーを一つ挿入すると、エラーが出ない上にコードを破壊してしまう可能性があるので、ブロックの字下げには十分に注意しなくてはなりません。特にブロックが入れ子になっている場合はこういった失敗に気づきにくいので注意しましょう。\n\n\n\n\n\nforループは予め繰り返し回数が決まっている場合に便利ですが、繰り返し回数が予め決められない場合もあり、その場合にはwhileループを用います。whileループは指定した条件が成り立っているかぎりwhileブロック内のコードを繰り返し実行しますが、条件が不成立になるとループ処理を終了します。\nforループとの違いを明らかにするため、まず0から5までの整数を印字するプログラムをforループで書いてみましょう。\nfor i in range(6):\n    print(i)\n同じものをwhileループを使って書くと、次のようになります。\ni = 0   # ループカウンタの初期値を0に設定\nwhile i &lt;= 5:\n    print(i)    # iの値を印字\n    i += 1      # iの値を1増やす\n字下げした部分がwhileブロックであり、繰り返される部分です。whileブロック内の最後の行はiの値を1増やすコードであり、i=i+1の省略記法です(教科書のp85-86参照)。上記のコードでは、まずiの値を0に設定し、ループ内ではiの値を印字してから、iの値を一つ増やすことを繰り返しています。したがってiの値はwhileブロックが実行されるたびに1ずつ増えます。whileの後に指定した条件i&lt;=5は、ループ処理が継続されるための条件であり、これが成り立っている限りwhileブロックの処理が繰り返されます。よって、上記のコードでは、iは0,1,2,3,…と増加し、iが6になるとwhileブロックは実行されず、ループは終了します。forループとは違い、whileループではループカウンタの初期値や増加をプログラマがコーディングしなくてはならないことに注意してください。\n次に、10000より小さい3の累乗(3,9,27,…)を全て印字するプログラムをwhileループで書いてみましょう。作戦として、iの初期値に3を設定し、iを印字してからiに3を掛けるということを繰り返し、iが10000以上になったとき繰り返しをやめれば良さそうです。これを実装すると次のようになります。\ni = 3   # iの初期値を3に設定\nwhile i &lt; 10000:\n    print(i)    # iを印字\n    i *= 3      # iに3をかける\ni *= 3は、i = i * 3の略記法です(教科書p85)。このプログラムは、条件i &lt; 10000が成り立っている間のみ、iを印字してからiを3倍する操作を繰り返します。このようなプログラムは、10000未満の3の累乗がいくつあるか予めわからないかぎり、forループで書くのが難しいことに注意してください。\n\n\n\n少し複雑な処理になると、ループの中にループを作る必要が出てきます。これを二重ループと呼びます。ループはいくらでも入れ子にでき、三重ループ、四重ループなどと呼ばれます。良くあるパターンはforループの中にforループがあるタイプですが、whileループの中にforループを作ったり、forループの中にwhileループを作ったりなど、whileとforの組み合わせに制約はありません。\n複雑なコードを書くさい、いきなり二重ループや三重ループのコードを書かないようにしてください。これはデバッグが難しくなりがちだからです。そうではなく、まずは一番内側のループから作成し、それが正しく動作することを確認することから始めてください。内側のループが完成したら、外側にループを付け足して二重ループを作りましょう。この二重ループもうまく動作することが確認できたら、必要に応じて更にループを付け足し、三重、四重と入れ子の階層を深めていくようにしてください。\n上述のように内側から外側に向かってコーディングするとうまく行くことが多いですが、問題によっては、外側のループから内側に向かって作成したほうが作りやすい場合もあります。重要なのは、全体を一気にコーディングするのではなく、シンプルなコードから始めて、動作をテストしながら、徐々に入れ子の階層を深めていくべきだということです。\n一例として、1000より小さい素数を全て印字するプログラムを作ってみましょう。こういう場合、問題が複雑ですので、まずは与えられた一つの数字iが素数かどうか判定するプログラムを作ってみることから初めるべきです。次のコードは、491が素数かどうか調べるプログラムです。素数ならTrueを印字し、素数でないならFalseを印字します。\ni = 491     # iを491に設定\nj = 2\nwhile i % j != 0:\n    j += 1\n\n# iが素数ならTrue, さもなくばFalseを印字\nif i == j:\n    print(True)\nelse:\n    print(False)\nこのコードでは1行目でiに491を代入し、2-4行目において、iを割り切る最小の素因数を求めています。そのような素因数を求めるため、まずjの値を2に設定し、whileループ内でjの値を1ずつ増やしながらiがjで割り切れるかその都度調べています。\nwhileのあとの条件文で使われている!=は、「左辺と右辺の値が異なる」ことを表す二項演算子です。従って、このwhileループは、iがjで割り切れるまで繰り返されることになり、ループが終了した時点でjにはiの最小の素因数が代入された状態になります。\n最後に、最小の素因数jがもとの数iに等しければiは素数ですので、この性質を利用して、素数ならばTrue、素数以外ならばFalseを印字しています。\n次に、二重ループを作る準備として、上記のコードを、iが素数かどうかに応じてTrueかFalseかを印字するのではなく、素数ならばiを印字し、さもなくば何も印字しないコードに書き換えておきます。\ni = 491     # iを491に設定\nj = 2\nwhile i % j != 0:\n    j += 1\nif i == j:\n    print(i)    # Trueならiを印字\nこれで内側のループが完成しました。次に、iを2から1000まで1ずつ増やしながら全てのiについて上記の操作をするプログラムを作りましょう。そのためには、次のように、上記のコードの2行目以降をまるごと、forループの中に入れて二重ループを作ります。\nfor i in range(2,1000):\n    j = 2\n    while i % j != 0:\n        j += 1\n    if i == j:\n        print(i)    # Trueならiを印字\n上記コードの外側のforループでは、iを2から999まで1ずつ増やしながら2行目以降の処理を行っています。range(2,1000)は、2以上1000未満の整数列を与えるrangeオブジェクトであることに注意してください(教科書p129)。2行目以降は、先のプログラムと全く同じで、iが素数ならiを印字し、さもなくば何も印字しません。これで目的が達成できました。\n\n\n\nbreakはループ処理を中断してループの外に出るための命令を表します。通常ループの中で条件分岐と組みあせわて使います。特に、forループの中でbreakを使うと、繰り返し回数の上限は決まっているが、途中でループを終了する場合もあるようなプログラムを作ることができます。\nたとえば、breakを使うと、素数を求めるプログラムの内側のループをforで実装できます。\nfor i in range(2,1000):\n    for j in range(2,i+1):    # jを2からiまで増やす\n        if i % j == 0:\n            break\n    if j == i:\n        print(i)\n上記のコードでは、iがjで割り切れた時点で内側のforループの処理を終了します。内側のループでrangeオブジェクトの範囲が2からiまでになっていることに注意してください。break文でループを終了すると、ループカウンタの値はbreakが実行された時点での値のままになります。従って、内側のループが終了した時点で、jにはiの最小の素因数が代入された状態になります。\nbreakはwhileと組み合わせることも良くあります。特に、whileの条件をTrueに設定した次のようなループは永遠に条件が成立する(==True)ため、無限にwhileブロックが実行され、終了することがありません。このようなループを無限ループと呼びます。\nwhile True:\n    # ここに書かれた処理は\n    # 無限に繰り返される\nこういったループには、必ずループブロック内部に特定の条件が満たされた場合にbreakで脱出する処理を設ける必要があります。\nbreakは、breakを含む一番内側のループのみ終了させることに注意しましょう。入れ子ループを二つ以上ジャンプするような構文はありません。なお、ループ処理を1回分だけスキップするcontinueという命令文もあります。経験上、continueを使う機会は多くありませんので、説明を割愛します(教科書のp136参照)。\n\n\n\nPythonにはfor-else構文という、独特の制御構文があります。これは、通常のforブロックに加えてelseブロックを持ちます。elseブロックには、breakが実行されずにforが最後まで処理された場合にのみ、追加で実行されるべき処理を書きます。for-elseはなくても特に困らない構文ですが、これを使うと分かりやすいコードを書ける場合があります。\nたとえば、for-else文を使うと、1000未満の素数を求めるプログラムは、次のようにスマートに書けます。\nfor i in range(2,1000):\n    for j in range(2,i):    # jを2からi-1まで増やす\n        if i % j == 0:\n            break           # ループを抜ける\n    else:\n        print(i)  # iを印字\nここで、内側のループのrangeオブジェクトの範囲が2からi-1までであることに注意しましょう。else節は、breakが実行されなかったときのみ、すなわち、iより小さいどのjでも割り切れなかったときのみ実行されます。従って、素数のみが印字されることになります。\n\n\n\nif-else構文では、ある条件が成り立っているときと、そうでないときの処理を指定できました。一方で、\n\nAならばXを実行\nAでないとき、BならばYを実行\nAでもBでないとき、Zを実行\n\nというように、二つ以上の条件を使って処理を分岐させたいときは、elif構文を使います。\nでは、1000未満の自然数iについて、iを印字するとともに、iが2で割り切れるものは2で割った商を、2で割り切れないが3で割り切れるものは3で割った商を、2でも3でも割り切れない場合はXを合わせて印字するようなプログラムを作りましょう。まずは、if-else文で書いてみます。\nfor i in range(1,1000):\n    if i % 2 == 0:\n        print(i,i//2)   # 2で割れるならi//2を印字\n    else:\n        if i % 3 == 0:\n            print(i,i//3)   # 3で割れるならi//3を印字\n        else:\n            print('X')\ni//2は整数iを2で割った商です(教科書p81)。このコードでは、１つめのif-else文のelseブロックの中にさらに入れ子でif-else文が入っていることに注意してください。\n次のように、elif構文を使うと、これと同じことが、入れ子を使わないで記述できます。\nfor i in range(1,1000):\n    if i % 2 == 0:\n        print(i,i//2)   # 2で割れるならi//2を印字\n    elif i % 3 == 0:\n        print(i,i//3)   # 3で割れるならi//3を印字\n    else:\n        print('X')\nelifはelse:ifと本質的に同じ意味ですが、インデントが変化していることに注意してください。見かけ上、入れ子構造がなくなっています。\nこのコードでは、6の倍数は、2でも3でも割り切れますが、2で割った商のみが印字されることに注意してください。elif節はif節が成り立たない場合のみ実行されるので、if節とelif節の条件が両方成り立っている場合は、ifブロックのみが実行されます。\nelifは幾つでも好きなだけ連結できます。次のコードは、2や3では割り切れないが、5で割り切れる数については5で割った商を印字します。\nfor i in range(1,1000):\n    if i % 2 == 0:\n        print(i,i//2)   # 2で割れるならi//2を印字\n    elif i % 3 == 0:\n        print(i,i//3)   # 3で割れるならi//3を印字\n    elif i % 5 == 0:\n        print(i,i//5)   # 5で割れるならi//5を印字\n    else:\n        print('X')\nif-else構文でこのようなプログラムを作ると、入れ子が深くなってしまって大変読みにくくなってしまいます。elif構文はこうした問題を解決してくれます。一般にコードを作成するときは、効率性（コードの短さや速さ）だけでなく、読みやすさ（可読性）に注意してコーディングするようにしましょう。\n\n\n\n\nif、elif、while等の条件式を用いる制御構文では、以下のような論理演算子を用いて複数の条件式を組み合わせた条件式や、条件式の否定文を用いることができます。\n\n\nand演算子は日本語の「かつ」に相当し、条件式A and 条件式Bは条件式Aと条件式Bがともに成立(すなわち値がTrue)のときのみTrueになるような条件式を表します。たとえば、次のコードは、100未満の自然数のうち、2と3の公倍数(つまりは6の倍数)のみを印字します。\nfor i in range(1,100):\n    if i % 2 == 0 and i % 3 == 0:\n        print(i)\n条件式A and Bの値は、条件式A、Bの値に応じて次のように決まります。\n\n\n\nA\nB\nA and B\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nor演算子は日本語の「または」に相当し、条件式A or 条件式Bは条件式Aと条件式Bのうち少なくともどちらか一方がTrueであればTrueになるような条件式を表します。たとえば、次のコードは、100未満の自然数のうち、2の倍数と3の倍数を全て印字します。\nfor i in range(1,100):\n    if i % 2 == 0 or i % 3 == 0:\n        print(i)\n条件式A or Bの値は、条件式A、Bの値に応じて次のように決まります。\n\n\n\nA\nB\nA or B\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nnot演算子は条件式の否定(〜でない)を表し、not 条件式Aは条件式AがFalseのときTrueになる条件式を表します。たとえば次のコードは、100未満の自然数のうち、3で割り切れないものを全て印字します。\ni = 1\nwhile not i &gt;= 100:\n    if not i % 3 == 0:\n        print(i)\n    i += 1\n上のコードは、次のコードと全く同じ意味であることに注意しましょう。\ni = 1\nwhile i &lt; 100:\n    if i % 3 != 0:\n        print(i)\n    i += 1\nこのようにnot演算子を使った条件式は、多くの場合notを使わない条件式に書き換えることができます。notを多用すると条件式が読みにくくなるので、使用は最小限に留めたほうが良いでしょう。例えば、以下のようなコードはnotを使わずに書くのが難しい例です。\n# ブラックリスト以外を印字するコード\nblack_list = [12,34,56,78,91]\nfor i in range(1,100):\n    if not i in black_list:\n        print(i)\nこのコードは、100未満の自然数のうち、リストblack_listに含まれていないもののみを印字します。ここでinは、特定の要素がリストに含まれているかどうかをチェックする演算子であり、A in BはAがリストBに含まれていればTrueとなります。したがってnot A in BはAがリストBに含まれていないときのみTrueになります。ちなみに、not A in BはA not in Bと書くこともできます。\n教科書のセクション3.4には、論理演算子のより高度な使い方が解説されています。興味のある方はチェックしておきましょう。\n\n\n\n上記の「ブラックリスト以外を印字するコード」をnotやnot inを使わずに書き直してください。(ヒント:if-else構文とpassを使います。)\n\n\n\n\n本講義では、以下のことを学びました。\n\nリストの構造\nシャローコピー\nディープコピー\nスライス記法\nリストの演算\nループ処理\nrangeオブジェクト\n条件分岐\n論理演算子\n\n今回の講義では、リストや制御構文のごく基本的な事柄しか扱えませんでした。リストや制御構文には非常に多くの押さえておくべき事柄がありますので、教科書のセクション4とセクション6を良く読んでおきましょう。\n\n\n\n\n『High Performance Python: Practical Performant Programming for Humans』(M. Gorelick, I. Ozsvald著) (2020) O’Reilly. ISBN-13 : 978-1492055020.\nハイパフォーマンスPython第2版(M. Gorelick, I. Ozsvald著, 中山光樹(訳)) (2023) O’Reilly. ISBN-13: 978-4873119908.\n\n上記参考書はリストや辞書の挙動について詳しいです(2は1の翻訳)。中〜上級者向け。\n\n\n\n\n\n\nPythonのビルトインデータ型には、__sizeof__というメソッドが備わっており、getsizeofはこれを呼び出しています。しかし、getsizeofの戻り値は__sizeof__の戻り値と常に同じではなく、前者はデータ型によってはオーバーヘッドにガベージコレクションのためのメモリ領域16バイトを含むことがあります。本稿では、オーバーヘッドの大きさには関心がないので、getsizeofと__sizeof__の違いについては論じません。\n参考までに、筆者の環境において幾つかの単純なオブジェクトに対する両者の出力を列挙しておきます。\n\n\n\nオブジェクト\ngetsizeof\n__sizeof__\n\n\n\n\n0\n24\n24\n\n\n\"\"\n49\n49\n\n\n[]\n56\n40\n\n\n()\n40\n24\n\n\n{}\n64\n48\n\n\ndict()\n232\n216\n\n\nset()\n216\n200\n\n\n\n\n\n\n\nリストがどのように要素オブジェクトへの参照を格納しているかは、リストオブジェクトを作成するCPythonのソースコードを見ると分かりやすいです。こちらはちょっと細かい話なので別ファイルにします。\n長いリストにおいてpopメソッドを使うとき、リストの末尾からpopするよりも、先頭からpopするほうが、はるかに遅いことが知られています。なぜそのような速度の差が生じるのか、考察してください。リストはpopによって配列に隙間が出来たときに何をしなければならないか、そしてそれにはどのくらいの時間がかかるか考察してみてください。\nrangeオブジェクトは、要素の参照を格納していません。様々な長さのrangeオブジェクトを作成し、占有メモリのサイズを比較してみてください。なぜPython3が等差数列リストではなく、rangeオブジェクトを使用することを選んだのか、考察してみてください。\n講義本編では、リストのサイズを一つずつ増やしながら、リストの占有メモリサイズが要素数に対して線形に増えていくことを確認しました。一方、リストのappendメソッドによって、既存のリストに一つずつ要素を加えていくときは、占有メモリサイズは線形には増加して行かず、興味深いパターンを示します。どのようなパターンになるのか研究し、なぜそのようになっているのか考察しましょう。"
  },
  {
    "objectID": "programming2025/programming-5.html#リストのしくみ",
    "href": "programming2025/programming-5.html#リストのしくみ",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "今回の講義では、Pythonのデータ型の代表格であるリストをじっくりと研究してみましょう。リストを研究することで、Pythonのデータ構造の特徴がより一層深く理解できるようになります。また、リストを研究していく過程で、ループ処理や条件分岐といった制御構文について学んでいきましょう。\nまず、次のように長さ5のリストを作成してxに代入すると何が起きるか考えてみましょう。\nx = [120,-3,'Py','thon','foo']\n筆者の環境で上記を実行すると、Pythonは、リストオブジェクトを保存するための96バイトのメモリ領域を確保して、それにxという名前をつけます。この96バイトのメモリ領域がリストオブジェクトの正体です(具体的なバイト数は処理系やPythonのバージョンにより異なります)。\nオブジェクトが占有するメモリ領域のサイズは、sysモジュールのgetsizeof関数によって調べることができます。ここでモジュールについて簡単に説明しておきます。モジュールというのは、通常Pythonの関数や特殊な変数を定義したファイルです。たとえば、module_nameという名前のモジュールで定義されたfunction_nameという関数を用いる場合は、次のように記述します。\n# %%\nimport module_name  #　モジュール読み込み\nmodule_name.function_name()   # 関数呼び出し\nあるいは、関数function_nameだけを読み込みたい場合は、次のようなfrom ... import文を用いることができます。\n# %%\nfrom module_name import function_name\nfunction_name()\nこのようにして読み込んだ場合、モジュール名module_name.を頭に付けることなく関数function_nameを呼び出すことができるようになりますが、モジュールmodule_name内のそれ以外の関数は呼び出せません。モジュールについては、後の講義で詳しく取り上げます。\nさてsysモジュールは、ビルトインモジュールという特殊なモジュールであり、ファイルとしては存在しておらず、Pythonインタープリタに埋め込まれ(built-in)ています。sysの関数群を用いると、Pythonの非常に基本的な機能にアクセスすることができます。ここでは、getsizeofという、引数に与えたオブジェクトの占有メモリサイズをバイト単位で返してくれる関数を使いましょう。\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getsizeof([120,-3,'Py','thon','foo'])\n96\n96バイトのうち56バイトには、参照カウンタやら何やらが保存されており、からっぽのリストにすら存在する領域で、オーバーヘッドと呼ばれることもあります。オーバーヘッドの具体的なサイズはPythonのバージョンや環境によって若干異なりますので、各自調べてみましょう(getsizeofの注釈参照)。\nオーバーヘッドの容量は空のリストのサイズを調べることにより確かめられます。\n&gt;&gt;&gt; sys.getsizeof([])\n56\nメモリの効率的利用について研究しているのでないかぎり、オーバーヘッドの機能を意識することはあまり重要ではありません。重要なのは残り40バイトの配列と呼ばれる部分です。\n\n\n\nlist structure\n\n\nこの合計40バイトの配列はメモリ上で一続きになっており、各8バイトの5つの区画に分かれています。それぞれの区画には、リストの要素になっているオブジェクトのアドレスが格納されています。(第1回の講義で学んだように、64ビット処理系ではメモリアドレスを8バイト数値で表すことに注意しましょう。リストのメモリ利用に関する注釈参照。)\nたとえば第1要素である120という整数オブジェクトは、メモリ上の9604番地に存在します（実際にはアドレスはもっと大きな整数ですが、面倒なので下4桁だけ使っています）が、それに対応して、リストオブジェクトの配列の第1番目の区画には、オブジェクト120のアドレスである9604が書き込んであります。他の要素についても同じで、配列の第k番目の区画には、リストの第k番目の要素であるオブジェクトのアドレスが格納されています。\nこのように、リストオブジェクトは、その要素そのものを直に格納しているのではなく、要素オブジェクトのアドレスを格納しています。このおかげで、リストオブジェクトには、整数、小数、文字列などの様々なデータ型のPythonオブジェクトを好きな順番で詰め込めるようになっています。なぜなら、どんなオブジェクトでも、アドレスは8バイトの数値だからです。\nリストが要素オブジェクトそのものを含んでいないことは、getsizeofを使っても間接的に確かめることができます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = [1,2,[3,4,5,6]]\n&gt;&gt;&gt; z = [1,2,[3,4,5,6,7,8,9,10]]\n&gt;&gt;&gt; sys.getsizeof(x)\n80\n&gt;&gt;&gt; sys.getsizeof(y)\n80\n&gt;&gt;&gt; sys.getsizeof(z)\n80\n上のコードでは、x、y、zが含んでいる要素の数はすべて異なるように見えますが、実際にはどのリストもオブジェクト三つ分の参照しかもっていないので、占有するメモリの大きさは同じになっています。もしリストが要素オブジェクトそのものを含んでいるとしたら、メモリの占有サイズは\nx &lt; y &lt; z\nとなることが期待されますが、そうはなっていません。\nなお、上記の性質は、リストだけでなく、より広いコンテナというクラスのデータ型の多くに当てはまる性質です。これから論じることは、多くが他のコンテナ型のデータ型に当てはまります。コンテナ型については教科書のセクション6に詳しいので、良く読んでおいてください。\nたとえば\n&gt;&gt;&gt; x = [120,-3,'Py','thon','foo']\n&gt;&gt;&gt; x[1]\n-3\n&gt;&gt;&gt; \nのように入力するときPythonは、xというリストオブジェクトの中にある配列領域のインデックス1の要素に書いてあるアドレスをチェックして、次にそのアドレスに行ってどんなオブジェクトがあるのかチェックします。するとそこには-3という整数オブジェクトがあったので、それを出力してくれています。"
  },
  {
    "objectID": "programming2025/programming-5.html#リスト要素の修正",
    "href": "programming2025/programming-5.html#リスト要素の修正",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "では次に、リストの要素の書き換えについて考えてみます。たとえば第2インデックス要素を’Py’から’bar’に書き換えたいとします。この場合、次のように書きます。\nx[2] = 'bar'\nするとPythonは何をするかというと、’bar’という文字列オブジェクトをメモリ上に作成して、そのアドレス0800をリストxの配列の第2インデックス要素に上書きで格納します。これによって、オブジェクト’Py’はリストxからは忘れ去られ、代わりに'bar'がリストのメンバーとして参入します。\n\n\n\nlist change element\n\n\nここで重要なのは、もともと'Py'が存在していた5782番地の内容が書き換えられるわけではないということです。そうではなく、単にリストxが覚えているアドレスが付け替えられるだけです。\nこのように、x[2]という表記は、第3要素オブジェクトへの参照として機能します。言い変えると、x[2]='bar'という代入は、ハコ型代入ではなくラベル型代入になっているということです。Pythonリストは、要素オブジェクトへの参照を格納していると考えることができ、通常Pythonのコミュニティーはそのような表現を好んで使います。"
  },
  {
    "objectID": "programming2025/programming-5.html#再帰的リスト",
    "href": "programming2025/programming-5.html#再帰的リスト",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "Pythonリストが格納しているのは要素オブジェクトそのものではなく要素オブジェクトへの参照であることから、リストは自分自身を要素にもつという奇妙なことができてしまいます。次のようにしてみましょう。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x[2] = x\n&gt;&gt;&gt; x\n[1, 2, [...]]\nここでは、リストxを作成したあと、その第3要素に自分自身を代入しています。これにより、xの内部にある配列の最後の要素には、x自身の参照が格納されることになります。最後の[...]という表現は、仮に自分自身をここに表示すると無限に入れ子になったリストを表示することになってしまうので、それを避けるために導入された略記表現です。\nこうした自分自身への参照を要素にもつ再帰的リストを積極的に作るべき場面はすこし思いつきませんが、似たような状況はPythonプログラミングにおいて容易に生じ得ます。それは、複数のリストオブジェクトが互いに相手への参照を要素にもつ以下のような場合です。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = [4,5,6]\n&gt;&gt;&gt; x[2] = y\n&gt;&gt;&gt; x\n[1, 2, [4, 5, 6]]\n&gt;&gt;&gt; y[2] = x\n&gt;&gt;&gt; x\n[1, 2, [4, 5, [...]]]\n&gt;&gt;&gt; y\n[4, 5, [1, 2, [...]]]\n詳しくは解説しませんが、このような循環参照はガベージコレクションというメモリ管理において重要なトピックとなります。興味がある人はインターネット等で調べてみてください。"
  },
  {
    "objectID": "programming2025/programming-5.html#リストのコピー",
    "href": "programming2025/programming-5.html#リストのコピー",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "PythonにはRのCopy on modifyがないため、リストの複製を作るためには、明示的にプログラマが複製操作を行う必要があります。\nPythonでは、それぞれのデータ型は、それを操作するための専用の一連の関数をもっています。このような関数群を、そのデータ型のメソッドと呼びます。(メソッドについては、後の講義で詳しく解説します。)\nたとえば、リスト型がどのようなメソッドを持つかを調べたいときは、REPLにおいてlist.と入力してタブキーを叩くと一覧が表示されます(もし1回で駄目なら2回叩いてください)。\n&gt;&gt;&gt; list.\nlist.append(  list.copy(    list.extend(  list.insert(  list.pop(     list.reverse(\nlist.clear(   list.count(   list.index(   list.mro(     list.remove(  list.sort(\nもしくはVS Code上でlist.と入力してしばらく待つと、メソッド一覧が表示されます(ただし少なくともpyreadlineモジュールがインストールされている必要がありますし、もしかしたらインテリセンスという拡張機能も必要かもしれません)。\n上記のリストのメソッド一覧の中に、copyという自身の複製を作成するメソッドが有ります。これを呼び出すには、次のようにします。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x.copy()    # xの複製を作ってyに代入\n&gt;&gt;&gt; x\n[1, 2, 3]\n&gt;&gt;&gt; y\n[1, 2, 3]\n&gt;&gt;&gt; x is y    # xとyは異なるオブジェクト\nFalse\n&gt;&gt;&gt; id(x)\n2510581312768\n&gt;&gt;&gt; id(y)\n2510581325056\n確かに、xのコピーが作成され、yに代入されています。xとyは異なるアドレスを指しており、異なるオブジェクトを参照していることが分かります。\n注意しなくてはならないのは、copyメソッドを呼び出すと、実際にコピーされるのは、要素オブジェクトへの参照であって、要素オブジェクト自体はコピーされないということです。参照がコピーされるということは、アドレスがコピーされるということです。xとyは、それ自体はメモリの違う場所にありながら、全く同じ要素オブジェクトを参照していることになります。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x.copy()\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[0] is y[0]    # 第1要素を共有\nTrue\n&gt;&gt;&gt; x[1] is y[1]    # 第2要素を共有\nTrue\n&gt;&gt;&gt; x[2] is y[2]    # 第3要素を共有\nTrue\nこうした性質をもったコピーをpythonではシャローコピー(shallow copy)と呼びます。シャローコピーは、要素がイミュータブルな場合には全く問題になりません。シャローコピーが問題になるのは、リストがミュータブルな要素を持つときです。\nたとえば次の例を考えてみましょう。ここでは、zというリストを作成したうえで、リストxの第2要素にzへの参照を持たせています。さらにxのコピーを作ってyに代入すると、xとyは異なるオブジェクトとなりましたが、当然第2要素のzを共有したままです。従って、x[2]の要素を変更すると、yにまで影響が及びます。\n&gt;&gt;&gt; z = [1,2,3]\n&gt;&gt;&gt; x = [120,-3,z,'thon','foo']\n&gt;&gt;&gt; y = x.copy()\n&gt;&gt;&gt; x\n[120, -3, [1, 2, 3], 'thon', 'foo']\n&gt;&gt;&gt; y\n[120, -3, [1, 2, 3], 'thon', 'foo']\n&gt;&gt;&gt; x is y  # xとyは異なるオブジェクト\nFalse\n&gt;&gt;&gt; x[2] is y[2]  # だがzオブジェクトを共有\nTrue\n&gt;&gt;&gt; x[2][1] = 5   # x経由でzに修正を加える\n&gt;&gt;&gt; x\n[120, -3, [1, 5, 3], 'thon', 'foo']\n&gt;&gt;&gt; y             # yも変わってしまった\n[120, -3, [1, 5, 3], 'thon', 'foo']\nこれは図に書くと何が起きているのか分かりやすいでしょう。\n\n\n\nlist_shallow_copy"
  },
  {
    "objectID": "programming2025/programming-5.html#要素の参照をウォッチする",
    "href": "programming2025/programming-5.html#要素の参照をウォッチする",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "上の例が示すように、リストの各要素がメモリのどこを参照しているのかを逐一把握するのは大変です。\nそこで、ここでは、リストの各要素のアドレス(id関数の出力)の下位2バイトを出力する関数を定義しておきます。\ndef sid(obj):\n    return hex(id(obj)&0xffff)\n\ndef lid(obj):\n    if type(obj) is list:\n        return [sid(el) for el in obj]\n    else:\n        return sid(obj)\nsidは、オブジェクトのアドレスの下位2バイトを返します。一方lidは、リストが引数に与えられたとき、要素の参照を要素として持つリストを返します。リスト以外を引数に与えたときはsidの戻り値を返します。\n\n\n上記のコードを実行する際にリアルタイムで何が起きているのかをデバッグモードで確かめることにします。GitHub/varsディレクトリの下に適当なファイル(たとえば”shallow.py”)を作成し、上のsid、lidのコードをコピー＆ペーストした上で、その下に次のコードを記述しなさい。\nz = [1,2,3]\nx = [120,-3,z,'thon','foo']\ny = x.copy()\nx[2][1] = 5   # x経由でzに修正を加える\npass\n次の8式をウォッチ式に設定しなさい。\n\nsid(x)\nsid(y)\nx is y\nlid(x)\nlid(y)\nx[2] is y[2]\nlid(x[2])\nlid(y[2])\n\nデバッグを実行し、ステップインによってウォッチ式と各変数の値がどのように変化するか観察しなさい。\n\n\n\n次の2つのコードについて、xの変更(ともに3行目)はyに影響を及ぼすか?結果を予想してからデバッグモードで確かめなさい。\n# コード1\nx = [1,[4,5,6],3]\ny = x.copy()\nx[1] = [7,8,9]\npass\n# コード2\nx = [1,[4,5,6],3]\ny = x.copy()\nx[1][:] = [7,8,9]\npass\nただし、以下のウォッチ式を設定すること。\n\nsid(x)\nsid(y)\nx is y\nlid(x)\nlid(y)\nx[1] is y[1]\nlid(x[1])\nlid(y[1])"
  },
  {
    "objectID": "programming2025/programming-5.html#ディープコピー",
    "href": "programming2025/programming-5.html#ディープコピー",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "このようにシャローコピーは、意図せぬ挙動を引き起こす可能性がありますので、それを避けたい場合はディープコピーという操作を行います。ディープコピーをすると、参照だけでなく要素オブジェクトも再帰的にコピーされます。ディープコピーは、copyモジュールによって提供されるdeepcopy関数で行うことができます。\n&gt;&gt;&gt; import copy\n&gt;&gt;&gt; x = [1,[4,5,6],3]\n&gt;&gt;&gt; y = copy.deepcopy(x)\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[1] is y[1]\nFalse\nただし、次のコードで分かるように、何もかもコピーされてしまうわけではありません。“末端”のイミュータブルオブジェクトなど、オリジナルと複製で共有しても問題が起きないような場合は、複製を行いません。\n&gt;&gt;&gt; x = [1000,[4000,5000,6000],3000]\n&gt;&gt;&gt; y = copy.deepcopy(x)\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[1] is y[1]\nFalse\n&gt;&gt;&gt; x[0] is y[0]\nTrue\n&gt;&gt;&gt; x[1][0] is y[1][0]\nTrue\n従って、特に入れ子の構造がないオブジェクトでは、シャローコピーとディープコピーの動作は全く同じです。\n\n\n次のコードをデバッグモードで実行し、単なる代入、シャローコピー、ディープコピーの違いを観察しなさい。\nimport copy\nx = [1,2,[3,4,[5,6]]]\ny = x\ny = x.copy()\ny = copy.deepcopy(x)\npass\nただしウォッチ式は以下とすること。\n\nsid(x)\nsid(y)\nx is y\nlid(x)\nlid(y)\nx[2] is y[2]\nlid(x[2])\nlid(y[2])\nx[2][2] is y[2][2]\nlid(x[2][2])\nlid(y[2][2])"
  },
  {
    "objectID": "programming2025/programming-5.html#スライス記法",
    "href": "programming2025/programming-5.html#スライス記法",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "シャローコピーはスライス記法によっても行うことができます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x[:]\n&gt;&gt;&gt; x is y\nFalse\nこのように、スライス記法は通常はシャローコピーとなりますが、代入の左辺で使うときは意味合いが異なりますので注意が必要です。前回の講義でも論じたように、左辺で使うと、コピーを作るのではなく、オリジナルのリストオブジェクトを変更することになります。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x[:] = [4,5,6]\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y\n[4, 5, 6]\n&gt;&gt;&gt; x is y\nTrue\nこのように、代入の左辺で使うスライス記法とそれ以外のスライスは分けて考えた方が良いでしょう。なお、これはスライス記法だけでなく、x[0]と言ったような、単一要素のインデクシングでも同じことが言えます。\nちなみに、スライス記法は、リストの1部分のシャローコピーを作るのにも使えます。下では、xの第1インデックス～第3インデックス要素のコピーをyに代入しています。\n&gt;&gt;&gt; x = [1000,2000,3000,4000,5000]\n&gt;&gt;&gt; y = x[1:4]      # スライスによるコピー\n&gt;&gt;&gt; x is y\nFalse\n&gt;&gt;&gt; x[1] is y[0]\nTrue\n&gt;&gt;&gt; x[2] is y[1]\nTrue\n&gt;&gt;&gt; x[3] is y[2]\nTrue\nここで、x[1:4]という表現は、xの第1インデックス要素から第3インデックス要素までを取り出す表現ですが、これはなれないと分かりにくいかと思います。まず基本的な事項として、リストのインデックスは0からはじまることに注意しましょう。たとえば上の場合ですと、インデックスと要素オブジェクトの対応は次のようになります。\n\n\n\nインデックス\n0\n1\n2\n3\n4\n\n\n\n\n要素オブジェクト\n1000\n2000\n3000\n4000\n5000\n\n\nx[1:4]\n\n始点\n–&gt;\n終点\n\n\n\nx[0:3]\n始点\n–&gt;\n終点\n\n\n\n\nx[:2]\n始点\n終点\n\n\n\n\n\nx[2:]\n\n\n始点\n–&gt;\n終点\n\n\n\nx[i:j]という表現では、インデックスiからj-1の位置までスライスすることになります。上の表には幾つかの例を挙げておきました。リストの先頭要素が始点の場合、始点を指定するインデックス0は省略できます。同様に、リストの末尾要素が終点の場合、終点を指定するインデックス(この場合5)は省略することができます。\nさて部分的なスライスを代入の左辺で使うと、やはりオブジェクト本体の変更になります。なお、左辺のスライスの長さと右辺のリストの長さは違っても構いません。\n&gt;&gt;&gt; x = [1,2,3,4,5]\n&gt;&gt;&gt; x[1:4] = ['foo','bar']\n&gt;&gt;&gt; x\n[1, 'foo', 'bar', 5]\n&gt;&gt;&gt; x = [1,2,3,4,5]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x[1:5] = ['foo','bar']\n&gt;&gt;&gt; x\n[1, 'foo', 'bar']\n&gt;&gt;&gt; y\n[1, 'foo', 'bar']\n&gt;&gt;&gt; x is y\nTrue"
  },
  {
    "objectID": "programming2025/programming-5.html#リストの変形と演算",
    "href": "programming2025/programming-5.html#リストの変形と演算",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "リストは様々なメソッドを搭載しており、要素の編集を行うことができます。たとえばappendメソッドは、リストの末尾に要素を追加します。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x.append(4)\n&gt;&gt;&gt; x\n[1, 2, 3, 4]\nここでは、xの末尾に4という値を付け足しています。\nその逆に、popメソッドはリストから要素を取り出すことができます。\n&gt;&gt;&gt; x = [1,2,3,4,5]\n&gt;&gt;&gt; y = x.pop()         # 末尾から取り出す\n&gt;&gt;&gt; x\n[1, 2, 3, 4]\n&gt;&gt;&gt; y\n5\n&gt;&gt;&gt; y = x.pop(1)    # インデックス1から取り出す\n&gt;&gt;&gt; x\n[1, 3, 4]\n&gt;&gt;&gt; y\n2\nそのほか、+演算子を用いて複数のリストを結合することが可能です。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x + [4,5,6]\n&gt;&gt;&gt; y\n[1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; x\n[1, 2, 3]\nただし、この場合はappendメソッドと違って、もとのオブジェクトx自体は変更されていないことに注意してください。\nリストを*演算子で掛け算することもできます。\n&gt;&gt;&gt; x = [1]*10\n&gt;&gt;&gt; x\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nただし、*演算子は対象リストをシャローコピーして繋げるだけであることに注意しなくてはなりません(教科書のp.212参照)。つまり、次のようなことが起きます。\n&gt;&gt;&gt; x = [[1,2]]*5\n&gt;&gt;&gt; x\n[[1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]\n&gt;&gt;&gt; x[0][1] = 5   # 第1の要素だけ変更したつもり\n&gt;&gt;&gt; x   # だが全ての要素が変わってしまった\n[[1, 5], [1, 5], [1, 5], [1, 5], [1, 5]]\nリストについてはこれ以上の説明は省略しますが、教科書のセクション6.1に様々な操作が載っていますので、よく読んでおいてください。"
  },
  {
    "objectID": "programming2025/programming-5.html#ループ処理",
    "href": "programming2025/programming-5.html#ループ処理",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "それではここで、リストオブジェクトが占有するメモリのサイズが、要素の数とともにどのように増加していくか調べてみましょう。理論的予測に基づけば、1つの要素オブジェクトあたり、オブジェクトの参照を格納するのに8バイト使います。従って、要素の数をnとすれば、リストの占有メモリサイズは(オーバーヘッド容量)+8nとなるはずです。\nこの実験を行うために、繰り返しのための制御構文であるforループを使ってみましょう。皆さんはRのforループをすでにご存じだと思います。次のような構文でしたね。\n# 1:10はベクトルc(1,2,3,4,5,6,7,8,9,10)と同じ意味\n\nfor (i in 1:10) {\n  print(i)  #forブロック\n}\nprint('End')\n上記のコードは、1から10までの整数を画面に出力したあと、最後に’End’と出力するRコードです。中括弧の中身はforブロックと呼ばれ、ここに記述された内容が繰り返されます。iはループカウンタと呼ばれる変数で、ループが1回実行されるごとに1ずつ増加していきます。iの初期値と最終的な値はinの後に記述されたベクトル1:10が決定します。この場合は、初期値がi=1、最後のループではi=10となります。\nPythonのforループもよく似ているので、Rのforを知っている皆さんならば即座に理解できます。\n# ループはi=0からi=3まで繰り返して欲しい\nindex_range = [0,1,2,3]\n\nfor i in index_range:\n    print(i)        # \n    print('FOO')    # ここは\n    print('BAR')    # 全部\n    print('BAZ')    # forブロック\n    print('')       #\n\nprint('End')\n上記のPythonコードは0から3までの整数を画面に印字します(ついでに’FOO’、‘BAR’、’BAZ’も印字します)。\nRとの違いをまとめると、次のようになります。\n\nforブロックが中括弧ではなくインデント(字下げ)によって表現される。\n先頭行の行末にコロン(:)が必要。\nforのあとの丸カッコは必要ない。\n\nなかでも重要なのは1です。print(i)やprint('FOO')のまえにタブキー1つ分の字下げが入っていることに注意してください。これによって、print(i)やprint('FOO')はforブロックの中の要素であるとPythonインタープリタによって解釈されます。一方、print('End')は字下げしていないので、ブロックの外にあると見なされ、繰り返されることはありません。\nそれでは上記のコードをVS Codeのインターラクティブモードで実行してみてください。\n0\nFOO\nBAR\nBAZ\n\n1\nFOO\nBAR\nBAZ\n\n2\nFOO\nBAR\nBAZ\n\n3\nFOO\nBAR\nBAZ\n\nEnd\n\n\n上記のコードの最初の行をブレークポイントに設定して、デバッグモードで起動してください。ステップインを繰り返し、どのようにiの値が変化していくか、どういう順番でコードが実行されていくかをよく観察してください。\nforループについては、教科書のセクション4.2.3に詳しく解説されていますので、良く読んでおいてください。"
  },
  {
    "objectID": "programming2025/programming-5.html#rangeオブジェクト",
    "href": "programming2025/programming-5.html#rangeオブジェクト",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "PythonにはRのように1:10といった連続整数値のベクトルを表す簡便な表記がありません。Pythonでは代わりに、もっと性能の良いrangeオブジェクトという特殊なオブジェクトを用います。\nrangeオブジェクトは、リストではありませんが、forループにおいて連続する数値のリストと同じ働きをするオブジェクトです(こういったオブジェクトをイテラブルと言います)。rangeオブジェクトを用いると、先のコードは次のようになります。\n# %%\n# range(4)は[0,1,2,3]と同じように機能する\n\nfor i in range(4):    # rangeオブジェクトを使った\n    print(i)        \n    print('FOO')    \n    print('BAR')    \n    print('BAZ')    \n    print('')       \n\nprint('End')\n上のコードにおいて、rangeはrangeオブジェクトを生成する関数であり、range(4)は0から3までの連続する整数のリストと全く同じように機能します。一般に、0からnまでの連続する整数を表したいときはrange(n+1)と書きます。\nrangeオブジェクトから、リストを作成することも可能です。そのためには、次のように関数listを使います。\n&gt;&gt;&gt; x = list(range(4))\n&gt;&gt;&gt; x\n[0, 1, 2, 3]\nrange関数については、教科書のセクション4.2.4に詳しく解説されていますので、良く読んでおいてください。\n\n\n次のように、0から9までの全ての整数について、2乗した値を出力するプログラムrange関数を使って書きなさい。\n# 結果\n\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81"
  },
  {
    "objectID": "programming2025/programming-5.html#リストの占有メモリサイズ",
    "href": "programming2025/programming-5.html#リストの占有メモリサイズ",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "それでは、forループを使ってリストのサイズと占有メモリサイズの関係を調べましょう。以下のプログラムはリストのサイズを0(空っぽ)から50まで変化させたときに、リストの占有メモリサイズがどのように変化するかを調べるためのものです。\n# リストのサイズが0から50まで変化するとき\n# メモリの占有サイズはどう変化するか?\n\nimport sys\n\nfor i in range(51):\n    temp_l = list(range(i))             # リストを作成\n    s_temp_l = sys.getsizeof(temp_l)    # サイズ計算\n    print(s_temp_l,end=' --&gt; ')         # 結果の出力\nforブロックの中を1行ずつ見ていきましょう。\nまず1行目ですが、\ntemp_l = list(range(i))\nこれは、0で始まりi-1で終わるリスト[0,1,2,3,...,i-1]を作成してtemp_lという変数に代入しています。iはループインデックスですので、k回目のループでは、長さkのリストが作成されることに注意しましょう。よってforブロックが1回実行されるごとに、作成されるリストの長さは要素1個ぶん長くなります。\nちなみに、最初のループではi=0です。したがって最初のループでは\ntemp_l = list(range(0))\nを実行していることになりますが、これは空のリストを作成することに注意してください。\n2行目は、\ns_temp_l = sys.getsizeof(temp_l)\nですが、これは先ほど作成したtemp_lのサイズを計算してs_temp_lという変数に代入しています。最後に、\nprint(s_temp_l,end=' --&gt; ')\nですが、これは上記で計算したメモリサイズs_temp_lを出力しています。print関数は、デフォルトで改行するようになっていますが、オプション引数endによって改行以外の文字を出力することができます。ここでは、サイズを出力したあとに、’ –&gt; ’という文字列を出力しています。\nそれでは、VS Codeで上記のコードを実行してみましょう。\n56 --&gt; 64 --&gt; 72 --&gt; 80 --&gt; 88 --&gt; 96 --&gt; 104 --&gt; 112 --&gt; 120 --&gt; 128 --&gt; 136 --&gt; 144 --&gt; 152 --&gt; 160 --&gt; 168 --&gt; 176 --&gt; 184 --&gt; 192 --&gt; 200 --&gt; 208 --&gt; 216 --&gt; 224 --&gt; 232 --&gt; 240 --&gt; 248 --&gt; 256 --&gt; 264 --&gt; 272 --&gt; 280 --&gt; 288 --&gt; 296 --&gt; 304 --&gt; 312 --&gt; 320 --&gt; 328 --&gt; 336 --&gt; 344 --&gt; 352 --&gt; 360 --&gt; 368 --&gt; 376 --&gt; 384 --&gt; 392 --&gt; 400 --&gt; 408 --&gt; 416 --&gt; 424 --&gt; 432 --&gt; 440 --&gt; 448 --&gt; 456 --&gt; \nたしかに、オーバーヘッド容量からはじまって、リストの長さが1増加するごとにメモリサイズが8バイト増加していることが分かります。"
  },
  {
    "objectID": "programming2025/programming-5.html#条件分岐",
    "href": "programming2025/programming-5.html#条件分岐",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "ところで、上記の”実験”プログラムは、出力が’–&gt;’記号で終わっていて美しくありません。この最後の矢印を消す方法を考えてみましょう。\nforブロックの最後の文で、print関数を用いていますが、そのオプション引数endを、forブロックが最後に実行される時以外は’ –&gt; ’に設定し、最後の実行のときだけは改行に設定すれば良さそうです。\nこれを言葉で書くと次のようになるでしょう。\nもし i &lt; 50 ならば、end_str = ' --&gt; '\nさもなくば、end_str = 改行文字\nただしend_strはprint関数のend引数に与える文字列です。\nところで、Rでの条件分岐を覚えているでしょうか?代表的な条件分岐の構文であるif-else文を思い出してみましょう。\nif (i &lt; 50) {\n  end_str &lt;- ' --&gt; '   # ifブロック\n} else {\n  end_str &lt;- '\\n'      # elseブロック\n}\n上記のコードで、’’は様々なプログラミング言語で改行文字を表す記号です。このようなバックスラッシュを使ってあらわされる特殊文字をエスケープシーケンスと呼びます。エスケープシーケンスについては、教科書のセクション2.2.7に詳しく説明されているので、良く読んでおいてください。\nさて、ifの後の中括弧に挟まれたコード領域はifブロックと呼ばれ、丸カッコの中の条件がTRUEの場合のみ実行されます。一方elseの後の中括弧に挟まれたコード領域はelseブロックと呼ばれ、条件がFALSEの場合のみ実行されます。従って、上記Rコードは、\nもし i &lt; 50 ならば、end_str = ' --&gt; '\nさもなくば、end_str = '\\n'\nとなり、意図した通りのコードになっています。\n全く同じことをPythonで書くと、次のようになります。\nif i &lt; 50:\n    end_str = ' --&gt; ' # ifブロック\nelse:\n    end_str = '\\n'    # elseブロック\nRでのif-elseと比べると、次の違いがあります。\n\nifブロック、elseブロックが字下げによって表現される\nif行とelse行はコロン(:)で終わる\n条件節を囲む丸カッコは必要ない\n\nここでもやはり1が最も重要です。条件分岐でも、やはりコードブロックは字下げによって表現されます。\nなおRと同様に、else:節は必須ではありません。else:節を省略すると、条件が不成立の場合には何もしません。したがって、たとえば次のように書いても、結果は同じになります。\n# 先にend_strを' --&gt; 'に設定し、\n# 最後のループだけend_str = '\\n'に再設定する\nend_str = ' --&gt; '\n\nif i == 50:\n    end_str = '\\n' # ifブロック\nそれでは条件分岐を用いて、メモリサイズ計算プログラムを改良しましょう。\nimport sys\n\nfor i in range(51):\n    temp_l = list(range(i))\n    s_temp_l = sys.getsizeof(temp_l)\n    if i &lt; 50:\n        end_str = ' --&gt; '\n    else:\n        end_str = '\\n'\n    print(s_temp_l,end=end_str)\nなお、実際にはもっとパフォーマンスの良い書き方はありますが、ここでは条件分岐の説明のために上記のコーディングを採用しました。"
  },
  {
    "objectID": "programming2025/programming-5.html#ブレークポイントの編集",
    "href": "programming2025/programming-5.html#ブレークポイントの編集",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "ここでは、上記のfor文の中でif-else構文がどのように機能しているのかを見るため、やや高度なブレークポイントを設定してみます。\nforブロックの1行目にブレークポイントを設定してください。ブレークポイントの赤いマークを右クリックし、『ブレークポイントの編集』を選びます。\n\n\n\nconditional_break\n\n\n『式：式がtrueと評価される場合に中断します。』と表示されるので、i==48と入力してEnterしましょう。\n\n\n\nconditional_break\n\n\nこれで、iが48に等しいときにのみストップするブレークポイントになります。(『式』ではなく『ヒットカウント』を選んで49を入力しても効果は同じです。)\nウォッチ式には、i &lt; 50を設定しましょう。\nこれでデバッグを実行すると、forループの49回目でストップしますので、そこからステップインを繰り返し、ウォッチ式i &lt; 50の値に応じて、ifブロックとelseブロックのどちらが実行されるか観察してください。"
  },
  {
    "objectID": "programming2025/programming-5.html#より望ましいコーディング",
    "href": "programming2025/programming-5.html#より望ましいコーディング",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "ところで、上記のコードでは、50や51といった具体的な値がコードのなかに埋め込まれています。これでは、値を変更したくなったときに一々50と51の両方を修正しなくてはなりません。また、もっとプログラムが大きくなると、どこの値を修正すれば良いのか分からなくなりそうです。従って、具体的な数値をソースコードの途中に色々と書き込むのは良くなさそうです。\n具体的な値は、次のように、ソースコードの最初のほうで変数に置き換えてしまうのが望ましいです。ついでに、以下の改良を付け加えてみましょう。\n\n結果が見やすいように5つごとに改行\nオーバーヘッド分を差し引く\n\nimport sys\n\nmax_size = 50   # max_sizeは最大のリスト長\noverhead = sys.getsizeof([]) # オーバーヘッド計算\n\nfor i in range(max_size+1):\n    temp_l = list(range(i))\n    s_temp_l = sys.getsizeof(temp_l)\n    if i &lt; max_size:\n        end_str = ' --&gt; '\n    else:\n        end_str = '\\n'\n    print(s_temp_l-overhead,end=end_str) # オーバーヘッド除去\n    if i%5 == 4:  # 5つごとに改行\n        print()\nこれを実行すると以下のようになります。ずいぶんと結果が分かりやすくなりました。\n0 --&gt; 8 --&gt; 16 --&gt; 24 --&gt; 32 --&gt; \n40 --&gt; 48 --&gt; 56 --&gt; 64 --&gt; 72 --&gt; \n80 --&gt; 88 --&gt; 96 --&gt; 104 --&gt; 112 --&gt; \n120 --&gt; 128 --&gt; 136 --&gt; 144 --&gt; 152 --&gt; \n160 --&gt; 168 --&gt; 176 --&gt; 184 --&gt; 192 --&gt; \n200 --&gt; 208 --&gt; 216 --&gt; 224 --&gt; 232 --&gt; \n240 --&gt; 248 --&gt; 256 --&gt; 264 --&gt; 272 --&gt; \n280 --&gt; 288 --&gt; 296 --&gt; 304 --&gt; 312 --&gt; \n320 --&gt; 328 --&gt; 336 --&gt; 344 --&gt; 352 --&gt; \n360 --&gt; 368 --&gt; 376 --&gt; 384 --&gt; 392 --&gt; \n400"
  },
  {
    "objectID": "programming2025/programming-5.html#字下げの注意",
    "href": "programming2025/programming-5.html#字下げの注意",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "Pythonでは、字下げによってコードブロックを表現するという、他の言語にはない際だった特徴があります。このおかげで、Pythonは非常に見やすいコードを書くことが可能になっています。ただ、インデントの幅を間違えるだけで、全く異なる意味になることがあるので注意が必要です。\nたとえば次のような三つのコードを考えてみましょう。\nfor i in range(10):\n    if i%2 == 0:\n        print(i) \nprint(\"Hello, World!\")  # ブロックの外\nfor i in range(10):\n    if i%2 == 0:\n        print(i) \n    print(\"Hello, World!\") # forブロックの中\nfor i in range(10):\n    if i%2 == 0:\n        print(i) \n        print(\"Hello, World!\")　# ifブロックの中\nこれらのコードは、3行目のインデントが異なるだけでそれ以外は全く同じですが、全て全く異なる挙動をします。3行目の所属するブロックが異なるからです。やっかいなのは、どれもエラーがでないことです。\nこのように、forやifブロックがあると、コーディング中にうっかりタブキーを一つ挿入すると、エラーが出ない上にコードを破壊してしまう可能性があるので、ブロックの字下げには十分に注意しなくてはなりません。特にブロックが入れ子になっている場合はこういった失敗に気づきにくいので注意しましょう。"
  },
  {
    "objectID": "programming2025/programming-5.html#その他の制御構文",
    "href": "programming2025/programming-5.html#その他の制御構文",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "forループは予め繰り返し回数が決まっている場合に便利ですが、繰り返し回数が予め決められない場合もあり、その場合にはwhileループを用います。whileループは指定した条件が成り立っているかぎりwhileブロック内のコードを繰り返し実行しますが、条件が不成立になるとループ処理を終了します。\nforループとの違いを明らかにするため、まず0から5までの整数を印字するプログラムをforループで書いてみましょう。\nfor i in range(6):\n    print(i)\n同じものをwhileループを使って書くと、次のようになります。\ni = 0   # ループカウンタの初期値を0に設定\nwhile i &lt;= 5:\n    print(i)    # iの値を印字\n    i += 1      # iの値を1増やす\n字下げした部分がwhileブロックであり、繰り返される部分です。whileブロック内の最後の行はiの値を1増やすコードであり、i=i+1の省略記法です(教科書のp85-86参照)。上記のコードでは、まずiの値を0に設定し、ループ内ではiの値を印字してから、iの値を一つ増やすことを繰り返しています。したがってiの値はwhileブロックが実行されるたびに1ずつ増えます。whileの後に指定した条件i&lt;=5は、ループ処理が継続されるための条件であり、これが成り立っている限りwhileブロックの処理が繰り返されます。よって、上記のコードでは、iは0,1,2,3,…と増加し、iが6になるとwhileブロックは実行されず、ループは終了します。forループとは違い、whileループではループカウンタの初期値や増加をプログラマがコーディングしなくてはならないことに注意してください。\n次に、10000より小さい3の累乗(3,9,27,…)を全て印字するプログラムをwhileループで書いてみましょう。作戦として、iの初期値に3を設定し、iを印字してからiに3を掛けるということを繰り返し、iが10000以上になったとき繰り返しをやめれば良さそうです。これを実装すると次のようになります。\ni = 3   # iの初期値を3に設定\nwhile i &lt; 10000:\n    print(i)    # iを印字\n    i *= 3      # iに3をかける\ni *= 3は、i = i * 3の略記法です(教科書p85)。このプログラムは、条件i &lt; 10000が成り立っている間のみ、iを印字してからiを3倍する操作を繰り返します。このようなプログラムは、10000未満の3の累乗がいくつあるか予めわからないかぎり、forループで書くのが難しいことに注意してください。\n\n\n\n少し複雑な処理になると、ループの中にループを作る必要が出てきます。これを二重ループと呼びます。ループはいくらでも入れ子にでき、三重ループ、四重ループなどと呼ばれます。良くあるパターンはforループの中にforループがあるタイプですが、whileループの中にforループを作ったり、forループの中にwhileループを作ったりなど、whileとforの組み合わせに制約はありません。\n複雑なコードを書くさい、いきなり二重ループや三重ループのコードを書かないようにしてください。これはデバッグが難しくなりがちだからです。そうではなく、まずは一番内側のループから作成し、それが正しく動作することを確認することから始めてください。内側のループが完成したら、外側にループを付け足して二重ループを作りましょう。この二重ループもうまく動作することが確認できたら、必要に応じて更にループを付け足し、三重、四重と入れ子の階層を深めていくようにしてください。\n上述のように内側から外側に向かってコーディングするとうまく行くことが多いですが、問題によっては、外側のループから内側に向かって作成したほうが作りやすい場合もあります。重要なのは、全体を一気にコーディングするのではなく、シンプルなコードから始めて、動作をテストしながら、徐々に入れ子の階層を深めていくべきだということです。\n一例として、1000より小さい素数を全て印字するプログラムを作ってみましょう。こういう場合、問題が複雑ですので、まずは与えられた一つの数字iが素数かどうか判定するプログラムを作ってみることから初めるべきです。次のコードは、491が素数かどうか調べるプログラムです。素数ならTrueを印字し、素数でないならFalseを印字します。\ni = 491     # iを491に設定\nj = 2\nwhile i % j != 0:\n    j += 1\n\n# iが素数ならTrue, さもなくばFalseを印字\nif i == j:\n    print(True)\nelse:\n    print(False)\nこのコードでは1行目でiに491を代入し、2-4行目において、iを割り切る最小の素因数を求めています。そのような素因数を求めるため、まずjの値を2に設定し、whileループ内でjの値を1ずつ増やしながらiがjで割り切れるかその都度調べています。\nwhileのあとの条件文で使われている!=は、「左辺と右辺の値が異なる」ことを表す二項演算子です。従って、このwhileループは、iがjで割り切れるまで繰り返されることになり、ループが終了した時点でjにはiの最小の素因数が代入された状態になります。\n最後に、最小の素因数jがもとの数iに等しければiは素数ですので、この性質を利用して、素数ならばTrue、素数以外ならばFalseを印字しています。\n次に、二重ループを作る準備として、上記のコードを、iが素数かどうかに応じてTrueかFalseかを印字するのではなく、素数ならばiを印字し、さもなくば何も印字しないコードに書き換えておきます。\ni = 491     # iを491に設定\nj = 2\nwhile i % j != 0:\n    j += 1\nif i == j:\n    print(i)    # Trueならiを印字\nこれで内側のループが完成しました。次に、iを2から1000まで1ずつ増やしながら全てのiについて上記の操作をするプログラムを作りましょう。そのためには、次のように、上記のコードの2行目以降をまるごと、forループの中に入れて二重ループを作ります。\nfor i in range(2,1000):\n    j = 2\n    while i % j != 0:\n        j += 1\n    if i == j:\n        print(i)    # Trueならiを印字\n上記コードの外側のforループでは、iを2から999まで1ずつ増やしながら2行目以降の処理を行っています。range(2,1000)は、2以上1000未満の整数列を与えるrangeオブジェクトであることに注意してください(教科書p129)。2行目以降は、先のプログラムと全く同じで、iが素数ならiを印字し、さもなくば何も印字しません。これで目的が達成できました。\n\n\n\nbreakはループ処理を中断してループの外に出るための命令を表します。通常ループの中で条件分岐と組みあせわて使います。特に、forループの中でbreakを使うと、繰り返し回数の上限は決まっているが、途中でループを終了する場合もあるようなプログラムを作ることができます。\nたとえば、breakを使うと、素数を求めるプログラムの内側のループをforで実装できます。\nfor i in range(2,1000):\n    for j in range(2,i+1):    # jを2からiまで増やす\n        if i % j == 0:\n            break\n    if j == i:\n        print(i)\n上記のコードでは、iがjで割り切れた時点で内側のforループの処理を終了します。内側のループでrangeオブジェクトの範囲が2からiまでになっていることに注意してください。break文でループを終了すると、ループカウンタの値はbreakが実行された時点での値のままになります。従って、内側のループが終了した時点で、jにはiの最小の素因数が代入された状態になります。\nbreakはwhileと組み合わせることも良くあります。特に、whileの条件をTrueに設定した次のようなループは永遠に条件が成立する(==True)ため、無限にwhileブロックが実行され、終了することがありません。このようなループを無限ループと呼びます。\nwhile True:\n    # ここに書かれた処理は\n    # 無限に繰り返される\nこういったループには、必ずループブロック内部に特定の条件が満たされた場合にbreakで脱出する処理を設ける必要があります。\nbreakは、breakを含む一番内側のループのみ終了させることに注意しましょう。入れ子ループを二つ以上ジャンプするような構文はありません。なお、ループ処理を1回分だけスキップするcontinueという命令文もあります。経験上、continueを使う機会は多くありませんので、説明を割愛します(教科書のp136参照)。\n\n\n\nPythonにはfor-else構文という、独特の制御構文があります。これは、通常のforブロックに加えてelseブロックを持ちます。elseブロックには、breakが実行されずにforが最後まで処理された場合にのみ、追加で実行されるべき処理を書きます。for-elseはなくても特に困らない構文ですが、これを使うと分かりやすいコードを書ける場合があります。\nたとえば、for-else文を使うと、1000未満の素数を求めるプログラムは、次のようにスマートに書けます。\nfor i in range(2,1000):\n    for j in range(2,i):    # jを2からi-1まで増やす\n        if i % j == 0:\n            break           # ループを抜ける\n    else:\n        print(i)  # iを印字\nここで、内側のループのrangeオブジェクトの範囲が2からi-1までであることに注意しましょう。else節は、breakが実行されなかったときのみ、すなわち、iより小さいどのjでも割り切れなかったときのみ実行されます。従って、素数のみが印字されることになります。\n\n\n\nif-else構文では、ある条件が成り立っているときと、そうでないときの処理を指定できました。一方で、\n\nAならばXを実行\nAでないとき、BならばYを実行\nAでもBでないとき、Zを実行\n\nというように、二つ以上の条件を使って処理を分岐させたいときは、elif構文を使います。\nでは、1000未満の自然数iについて、iを印字するとともに、iが2で割り切れるものは2で割った商を、2で割り切れないが3で割り切れるものは3で割った商を、2でも3でも割り切れない場合はXを合わせて印字するようなプログラムを作りましょう。まずは、if-else文で書いてみます。\nfor i in range(1,1000):\n    if i % 2 == 0:\n        print(i,i//2)   # 2で割れるならi//2を印字\n    else:\n        if i % 3 == 0:\n            print(i,i//3)   # 3で割れるならi//3を印字\n        else:\n            print('X')\ni//2は整数iを2で割った商です(教科書p81)。このコードでは、１つめのif-else文のelseブロックの中にさらに入れ子でif-else文が入っていることに注意してください。\n次のように、elif構文を使うと、これと同じことが、入れ子を使わないで記述できます。\nfor i in range(1,1000):\n    if i % 2 == 0:\n        print(i,i//2)   # 2で割れるならi//2を印字\n    elif i % 3 == 0:\n        print(i,i//3)   # 3で割れるならi//3を印字\n    else:\n        print('X')\nelifはelse:ifと本質的に同じ意味ですが、インデントが変化していることに注意してください。見かけ上、入れ子構造がなくなっています。\nこのコードでは、6の倍数は、2でも3でも割り切れますが、2で割った商のみが印字されることに注意してください。elif節はif節が成り立たない場合のみ実行されるので、if節とelif節の条件が両方成り立っている場合は、ifブロックのみが実行されます。\nelifは幾つでも好きなだけ連結できます。次のコードは、2や3では割り切れないが、5で割り切れる数については5で割った商を印字します。\nfor i in range(1,1000):\n    if i % 2 == 0:\n        print(i,i//2)   # 2で割れるならi//2を印字\n    elif i % 3 == 0:\n        print(i,i//3)   # 3で割れるならi//3を印字\n    elif i % 5 == 0:\n        print(i,i//5)   # 5で割れるならi//5を印字\n    else:\n        print('X')\nif-else構文でこのようなプログラムを作ると、入れ子が深くなってしまって大変読みにくくなってしまいます。elif構文はこうした問題を解決してくれます。一般にコードを作成するときは、効率性（コードの短さや速さ）だけでなく、読みやすさ（可読性）に注意してコーディングするようにしましょう。"
  },
  {
    "objectID": "programming2025/programming-5.html#論理演算子",
    "href": "programming2025/programming-5.html#論理演算子",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "if、elif、while等の条件式を用いる制御構文では、以下のような論理演算子を用いて複数の条件式を組み合わせた条件式や、条件式の否定文を用いることができます。\n\n\nand演算子は日本語の「かつ」に相当し、条件式A and 条件式Bは条件式Aと条件式Bがともに成立(すなわち値がTrue)のときのみTrueになるような条件式を表します。たとえば、次のコードは、100未満の自然数のうち、2と3の公倍数(つまりは6の倍数)のみを印字します。\nfor i in range(1,100):\n    if i % 2 == 0 and i % 3 == 0:\n        print(i)\n条件式A and Bの値は、条件式A、Bの値に応じて次のように決まります。\n\n\n\nA\nB\nA and B\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nor演算子は日本語の「または」に相当し、条件式A or 条件式Bは条件式Aと条件式Bのうち少なくともどちらか一方がTrueであればTrueになるような条件式を表します。たとえば、次のコードは、100未満の自然数のうち、2の倍数と3の倍数を全て印字します。\nfor i in range(1,100):\n    if i % 2 == 0 or i % 3 == 0:\n        print(i)\n条件式A or Bの値は、条件式A、Bの値に応じて次のように決まります。\n\n\n\nA\nB\nA or B\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nnot演算子は条件式の否定(〜でない)を表し、not 条件式Aは条件式AがFalseのときTrueになる条件式を表します。たとえば次のコードは、100未満の自然数のうち、3で割り切れないものを全て印字します。\ni = 1\nwhile not i &gt;= 100:\n    if not i % 3 == 0:\n        print(i)\n    i += 1\n上のコードは、次のコードと全く同じ意味であることに注意しましょう。\ni = 1\nwhile i &lt; 100:\n    if i % 3 != 0:\n        print(i)\n    i += 1\nこのようにnot演算子を使った条件式は、多くの場合notを使わない条件式に書き換えることができます。notを多用すると条件式が読みにくくなるので、使用は最小限に留めたほうが良いでしょう。例えば、以下のようなコードはnotを使わずに書くのが難しい例です。\n# ブラックリスト以外を印字するコード\nblack_list = [12,34,56,78,91]\nfor i in range(1,100):\n    if not i in black_list:\n        print(i)\nこのコードは、100未満の自然数のうち、リストblack_listに含まれていないもののみを印字します。ここでinは、特定の要素がリストに含まれているかどうかをチェックする演算子であり、A in BはAがリストBに含まれていればTrueとなります。したがってnot A in BはAがリストBに含まれていないときのみTrueになります。ちなみに、not A in BはA not in Bと書くこともできます。\n教科書のセクション3.4には、論理演算子のより高度な使い方が解説されています。興味のある方はチェックしておきましょう。\n\n\n\n上記の「ブラックリスト以外を印字するコード」をnotやnot inを使わずに書き直してください。(ヒント:if-else構文とpassを使います。)"
  },
  {
    "objectID": "programming2025/programming-5.html#まとめ",
    "href": "programming2025/programming-5.html#まとめ",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "本講義では、以下のことを学びました。\n\nリストの構造\nシャローコピー\nディープコピー\nスライス記法\nリストの演算\nループ処理\nrangeオブジェクト\n条件分岐\n論理演算子\n\n今回の講義では、リストや制御構文のごく基本的な事柄しか扱えませんでした。リストや制御構文には非常に多くの押さえておくべき事柄がありますので、教科書のセクション4とセクション6を良く読んでおきましょう。"
  },
  {
    "objectID": "programming2025/programming-5.html#参考書",
    "href": "programming2025/programming-5.html#参考書",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "『High Performance Python: Practical Performant Programming for Humans』(M. Gorelick, I. Ozsvald著) (2020) O’Reilly. ISBN-13 : 978-1492055020.\nハイパフォーマンスPython第2版(M. Gorelick, I. Ozsvald著, 中山光樹(訳)) (2023) O’Reilly. ISBN-13: 978-4873119908.\n\n上記参考書はリストや辞書の挙動について詳しいです(2は1の翻訳)。中〜上級者向け。"
  },
  {
    "objectID": "programming2025/programming-5.html#補遺",
    "href": "programming2025/programming-5.html#補遺",
    "title": "第5回 データ型と制御構文",
    "section": "",
    "text": "Pythonのビルトインデータ型には、__sizeof__というメソッドが備わっており、getsizeofはこれを呼び出しています。しかし、getsizeofの戻り値は__sizeof__の戻り値と常に同じではなく、前者はデータ型によってはオーバーヘッドにガベージコレクションのためのメモリ領域16バイトを含むことがあります。本稿では、オーバーヘッドの大きさには関心がないので、getsizeofと__sizeof__の違いについては論じません。\n参考までに、筆者の環境において幾つかの単純なオブジェクトに対する両者の出力を列挙しておきます。\n\n\n\nオブジェクト\ngetsizeof\n__sizeof__\n\n\n\n\n0\n24\n24\n\n\n\"\"\n49\n49\n\n\n[]\n56\n40\n\n\n()\n40\n24\n\n\n{}\n64\n48\n\n\ndict()\n232\n216\n\n\nset()\n216\n200\n\n\n\n\n\n\n\nリストがどのように要素オブジェクトへの参照を格納しているかは、リストオブジェクトを作成するCPythonのソースコードを見ると分かりやすいです。こちらはちょっと細かい話なので別ファイルにします。\n長いリストにおいてpopメソッドを使うとき、リストの末尾からpopするよりも、先頭からpopするほうが、はるかに遅いことが知られています。なぜそのような速度の差が生じるのか、考察してください。リストはpopによって配列に隙間が出来たときに何をしなければならないか、そしてそれにはどのくらいの時間がかかるか考察してみてください。\nrangeオブジェクトは、要素の参照を格納していません。様々な長さのrangeオブジェクトを作成し、占有メモリのサイズを比較してみてください。なぜPython3が等差数列リストではなく、rangeオブジェクトを使用することを選んだのか、考察してみてください。\n講義本編では、リストのサイズを一つずつ増やしながら、リストの占有メモリサイズが要素数に対して線形に増えていくことを確認しました。一方、リストのappendメソッドによって、既存のリストに一つずつ要素を加えていくときは、占有メモリサイズは線形には増加して行かず、興味深いパターンを示します。どのようなパターンになるのか研究し、なぜそのようになっているのか考察しましょう。"
  },
  {
    "objectID": "programming2025/programming-7.html",
    "href": "programming2025/programming-7.html",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "第7回 標準ライブラリ(2)―辞書、集合\n\n辞書(dict)\n辞書の更新\nループでの挙動\n\n練習1\n\nハッシュ可能オブジェクト\nハッシュ表\nビットマスク\n\n練習2\n\n辞書のリサイズ\n集合\n集合演算\n\n練習3\n\nまとめ\n参考書\n宿題(ホームワーク)\n課題(アサインメント)\n\n\n\n\n辞書(ディクショナリとも呼びます)型はRのリストに似たデータ構造で、次の特徴を持ちます。\n\nイテラブル\nミュータブル\n「キーオブジェクト」と「値オブジェクト」のペアを保存する\nハッシュ可能オブジェクトだけをキーに持てる\n任意のオブジェクトを値に持てる\nキーを指定して値にアクセスする\nインデックス参照やスライス記法は受け付けない\n\n辞書はPythonにおいて重要であるだけでなく、ハッシュテーブルという計算機科学において非常に重要なデータ構造なので、詳しく説明します。\nリストは、要素を列挙したものでした。リストは本質的に順序集合です。\n&gt;&gt;&gt; x = ['foo','bar','baz']\n&gt;&gt;&gt; print(x[1])\nbar\n一方、辞書は要素の順序集合ではなく、オブジェクトのペアの集合です。ペアを構成するオブジェクトは、キーおよび値と呼ばれます。\n辞書を説明するには、実際の辞書の例が分かりやすいです。\n\n\n\n英単語\n意味\n\n\n\n\nyep\nはい\n\n\nyes\nはい\n\n\nyet\nしかし\n\n\n\nといった(あまり役に立たない)英和辞書があったとします。この辞書では、英単語から意味を検索できるが、その逆(意味から英単語を検索)はできないとします。\n英単語がキー、意味が値に相当します。キーは一意でなくてはなりませんが、値は重複があっても構いません。\n実際にこの辞書を作るには幾つかのやり方がありますが、そのうち二つを紹介しておきます。他の作成方法については教科書のセクション6.3.1を見てください。\n&gt;&gt;&gt; x = {'yep':'はい','yes':'はい','yet':'しかし'}\n&gt;&gt;&gt; x\n{'yep': 'はい', 'yes': 'はい', 'yet': 'しかし'}\n&gt;&gt;&gt; x = dict(yep='はい',yes='はい',yet='しかし')\n&gt;&gt;&gt; x\n{'yep': 'はい', 'yes': 'はい', 'yet': 'しかし'}\n1番目の方法では、中括弧を使って辞書を作っています。中括弧の中にはキーと値のペアをコンマで区切って列挙します。キーと値はコロンで区切ります。\n2番目の方法では、dictという関数を明示的に呼び出して辞書を作成しています。関数には、key=valueという形式でキーと値のペアを渡します。こちらの形式では、キーにクォーテーションは必要ないので注意してください。\nちょうどリストにおいてインデックスから要素を取得したように、キーを指定すれば値を取得できます。\n&gt;&gt;&gt; x['yep']\n'はい'\n&gt;&gt;&gt; x['yet']\n'しかし'\nキーの一覧、値の一覧、キーと値のペアの一覧を取得するには、keysメソッド、valuesメソッド、itemsメソッドを使います。\n&gt;&gt;&gt; x.keys()\ndict_keys(['yep', 'yes', 'yet'])\n&gt;&gt;&gt; x.values()\ndict_values(['はい', 'はい', 'しかし'])\n&gt;&gt;&gt; x.items()\ndict_items([('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')])\n上記のようにキーの一覧、値の一覧、ペアの一覧はdict_keys、dict_values、dict_itemsという特殊なイテラブルデータ型で返されます。これは、適宜リストや集合、タプルに変換して用いることができます。\nたとえばリストに変換するには、関数listを使います。\n&gt;&gt;&gt; y = list(x.keys())\n&gt;&gt;&gt; y\n['yep', 'yes', 'yet']\n&gt;&gt;&gt; z = list(x.values())\n&gt;&gt;&gt; z\n['はい', 'はい', 'しかし']\n&gt;&gt;&gt; a = list(x.items())\n&gt;&gt;&gt; a\n[('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')]\n\n\n\n辞書の内容を更新するもっとも基本的な方法は、代入です。たとえば、xの'yep'の意味を'うっす'に変更したいときは、次のようにします。\n&gt;&gt;&gt; x['yep'] = 'うっす'\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし'}\nこのような代入操作において、指定されたキーが存在する場合は、上記のように既存の値が更新されます。指定されたキーがまだ存在しない場合は、新たにキー：値ペアが挿入されます。\n&gt;&gt;&gt; x['yeah'] = 'うん'\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし', 'yeah': 'うん'}\n特定のキー：値ペアを削除したいときは、del文を用います。\n&gt;&gt;&gt; del x['yeah']\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし'}\n複数の値を一挙に更新したい場合は、updateメソッドを使います。例えば、辞書xを辞書yで上書き更新するには、次のようにupdateメソッドを用います。\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし'}\n&gt;&gt;&gt; y = {'yep':'はーい','yet':'まだ','no':'いいえ'}\n&gt;&gt;&gt; y\n{'yep': 'はーい', 'yet': 'まだ', 'no': 'いいえ'}\n&gt;&gt;&gt; x.update(y)\n&gt;&gt;&gt; x\n{'yep': 'はーい', 'yes': 'はい', 'yet': 'まだ', 'no': 'いいえ'}\nこのようにx.update(y)と書くことにより、yの要素(キー：値ペア)ですでにxに存在するものは置き換えられ、存在しないものは新たに追加されます。\n\n\n\n辞書をリストの代わりにループインデックスの範囲として指定すると、ループインデックスにはキーだけが代入されます。つまり、次の2つのコードは全く同じ意味です。\n# %%\n# xは辞書\nfor i in x.keys():\n    print(i)\n# %%\nfor i in x:\n    print(i)\nキーと値の両方を使いたいときは、次のようにしなくてはなりません。\n# %%\nx = {'yep':'はい','yes':'はい','yet':'しかし'}\nfor i in x.items():\n    print(i)\nこのように書くと、ループインデックスにはループごとにキーと値のタプルが代入されます。\n# 出力\n('yep', 'はい')\n('yes', 'はい')\n('yet', 'しかし')\nこのようループインデックスにタプルを返すイテラブルの場合、次のようなループインデックスへのアンパック代入がサポートされています。\n# %%\nx = {'yep':'はい','yes':'はい','yet':'しかし'}\nfor i,j in x.items():\n    print(i + ' --&gt; ' + j)\n# 出力\n\nyep --&gt; はい\nyes --&gt; はい\nyet --&gt; しかし\n\n\n全ての小文字アルファベットをキー、対応する大文字アルファベットを値とする辞書letcapを作成しなさい。また、辞書letcapから、キーと値を入れ替えた辞書、すなわち大文字をキー、小文字を値とする辞書capletを作成しなさい。\n\n\n\n\n任意のオブジェクトが値になれますが、キーに指定できるのは、ハッシュ可能なPythonオブジェクトのみです。\nあるアルゴリズムによってオブジェクトを整数に変換することをハッシュ化と呼びます。ハッシュ化によって得られる数値をハッシュ値と呼び、当のアルゴリズムをハッシュ関数と呼びます。全てのPythonオブジェクトがハッシュ化できるわけではなく、ハッシュ化できるオブジェクトをハッシュ可能(hashable)であると言います。ビルトインイミュータブル型のオブジェクトはほとんどすべてハッシュ可能ですが、ミュータブル型はハッシュ不可能です。\nハッシュ化は、ビルトイン関数のhashによって行うことができます。\n&gt;&gt;&gt; hash(1)\n1\n&gt;&gt;&gt; hash(\"foo\")\n2930000467231731134\n&gt;&gt;&gt; hash((1,2,3))\n529344067295497451\n&gt;&gt;&gt; hash(range(10))\n-7546101314042312252\n&gt;&gt;&gt; hash([1,2,3])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n上記の例では、リスト[1,2,3]がハッシュ不可能なため、エラーが出ています。\nタプルはイミュータブルですが、全ての要素がハッシュ可能な場合にのみハッシュ可能です。よって、たとえば次のようなタプルはハッシュ不可能です。\n&gt;&gt;&gt; x = (1,2,[3])\n&gt;&gt;&gt; hash(x)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nしたがって、このようなタプルは辞書のキーに指定することができず、エラーが出ます。\n&gt;&gt;&gt; x = {}\n&gt;&gt;&gt; x[(1,2,[3])]=123\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nハッシュ関数の特徴は、\n\n==演算子でTrueになる二つのオブジェクトは同じハッシュ値をもつ\n異なるオブジェクトが同じハッシュ値を持ってもよい(ただしその確率は通常小さい)\n\nということです。たとえば、Pythonのハッシュ関数は、-1と-2に同じハッシュ値を返します。\n&gt;&gt;&gt; hash(-1) == hash(-2)\nTrue\nこのようにハッシュ化は不可逆変換です。ハッシュ値からもとのオブジェクトを復元することは通常できません。\nなお、実際には、hash関数が使うアルゴリズムは、ハッシュ化するオブジェクトの型に依存しています。ハッシュ可能なデータ型は、すべて__hash__というハッシュ値を返すメソッドを持っていて、関数hashはこのメソッドを呼び出しているだけです。それは次のようにして確認できます。\n&gt;&gt;&gt; x = \"foo\"\n&gt;&gt;&gt; hash(x)\n2419985339487190468\n&gt;&gt;&gt; x.__hash__()\n2419985339487190468\n&gt;&gt;&gt; hash(x) == x.__hash__()\nTrue\nまた、Pythonのハッシュ関数は、セキュリティー上の理由から、インタープリタを起動するごとに異なるハッシュ値を返すようになっています。値の同じオブジェクトにはいつも同じハッシュ値を返すようにするには、環境変数PYTHONHASHSEEDに0～2**32-1の範囲の整数(4バイト符合なし整数)を設定してAnacondaプロンプト(もしくはVS Code)を再起動してください。\n\n\n\n辞書の構造は少し不思議です。というのも、なぜPythonは、x['yep']と書くだけで、すぐにキー'yep'に対応する値を発見することができるのでしょうか？もし辞書がキー：値ペアを順番に格納しているだけだと、Pythonはキー'yep'を見つけるのに、いちいち全てのキー集合のなかから'yep'を検索しなくてはなりません。これだと、辞書が大きくなるに従って、検索に大きな時間を要するようになってしまいます。Pythonはこの問題を、ハッシュ表という構造を用いて解決しています。\nそれでは、次のコードを例に、辞書を作成する際に何が起きているのかを見ていきましょう。\n&gt;&gt;&gt; x = {'foo':123,'bar':456,'baz':789}\n上のコードを実行すると、筆者の処理系では辞書xのために232バイトのメモリ領域が確保されます（具体的なバイト数は処理系やPythonのバージョンに依存します）。\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getsizeof(x)\n232\nこの232バイトのうち、104バイトはオーバーヘッドで、本質的なのは残り128バイトです。この128バイトは、ハッシュ表を格納しています。ハッシュ表の役割は、キーオブジェクトを、値オブジェクトに対応付けることです。\n最近のバージョンのPythonでは、ハッシュ表はインデックス配列とエントリー表という二つの部分から構成されています。インデックス配列は、1区画1バイトからなる8区画の一続きのメモリ領域で、合計8バイトを占有しています。\n一方エントリー表は、1スロット(区画)24バイトからなる5スロットの一続きのメモリ領域で、合計120バイトを占有しています。さらに一つのスロットは三つの小区画に分かれていて、一つの小区画は8バイト占めています。この三つの小さい区画をハッシュ値区画、キー区画、値区画と呼ぶことにします。\nエントリー表の各スロットには、xを構成するキーや値の情報が格納されています。以下、Pythonがどのようにそれらの情報をエントリー表に格納していくか説明します。\n\n\n\ndict\n\n\nまず、Pythonは第一のキーオブジェクト'foo'をハッシュ化し、そのハッシュ値を0～7の整数に変換します。この変換は、ハッシュ値の下位3ビットを取り出すことで行っています。3ビットの整数は0～7の範囲をとることに注意してください。\n&gt;&gt;&gt; x = hash(\"foo\")\n&gt;&gt;&gt; bin(x)\n'0b111111111111110001101001010101111001010101111011001011001010100'\n&gt;&gt;&gt; x & 0b111   # xの下位3ビットを取得\n4\nなおここで、& 0b111というのが任意の数の下位3ビットを取り出す操作になっていますが、これについては後で解説します。ここでは、確かにbin(x)の下位3文字が100、つまり2進数で4になっていることを確認してください。\nその後Pythonは、キー'foo'の参照、値123の参照、ハッシュ値(hash(\"foo\")の値)をエントリー表第0スロットのキー区画、値区画、ハッシュ値区画に記録します。キーの参照、値の参照、ハッシュ値はどれも8バイトなので、スロットは24バイト消費します。\n次に、“foo”のハッシュ値の下位3ビットは0b100=4でしたので、Pythonは、インデックス配列の第4区画に、エントリー表での'foo'のスロット番号0を記録します。\nPythonは、同じことを、'bar'と'baz'に対しても行います。これらのハッシュ値と下位3ビットを調べてみましょう。\n&gt;&gt;&gt; hash(\"bar\") & 0b111\n7\n&gt;&gt;&gt; hash(\"baz\") & 0b111\n2\n\"bar\"と\"baz\"の情報はエントリー表の第1、第2スロットに順番に収められます。また、hash(\"bar\")の下位3ビットが7であったので、インデックス配列の第7区画に\"bar\"のスロット番号である1をセットします。同様にhash(\"baz\")の下位3ビットが2であったので、インデックス配列の第2区画に”baz”のスロット番号2をセットします。\nこのようにして、Pythonは図のようなハッシュテーブルを完成させます。\nPythonが、完成した辞書からキー'foo'に対応する値123を取り出す際は、それを登録したときとほぼ同じ方法を使います。\nまず、'foo'をハッシュして下位3桁をみます。するとその値は4ですので、インデックス表の4番目を見ます。そこが空っぽであればPythonはエラーを出しますが、番号が書いてあった場合は、その番号に対応するエントリー表のスロットをみます。そのスロットに記録されているキーが、今探しているキーと一致すれば、対応する値を返して作業を終了します。\n上記の作業の作業量は、ハッシュテーブルにエントリーされているキー：値ペアの数に依存せずほぼ一定であるため、辞書の操作は登録されている要素(キー：値ペア)の数が大きくなっても、比較的高速に行うことができるのです。\nなお、ハッシュ化して下3桁をとると、複数のキーが同じインデックスになってしまうことがあります。これをハッシュ衝突と呼びます。二つのキーでハッシュ衝突が起きると、後から登録しようとしているキーに対しては、あるアルゴリズムで別のインデックスを振られます。\nここから先は専門的な話になりますので詳細は説明しませんが、ここで使われている空きインデックスを探すアルゴリズムはリニアプロービングという単純なアルゴリズムです。関心のある方は参考書の『High Performance Python: Practical Performant Programming for Humans』(Gorelick & Ozsvald, 2020)をご覧ください。ここではハッシュ衝突の概念だけ押さえておきましょう。\n\n\n\nさてここで話が少しそれますが、ハッシュ値から下3桁をとりだした操作は教養の観点から言って重要ですので、少し詳しく説明をしておきます。ハッシュ値のところで行ったように、たとえば整数123から下位3ビットを取り出すには、次のようにします。\n&gt;&gt;&gt; 123 & 0b111\n3\nまず、0b111は、接頭辞0bがついているので、7を2進数表現したものであることにしてください。&演算子は、bitwise ANDというビット演算子の一種で、二つのビット配列がともに1になっているビットだけを1にし、残りの全てのビットを0にした数字を返します。\n&gt;&gt;&gt; x = 0b1010 & 0b1001\n&gt;&gt;&gt; x\n8\n&gt;&gt;&gt; bin(x)\n'0b1000'\n&gt;&gt;&gt;\nしたがって、どのような整数でも、0b111とのbitwise ANDをとれば、下位3ビット以外はすべて0になり、下位3ビットだけがとりだせることになります。このように、ビット列との&をとって特定のビットだけを抽出することを、ビットマスクをかけるといいます。このとき、ビット抽出に使われる0b111のような数字をビットマスクと呼びます。情報科学で頻繁に使われる概念なので覚えておきましょう。\nなおハッシュ値が負の値の場合、bin関数が表示する2進数表記は、実際にハッシュ値がメモリに記録されるときのビット配列とは異なります。bin(x)が返すのは、xの絶対値の2進数表現にマイナス符合を付けたものであり、xのメモリ上でのビット配列ではありません。ビットマスクはbin関数の戻り値では無く、メモリ上でのビット配列、つまり2の補数表現に対して取られます。たとえば、“bar”を関数hashでハッシュ化すると、筆者の環境では次のように負の値になり、その下3ビットは001、つまり1となります。\n&gt;&gt;&gt; bin(hash('bar'))\n'-0b101111000110111000001100101111000011111100001110110110111001'\nところが、’bar’のハッシュ値と0b111のANDを取ったものは、上で示したように、7でした。この食い違いは、ハッシュ値が負である為に置きます。ハッシュ値が負のときのビット演算の結果は、2の補数表現で考えなくてはいけません。\n初回の講義の補遺において紹介したint_to_bitsを使ってハッシュ値の2の補数表現を求めておきましょう。\n# %%\nint_to_bits(hash('bar'),8)\n# 出力\n11110100 00111001 00011111 00110100 00111100 00001111 00010010 01000111\nこのように、確かに下3桁は0b111、つまり7になっていることが分かります。\nbitwise演算子には、AND以外にも様々なものがあり、ビット単位での操作を可能にします。ここでは取り上げませんが、非常に重要ですので、教科書のセクション3.5を良く読んでおきましょう。\n\n\n試作品段階ですが、辞書の内部構造を表示するモジュールinsdictを開発中です。興味のある方は仮想環境にインストールして使ってみてください。ただし、インタープリタをコンパイルしたのと同じCコンパイラが必要です。Windowsの場合は、Microsoft Visual Studioが必要です。Linuxの場合はGCCが必要です。\n\n\n\n\nさて、辞書に話を戻します。辞書のエントリーが増えてきて、インデックス表が埋まってくると、だんだんとハッシュ衝突の確率が上がってきます。衝突が多いほど、登録にも検索にも時間がかかるようになります。ですので、衝突を最小限に抑えるために、インデックス配列の区画数はエントリー表よりもすこし大きめに確保してあります。具体的には、エントリー表のスロット数は、インデックス配列の長さの約2/3になっています。\nエントリー表が満杯になった状態で次のキーが登録されると、インデックス配列とエントリー表が同時に拡張されます。このとき、新しくインデックス配列とエントリー表が作成され、既存のインデックス配列とエントリー表の内容がコピーされます。\n新しく作成されたエントリー表のサイズは10区画、インデックス表のサイズは16区画になります。再びエントリー表が一杯になると、再度拡張がおき、今度はエントリー表は21区画、インデックス表は32区画になります。このようにして、エントリー表が一杯になるたびに、おおよそ倍々にインデックス表とエントリー表は拡張されていきます。\n理論的には、辞書の要素が増えるにつれ、オーバヘッドを除く占有バイト数は次のように変化していきます。\n\n\n\n要素数\nスロット数\n配列長\nエントリー表サイズ\n配列サイズ\n合計\n\n\n\n\n1~5\n5\n8\n24x5=120\n1x8=8\n128\n\n\n6~10\n10\n16\n24x10=240\n1x16=16\n256\n\n\n11~21\n21\n32\n24x21=504\n1x32=32\n536\n\n\n22~42\n42\n64\n24x42=1008\n1x64=64\n1072\n\n\n43~85\n85\n128\n24x85=2040\n1x128=128\n2168\n\n\n86~170\n170\n256\n24x170=4080\n2x256=512\n4592\n\n\n171~341\n341\n512\n24x341=8184\n2x512=1024\n9208\n\n\n\n上記の表で、各列の意味は以下の通りです。\n\n\n\n列\n意味\n\n\n\n\nスロット数\nエントリー表のスロット数\n\n\n配列長\nインデックス配列の区画数\n\n\nエントリー表サイズ\nエントリー表の総バイト数\n\n\n配列サイズ\nインデックス配列の総バイト数\n\n\n合計\nエントリー表の総バイト数＋インデックス配列の総バイト数\n\n\n\nちょっと細かいことですが、上の表でインデックス配列は、辞書が小さい間は、1区画1バイトを占めていますが、エントリー表のスロット数が85から170に増加したときに1区画あたり2バイトに増加します。これは、インデックス配列のそれぞれの区画は、 符号付き1バイト整数(-128～+127)を表すのに使っており、128以上のスロットナンバーを記録できないからです。\n本当に上記のようなことが起きているかを確かめるためのコードを書いてみましょう。からっぽの辞書に一つずつキー：値ペアを追加していき、2**8個までペアを追加することにします。占有バイト数が変化したときだけ出力することにします。\nimport sys\n\nx = dict()\nprev_size = 0     # 前回のハッシュ表サイズ\ncurr_size = 0     # 今回のハッシュ表サイズ\nmin_size = 128    # 最小のハッシュ表サイズ\noverhead = sys.getsizeof(x) - min_size # オーバーヘッド\n\nfor i in range(1,2**8+1):\n    x.update({i:i})\n    curr_size = sys.getsizeof(x) - overhead\n    if curr_size != prev_size:\n        print(str(i) + ' --&gt; ' + str(curr_size))\n    prev_size = curr_size\n# 出力\n1 --&gt; 128\n6 --&gt; 256\n11 --&gt; 536\n22 --&gt; 1072\n43 --&gt; 2168\n86 --&gt; 4592\n171 --&gt; 9208\n1列目は辞書のエントリー数、2列目はオーバーヘッドを除いたハッシュ表の占有バイト数です。\n下の図は、エントリ数とともに辞書の占有メモリがどのように増えていくかを表した図です。オーバーヘッドは含んでいません。\n\n\n\ndict-mem\n\n\n具体的なバイト数は処理系(64bitか32bitか)に依存し得ます。64ビットOSなのに結果が上の表と一致しないとすれば、Pythonのバージョンがかなり古いか、あるいはものすごく新しい可能性があります。その場合は、試しに自分の使っている処理系ではどのようにハッシュ表がメモリを使っているのか色々と実験して調べてみてください。\n\n\n\n集合型は、辞書やリストに比べると使う機会が少ないと思いますので、説明は簡単にしておきます。集合は、内部構造をもたないオブジェクトの集まりです。集合は、値のないキーだけの辞書と思ってほぼ間違いはありません。以下のような特徴を持ちます。\n\nイテラブル\nミュータブル\nインデックス・スライス参照不可\nキー参照不可\nハッシュ可能オブジェクトだけを要素に持てる\n算術演算不可\n集合演算可\n\n集合を作るやり方は主に二通りあります。一つは、中かっこ内に要素を列挙する方法、もう一つは、関数setにイテラブルオブジェクトを渡す方法です。\n&gt;&gt;&gt; x = {'foo','bar','baz'}\n&gt;&gt;&gt; x\n{'baz', 'foo', 'bar'}\n&gt;&gt;&gt; y = set([1,2,3])\n&gt;&gt;&gt; y\n{1, 2, 3}\n集合は辞書キーと同じで、重複が許されないことに注意してください。これを利用して、文字列などから、文字列に含まれている文字の集合を作成できます。\n# 文字の一覧を取得\n&gt;&gt;&gt; z = set(\"foo bar baz\")\n&gt;&gt;&gt; z\n{'a', 'f', 'b', ' ', 'r', 'o', 'z'}\n集合の要素は辞書のキーと同じでハッシュ可能でないといけません。\n&gt;&gt;&gt; x = {[3],5}\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nループでの挙動は、辞書と変わりありません。\n&gt;&gt;&gt; x = {'a','b','c'}\n&gt;&gt;&gt; x\n{'b', 'a', 'c'}\n&gt;&gt;&gt; for i in x:\n...     print(i)\n...\nb\na\nc\n\n\n\nリストや辞書でなく、集合を用いるのは、集合演算を用いたいときでしょう。集合型には様々な集合演算が定義されています。\n\n\n\nメソッド\n記号\n機能\n\n\n\n\nx.difference(y)\n-\nxとyの差集合\n\n\nx.intersection(y)\n&\nxとyの積集合\n\n\nx.union(y)\n|\nxとyの和集合\n\n\nx.issubset(y)\n&lt;=\nxがyの部分集合ならTrue\n\n\nx.issuperset(y)\n&gt;=\nyがxの部分集合ならTrue\n\n\n\nたとえば、和集合はunionメソッドもしくは|演算子で作成できます。\n&gt;&gt;&gt; x = {'a','b','c'}\n&gt;&gt;&gt; y = {'c','d','e'}\n&gt;&gt;&gt; x.union(y)\n{'b', 'a', 'd', 'e', 'c'}\n&gt;&gt;&gt; x | y   # 同じ意味\n{'b', 'a', 'd', 'e', 'c'}\n上記の集合演算を自分で色々と試してみましょう。\n\n\n文字列”pythonlanguage”に含まれる文字のうち、“helloworld”と”foobarbaz”のどちらか一方にのみ含まれている文字の集合を求めなさい。\n\n\n\n\n今回の講義では、以下のことを学びました。\n\n辞書の仕組み\nハッシュ表\nビットマスク\n集合型\n集合演算\n\n辞書はPythonのデータ型の中でも非常に重要な役割を持つものですので、教科書の対応する範囲を良く読み、挙動を理解するようにしましょう。\n\n\n\n\n『High Performance Python: Practical Performant Programming for Humans』(M. Gorelick, I. Ozsvald著) (2020) O’Reilly. ISBN-13 : 978-1492055020.\n『CPython Internals: Your Guide to The Python 3 Interpreter』(A. Shaw, The real python.com tutorial team)(2021) Real Python. ISBN-13: 978-1775093343."
  },
  {
    "objectID": "programming2025/programming-7.html#辞書dict",
    "href": "programming2025/programming-7.html#辞書dict",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "辞書(ディクショナリとも呼びます)型はRのリストに似たデータ構造で、次の特徴を持ちます。\n\nイテラブル\nミュータブル\n「キーオブジェクト」と「値オブジェクト」のペアを保存する\nハッシュ可能オブジェクトだけをキーに持てる\n任意のオブジェクトを値に持てる\nキーを指定して値にアクセスする\nインデックス参照やスライス記法は受け付けない\n\n辞書はPythonにおいて重要であるだけでなく、ハッシュテーブルという計算機科学において非常に重要なデータ構造なので、詳しく説明します。\nリストは、要素を列挙したものでした。リストは本質的に順序集合です。\n&gt;&gt;&gt; x = ['foo','bar','baz']\n&gt;&gt;&gt; print(x[1])\nbar\n一方、辞書は要素の順序集合ではなく、オブジェクトのペアの集合です。ペアを構成するオブジェクトは、キーおよび値と呼ばれます。\n辞書を説明するには、実際の辞書の例が分かりやすいです。\n\n\n\n英単語\n意味\n\n\n\n\nyep\nはい\n\n\nyes\nはい\n\n\nyet\nしかし\n\n\n\nといった(あまり役に立たない)英和辞書があったとします。この辞書では、英単語から意味を検索できるが、その逆(意味から英単語を検索)はできないとします。\n英単語がキー、意味が値に相当します。キーは一意でなくてはなりませんが、値は重複があっても構いません。\n実際にこの辞書を作るには幾つかのやり方がありますが、そのうち二つを紹介しておきます。他の作成方法については教科書のセクション6.3.1を見てください。\n&gt;&gt;&gt; x = {'yep':'はい','yes':'はい','yet':'しかし'}\n&gt;&gt;&gt; x\n{'yep': 'はい', 'yes': 'はい', 'yet': 'しかし'}\n&gt;&gt;&gt; x = dict(yep='はい',yes='はい',yet='しかし')\n&gt;&gt;&gt; x\n{'yep': 'はい', 'yes': 'はい', 'yet': 'しかし'}\n1番目の方法では、中括弧を使って辞書を作っています。中括弧の中にはキーと値のペアをコンマで区切って列挙します。キーと値はコロンで区切ります。\n2番目の方法では、dictという関数を明示的に呼び出して辞書を作成しています。関数には、key=valueという形式でキーと値のペアを渡します。こちらの形式では、キーにクォーテーションは必要ないので注意してください。\nちょうどリストにおいてインデックスから要素を取得したように、キーを指定すれば値を取得できます。\n&gt;&gt;&gt; x['yep']\n'はい'\n&gt;&gt;&gt; x['yet']\n'しかし'\nキーの一覧、値の一覧、キーと値のペアの一覧を取得するには、keysメソッド、valuesメソッド、itemsメソッドを使います。\n&gt;&gt;&gt; x.keys()\ndict_keys(['yep', 'yes', 'yet'])\n&gt;&gt;&gt; x.values()\ndict_values(['はい', 'はい', 'しかし'])\n&gt;&gt;&gt; x.items()\ndict_items([('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')])\n上記のようにキーの一覧、値の一覧、ペアの一覧はdict_keys、dict_values、dict_itemsという特殊なイテラブルデータ型で返されます。これは、適宜リストや集合、タプルに変換して用いることができます。\nたとえばリストに変換するには、関数listを使います。\n&gt;&gt;&gt; y = list(x.keys())\n&gt;&gt;&gt; y\n['yep', 'yes', 'yet']\n&gt;&gt;&gt; z = list(x.values())\n&gt;&gt;&gt; z\n['はい', 'はい', 'しかし']\n&gt;&gt;&gt; a = list(x.items())\n&gt;&gt;&gt; a\n[('yep', 'はい'), ('yes', 'はい'), ('yet', 'しかし')]"
  },
  {
    "objectID": "programming2025/programming-7.html#辞書の更新",
    "href": "programming2025/programming-7.html#辞書の更新",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "辞書の内容を更新するもっとも基本的な方法は、代入です。たとえば、xの'yep'の意味を'うっす'に変更したいときは、次のようにします。\n&gt;&gt;&gt; x['yep'] = 'うっす'\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし'}\nこのような代入操作において、指定されたキーが存在する場合は、上記のように既存の値が更新されます。指定されたキーがまだ存在しない場合は、新たにキー：値ペアが挿入されます。\n&gt;&gt;&gt; x['yeah'] = 'うん'\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし', 'yeah': 'うん'}\n特定のキー：値ペアを削除したいときは、del文を用います。\n&gt;&gt;&gt; del x['yeah']\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし'}\n複数の値を一挙に更新したい場合は、updateメソッドを使います。例えば、辞書xを辞書yで上書き更新するには、次のようにupdateメソッドを用います。\n&gt;&gt;&gt; x\n{'yep': 'うっす', 'yes': 'はい', 'yet': 'しかし'}\n&gt;&gt;&gt; y = {'yep':'はーい','yet':'まだ','no':'いいえ'}\n&gt;&gt;&gt; y\n{'yep': 'はーい', 'yet': 'まだ', 'no': 'いいえ'}\n&gt;&gt;&gt; x.update(y)\n&gt;&gt;&gt; x\n{'yep': 'はーい', 'yes': 'はい', 'yet': 'まだ', 'no': 'いいえ'}\nこのようにx.update(y)と書くことにより、yの要素(キー：値ペア)ですでにxに存在するものは置き換えられ、存在しないものは新たに追加されます。"
  },
  {
    "objectID": "programming2025/programming-7.html#ループでの挙動",
    "href": "programming2025/programming-7.html#ループでの挙動",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "辞書をリストの代わりにループインデックスの範囲として指定すると、ループインデックスにはキーだけが代入されます。つまり、次の2つのコードは全く同じ意味です。\n# %%\n# xは辞書\nfor i in x.keys():\n    print(i)\n# %%\nfor i in x:\n    print(i)\nキーと値の両方を使いたいときは、次のようにしなくてはなりません。\n# %%\nx = {'yep':'はい','yes':'はい','yet':'しかし'}\nfor i in x.items():\n    print(i)\nこのように書くと、ループインデックスにはループごとにキーと値のタプルが代入されます。\n# 出力\n('yep', 'はい')\n('yes', 'はい')\n('yet', 'しかし')\nこのようループインデックスにタプルを返すイテラブルの場合、次のようなループインデックスへのアンパック代入がサポートされています。\n# %%\nx = {'yep':'はい','yes':'はい','yet':'しかし'}\nfor i,j in x.items():\n    print(i + ' --&gt; ' + j)\n# 出力\n\nyep --&gt; はい\nyes --&gt; はい\nyet --&gt; しかし\n\n\n全ての小文字アルファベットをキー、対応する大文字アルファベットを値とする辞書letcapを作成しなさい。また、辞書letcapから、キーと値を入れ替えた辞書、すなわち大文字をキー、小文字を値とする辞書capletを作成しなさい。"
  },
  {
    "objectID": "programming2025/programming-7.html#ハッシュ可能オブジェクト",
    "href": "programming2025/programming-7.html#ハッシュ可能オブジェクト",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "任意のオブジェクトが値になれますが、キーに指定できるのは、ハッシュ可能なPythonオブジェクトのみです。\nあるアルゴリズムによってオブジェクトを整数に変換することをハッシュ化と呼びます。ハッシュ化によって得られる数値をハッシュ値と呼び、当のアルゴリズムをハッシュ関数と呼びます。全てのPythonオブジェクトがハッシュ化できるわけではなく、ハッシュ化できるオブジェクトをハッシュ可能(hashable)であると言います。ビルトインイミュータブル型のオブジェクトはほとんどすべてハッシュ可能ですが、ミュータブル型はハッシュ不可能です。\nハッシュ化は、ビルトイン関数のhashによって行うことができます。\n&gt;&gt;&gt; hash(1)\n1\n&gt;&gt;&gt; hash(\"foo\")\n2930000467231731134\n&gt;&gt;&gt; hash((1,2,3))\n529344067295497451\n&gt;&gt;&gt; hash(range(10))\n-7546101314042312252\n&gt;&gt;&gt; hash([1,2,3])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n上記の例では、リスト[1,2,3]がハッシュ不可能なため、エラーが出ています。\nタプルはイミュータブルですが、全ての要素がハッシュ可能な場合にのみハッシュ可能です。よって、たとえば次のようなタプルはハッシュ不可能です。\n&gt;&gt;&gt; x = (1,2,[3])\n&gt;&gt;&gt; hash(x)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nしたがって、このようなタプルは辞書のキーに指定することができず、エラーが出ます。\n&gt;&gt;&gt; x = {}\n&gt;&gt;&gt; x[(1,2,[3])]=123\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nハッシュ関数の特徴は、\n\n==演算子でTrueになる二つのオブジェクトは同じハッシュ値をもつ\n異なるオブジェクトが同じハッシュ値を持ってもよい(ただしその確率は通常小さい)\n\nということです。たとえば、Pythonのハッシュ関数は、-1と-2に同じハッシュ値を返します。\n&gt;&gt;&gt; hash(-1) == hash(-2)\nTrue\nこのようにハッシュ化は不可逆変換です。ハッシュ値からもとのオブジェクトを復元することは通常できません。\nなお、実際には、hash関数が使うアルゴリズムは、ハッシュ化するオブジェクトの型に依存しています。ハッシュ可能なデータ型は、すべて__hash__というハッシュ値を返すメソッドを持っていて、関数hashはこのメソッドを呼び出しているだけです。それは次のようにして確認できます。\n&gt;&gt;&gt; x = \"foo\"\n&gt;&gt;&gt; hash(x)\n2419985339487190468\n&gt;&gt;&gt; x.__hash__()\n2419985339487190468\n&gt;&gt;&gt; hash(x) == x.__hash__()\nTrue\nまた、Pythonのハッシュ関数は、セキュリティー上の理由から、インタープリタを起動するごとに異なるハッシュ値を返すようになっています。値の同じオブジェクトにはいつも同じハッシュ値を返すようにするには、環境変数PYTHONHASHSEEDに0～2**32-1の範囲の整数(4バイト符合なし整数)を設定してAnacondaプロンプト(もしくはVS Code)を再起動してください。"
  },
  {
    "objectID": "programming2025/programming-7.html#ハッシュ表",
    "href": "programming2025/programming-7.html#ハッシュ表",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "辞書の構造は少し不思議です。というのも、なぜPythonは、x['yep']と書くだけで、すぐにキー'yep'に対応する値を発見することができるのでしょうか？もし辞書がキー：値ペアを順番に格納しているだけだと、Pythonはキー'yep'を見つけるのに、いちいち全てのキー集合のなかから'yep'を検索しなくてはなりません。これだと、辞書が大きくなるに従って、検索に大きな時間を要するようになってしまいます。Pythonはこの問題を、ハッシュ表という構造を用いて解決しています。\nそれでは、次のコードを例に、辞書を作成する際に何が起きているのかを見ていきましょう。\n&gt;&gt;&gt; x = {'foo':123,'bar':456,'baz':789}\n上のコードを実行すると、筆者の処理系では辞書xのために232バイトのメモリ領域が確保されます（具体的なバイト数は処理系やPythonのバージョンに依存します）。\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getsizeof(x)\n232\nこの232バイトのうち、104バイトはオーバーヘッドで、本質的なのは残り128バイトです。この128バイトは、ハッシュ表を格納しています。ハッシュ表の役割は、キーオブジェクトを、値オブジェクトに対応付けることです。\n最近のバージョンのPythonでは、ハッシュ表はインデックス配列とエントリー表という二つの部分から構成されています。インデックス配列は、1区画1バイトからなる8区画の一続きのメモリ領域で、合計8バイトを占有しています。\n一方エントリー表は、1スロット(区画)24バイトからなる5スロットの一続きのメモリ領域で、合計120バイトを占有しています。さらに一つのスロットは三つの小区画に分かれていて、一つの小区画は8バイト占めています。この三つの小さい区画をハッシュ値区画、キー区画、値区画と呼ぶことにします。\nエントリー表の各スロットには、xを構成するキーや値の情報が格納されています。以下、Pythonがどのようにそれらの情報をエントリー表に格納していくか説明します。\n\n\n\ndict\n\n\nまず、Pythonは第一のキーオブジェクト'foo'をハッシュ化し、そのハッシュ値を0～7の整数に変換します。この変換は、ハッシュ値の下位3ビットを取り出すことで行っています。3ビットの整数は0～7の範囲をとることに注意してください。\n&gt;&gt;&gt; x = hash(\"foo\")\n&gt;&gt;&gt; bin(x)\n'0b111111111111110001101001010101111001010101111011001011001010100'\n&gt;&gt;&gt; x & 0b111   # xの下位3ビットを取得\n4\nなおここで、& 0b111というのが任意の数の下位3ビットを取り出す操作になっていますが、これについては後で解説します。ここでは、確かにbin(x)の下位3文字が100、つまり2進数で4になっていることを確認してください。\nその後Pythonは、キー'foo'の参照、値123の参照、ハッシュ値(hash(\"foo\")の値)をエントリー表第0スロットのキー区画、値区画、ハッシュ値区画に記録します。キーの参照、値の参照、ハッシュ値はどれも8バイトなので、スロットは24バイト消費します。\n次に、“foo”のハッシュ値の下位3ビットは0b100=4でしたので、Pythonは、インデックス配列の第4区画に、エントリー表での'foo'のスロット番号0を記録します。\nPythonは、同じことを、'bar'と'baz'に対しても行います。これらのハッシュ値と下位3ビットを調べてみましょう。\n&gt;&gt;&gt; hash(\"bar\") & 0b111\n7\n&gt;&gt;&gt; hash(\"baz\") & 0b111\n2\n\"bar\"と\"baz\"の情報はエントリー表の第1、第2スロットに順番に収められます。また、hash(\"bar\")の下位3ビットが7であったので、インデックス配列の第7区画に\"bar\"のスロット番号である1をセットします。同様にhash(\"baz\")の下位3ビットが2であったので、インデックス配列の第2区画に”baz”のスロット番号2をセットします。\nこのようにして、Pythonは図のようなハッシュテーブルを完成させます。\nPythonが、完成した辞書からキー'foo'に対応する値123を取り出す際は、それを登録したときとほぼ同じ方法を使います。\nまず、'foo'をハッシュして下位3桁をみます。するとその値は4ですので、インデックス表の4番目を見ます。そこが空っぽであればPythonはエラーを出しますが、番号が書いてあった場合は、その番号に対応するエントリー表のスロットをみます。そのスロットに記録されているキーが、今探しているキーと一致すれば、対応する値を返して作業を終了します。\n上記の作業の作業量は、ハッシュテーブルにエントリーされているキー：値ペアの数に依存せずほぼ一定であるため、辞書の操作は登録されている要素(キー：値ペア)の数が大きくなっても、比較的高速に行うことができるのです。\nなお、ハッシュ化して下3桁をとると、複数のキーが同じインデックスになってしまうことがあります。これをハッシュ衝突と呼びます。二つのキーでハッシュ衝突が起きると、後から登録しようとしているキーに対しては、あるアルゴリズムで別のインデックスを振られます。\nここから先は専門的な話になりますので詳細は説明しませんが、ここで使われている空きインデックスを探すアルゴリズムはリニアプロービングという単純なアルゴリズムです。関心のある方は参考書の『High Performance Python: Practical Performant Programming for Humans』(Gorelick & Ozsvald, 2020)をご覧ください。ここではハッシュ衝突の概念だけ押さえておきましょう。"
  },
  {
    "objectID": "programming2025/programming-7.html#ビットマスク",
    "href": "programming2025/programming-7.html#ビットマスク",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "さてここで話が少しそれますが、ハッシュ値から下3桁をとりだした操作は教養の観点から言って重要ですので、少し詳しく説明をしておきます。ハッシュ値のところで行ったように、たとえば整数123から下位3ビットを取り出すには、次のようにします。\n&gt;&gt;&gt; 123 & 0b111\n3\nまず、0b111は、接頭辞0bがついているので、7を2進数表現したものであることにしてください。&演算子は、bitwise ANDというビット演算子の一種で、二つのビット配列がともに1になっているビットだけを1にし、残りの全てのビットを0にした数字を返します。\n&gt;&gt;&gt; x = 0b1010 & 0b1001\n&gt;&gt;&gt; x\n8\n&gt;&gt;&gt; bin(x)\n'0b1000'\n&gt;&gt;&gt;\nしたがって、どのような整数でも、0b111とのbitwise ANDをとれば、下位3ビット以外はすべて0になり、下位3ビットだけがとりだせることになります。このように、ビット列との&をとって特定のビットだけを抽出することを、ビットマスクをかけるといいます。このとき、ビット抽出に使われる0b111のような数字をビットマスクと呼びます。情報科学で頻繁に使われる概念なので覚えておきましょう。\nなおハッシュ値が負の値の場合、bin関数が表示する2進数表記は、実際にハッシュ値がメモリに記録されるときのビット配列とは異なります。bin(x)が返すのは、xの絶対値の2進数表現にマイナス符合を付けたものであり、xのメモリ上でのビット配列ではありません。ビットマスクはbin関数の戻り値では無く、メモリ上でのビット配列、つまり2の補数表現に対して取られます。たとえば、“bar”を関数hashでハッシュ化すると、筆者の環境では次のように負の値になり、その下3ビットは001、つまり1となります。\n&gt;&gt;&gt; bin(hash('bar'))\n'-0b101111000110111000001100101111000011111100001110110110111001'\nところが、’bar’のハッシュ値と0b111のANDを取ったものは、上で示したように、7でした。この食い違いは、ハッシュ値が負である為に置きます。ハッシュ値が負のときのビット演算の結果は、2の補数表現で考えなくてはいけません。\n初回の講義の補遺において紹介したint_to_bitsを使ってハッシュ値の2の補数表現を求めておきましょう。\n# %%\nint_to_bits(hash('bar'),8)\n# 出力\n11110100 00111001 00011111 00110100 00111100 00001111 00010010 01000111\nこのように、確かに下3桁は0b111、つまり7になっていることが分かります。\nbitwise演算子には、AND以外にも様々なものがあり、ビット単位での操作を可能にします。ここでは取り上げませんが、非常に重要ですので、教科書のセクション3.5を良く読んでおきましょう。\n\n\n試作品段階ですが、辞書の内部構造を表示するモジュールinsdictを開発中です。興味のある方は仮想環境にインストールして使ってみてください。ただし、インタープリタをコンパイルしたのと同じCコンパイラが必要です。Windowsの場合は、Microsoft Visual Studioが必要です。Linuxの場合はGCCが必要です。"
  },
  {
    "objectID": "programming2025/programming-7.html#辞書のリサイズ",
    "href": "programming2025/programming-7.html#辞書のリサイズ",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "さて、辞書に話を戻します。辞書のエントリーが増えてきて、インデックス表が埋まってくると、だんだんとハッシュ衝突の確率が上がってきます。衝突が多いほど、登録にも検索にも時間がかかるようになります。ですので、衝突を最小限に抑えるために、インデックス配列の区画数はエントリー表よりもすこし大きめに確保してあります。具体的には、エントリー表のスロット数は、インデックス配列の長さの約2/3になっています。\nエントリー表が満杯になった状態で次のキーが登録されると、インデックス配列とエントリー表が同時に拡張されます。このとき、新しくインデックス配列とエントリー表が作成され、既存のインデックス配列とエントリー表の内容がコピーされます。\n新しく作成されたエントリー表のサイズは10区画、インデックス表のサイズは16区画になります。再びエントリー表が一杯になると、再度拡張がおき、今度はエントリー表は21区画、インデックス表は32区画になります。このようにして、エントリー表が一杯になるたびに、おおよそ倍々にインデックス表とエントリー表は拡張されていきます。\n理論的には、辞書の要素が増えるにつれ、オーバヘッドを除く占有バイト数は次のように変化していきます。\n\n\n\n要素数\nスロット数\n配列長\nエントリー表サイズ\n配列サイズ\n合計\n\n\n\n\n1~5\n5\n8\n24x5=120\n1x8=8\n128\n\n\n6~10\n10\n16\n24x10=240\n1x16=16\n256\n\n\n11~21\n21\n32\n24x21=504\n1x32=32\n536\n\n\n22~42\n42\n64\n24x42=1008\n1x64=64\n1072\n\n\n43~85\n85\n128\n24x85=2040\n1x128=128\n2168\n\n\n86~170\n170\n256\n24x170=4080\n2x256=512\n4592\n\n\n171~341\n341\n512\n24x341=8184\n2x512=1024\n9208\n\n\n\n上記の表で、各列の意味は以下の通りです。\n\n\n\n列\n意味\n\n\n\n\nスロット数\nエントリー表のスロット数\n\n\n配列長\nインデックス配列の区画数\n\n\nエントリー表サイズ\nエントリー表の総バイト数\n\n\n配列サイズ\nインデックス配列の総バイト数\n\n\n合計\nエントリー表の総バイト数＋インデックス配列の総バイト数\n\n\n\nちょっと細かいことですが、上の表でインデックス配列は、辞書が小さい間は、1区画1バイトを占めていますが、エントリー表のスロット数が85から170に増加したときに1区画あたり2バイトに増加します。これは、インデックス配列のそれぞれの区画は、 符号付き1バイト整数(-128～+127)を表すのに使っており、128以上のスロットナンバーを記録できないからです。\n本当に上記のようなことが起きているかを確かめるためのコードを書いてみましょう。からっぽの辞書に一つずつキー：値ペアを追加していき、2**8個までペアを追加することにします。占有バイト数が変化したときだけ出力することにします。\nimport sys\n\nx = dict()\nprev_size = 0     # 前回のハッシュ表サイズ\ncurr_size = 0     # 今回のハッシュ表サイズ\nmin_size = 128    # 最小のハッシュ表サイズ\noverhead = sys.getsizeof(x) - min_size # オーバーヘッド\n\nfor i in range(1,2**8+1):\n    x.update({i:i})\n    curr_size = sys.getsizeof(x) - overhead\n    if curr_size != prev_size:\n        print(str(i) + ' --&gt; ' + str(curr_size))\n    prev_size = curr_size\n# 出力\n1 --&gt; 128\n6 --&gt; 256\n11 --&gt; 536\n22 --&gt; 1072\n43 --&gt; 2168\n86 --&gt; 4592\n171 --&gt; 9208\n1列目は辞書のエントリー数、2列目はオーバーヘッドを除いたハッシュ表の占有バイト数です。\n下の図は、エントリ数とともに辞書の占有メモリがどのように増えていくかを表した図です。オーバーヘッドは含んでいません。\n\n\n\ndict-mem\n\n\n具体的なバイト数は処理系(64bitか32bitか)に依存し得ます。64ビットOSなのに結果が上の表と一致しないとすれば、Pythonのバージョンがかなり古いか、あるいはものすごく新しい可能性があります。その場合は、試しに自分の使っている処理系ではどのようにハッシュ表がメモリを使っているのか色々と実験して調べてみてください。"
  },
  {
    "objectID": "programming2025/programming-7.html#集合",
    "href": "programming2025/programming-7.html#集合",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "集合型は、辞書やリストに比べると使う機会が少ないと思いますので、説明は簡単にしておきます。集合は、内部構造をもたないオブジェクトの集まりです。集合は、値のないキーだけの辞書と思ってほぼ間違いはありません。以下のような特徴を持ちます。\n\nイテラブル\nミュータブル\nインデックス・スライス参照不可\nキー参照不可\nハッシュ可能オブジェクトだけを要素に持てる\n算術演算不可\n集合演算可\n\n集合を作るやり方は主に二通りあります。一つは、中かっこ内に要素を列挙する方法、もう一つは、関数setにイテラブルオブジェクトを渡す方法です。\n&gt;&gt;&gt; x = {'foo','bar','baz'}\n&gt;&gt;&gt; x\n{'baz', 'foo', 'bar'}\n&gt;&gt;&gt; y = set([1,2,3])\n&gt;&gt;&gt; y\n{1, 2, 3}\n集合は辞書キーと同じで、重複が許されないことに注意してください。これを利用して、文字列などから、文字列に含まれている文字の集合を作成できます。\n# 文字の一覧を取得\n&gt;&gt;&gt; z = set(\"foo bar baz\")\n&gt;&gt;&gt; z\n{'a', 'f', 'b', ' ', 'r', 'o', 'z'}\n集合の要素は辞書のキーと同じでハッシュ可能でないといけません。\n&gt;&gt;&gt; x = {[3],5}\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\nループでの挙動は、辞書と変わりありません。\n&gt;&gt;&gt; x = {'a','b','c'}\n&gt;&gt;&gt; x\n{'b', 'a', 'c'}\n&gt;&gt;&gt; for i in x:\n...     print(i)\n...\nb\na\nc"
  },
  {
    "objectID": "programming2025/programming-7.html#集合演算",
    "href": "programming2025/programming-7.html#集合演算",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "リストや辞書でなく、集合を用いるのは、集合演算を用いたいときでしょう。集合型には様々な集合演算が定義されています。\n\n\n\nメソッド\n記号\n機能\n\n\n\n\nx.difference(y)\n-\nxとyの差集合\n\n\nx.intersection(y)\n&\nxとyの積集合\n\n\nx.union(y)\n|\nxとyの和集合\n\n\nx.issubset(y)\n&lt;=\nxがyの部分集合ならTrue\n\n\nx.issuperset(y)\n&gt;=\nyがxの部分集合ならTrue\n\n\n\nたとえば、和集合はunionメソッドもしくは|演算子で作成できます。\n&gt;&gt;&gt; x = {'a','b','c'}\n&gt;&gt;&gt; y = {'c','d','e'}\n&gt;&gt;&gt; x.union(y)\n{'b', 'a', 'd', 'e', 'c'}\n&gt;&gt;&gt; x | y   # 同じ意味\n{'b', 'a', 'd', 'e', 'c'}\n上記の集合演算を自分で色々と試してみましょう。\n\n\n文字列”pythonlanguage”に含まれる文字のうち、“helloworld”と”foobarbaz”のどちらか一方にのみ含まれている文字の集合を求めなさい。"
  },
  {
    "objectID": "programming2025/programming-7.html#まとめ",
    "href": "programming2025/programming-7.html#まとめ",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "今回の講義では、以下のことを学びました。\n\n辞書の仕組み\nハッシュ表\nビットマスク\n集合型\n集合演算\n\n辞書はPythonのデータ型の中でも非常に重要な役割を持つものですので、教科書の対応する範囲を良く読み、挙動を理解するようにしましょう。"
  },
  {
    "objectID": "programming2025/programming-7.html#参考書",
    "href": "programming2025/programming-7.html#参考書",
    "title": "第7回 標準ライブラリ(2)―辞書、集合",
    "section": "",
    "text": "『High Performance Python: Practical Performant Programming for Humans』(M. Gorelick, I. Ozsvald著) (2020) O’Reilly. ISBN-13 : 978-1492055020.\n『CPython Internals: Your Guide to The Python 3 Interpreter』(A. Shaw, The real python.com tutorial team)(2021) Real Python. ISBN-13: 978-1775093343."
  },
  {
    "objectID": "programming2025/programming-1.html",
    "href": "programming2025/programming-1.html",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "第1回 プログラミング概論\n\nPythonの実行方法\nREPLによる対話的実行\n\n練習1\n\nコマンドラインによる実行\n\n練習2\n\n2進数と16進数\nコンピューターの仕組み\nメモリの仕組み\nCPUの働き\nマシン語\nプログラミング言語の種類\n\nコンパイル型言語\nインタープリタ型言語\nアセンブリ言語\n\n抽象度\nプログラミング上達のコツ\n\n正しいタイピング\nキーバインド\n写経\n\nまとめ\n参考書\n補遺(メモリ上での数の表現)\n\n符号なし整数\n符号つき整数\n小数\nエンディアン\n\n\n\n\n\nまずはPythonを動かしてみましょう。Pythonを動かすには、様々な方法がありますが、そのうち、代表的なものは次の3つです。\n\nREPLで一行ずつ対話的(インターラクティブ)に実行\nPythonスクリプトを作成してコマンドラインから実行\nVSCode内でセル(コードブロック)ごとに対話的に実行(第2回講義参照)\n\n\n\n\nまずはREPL(Read-Eval-Print Loop)を用いた対話的実行を行ってみましょう。\nウィンドウズを起動して、画面の左下の検索ウィンドウにAnacondaと打ち込んで、Anaconda Promptを起動しましょう（Anaconda Powershell Promptでも構いません）。Anacondaを起動したら、pythonと入力し、pythonの対話的インタープリタREPLを起動しましょう。プロンプトと呼ばれる\"&gt;&gt;&gt;\"記号が現れて、入力待ちの状態になります。\nREPLは、Pythonのコードを1行ごとに評価し、即時にその結果を表示してくれるシステムです。小さなコード断片の挙動を確かめる際などに便利です。\nPythonには、整数や計算式などはそれ自体がPythonのコードと見なされるという特徴があります。そのおかげで、PythonのREPLを計算機として用いることができます。たとえば、何でも良いので、簡単な足し算や引き算をREPLに入力してみましょう。（入力の最後にはEnterキーを押します。）\n&gt;&gt;&gt; 1 + 1\n2\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 3 * 2\n6\n&gt;&gt;&gt; 8 / 2\n4.0\n&gt;&gt;&gt; 11 // 3\n3\n&gt;&gt;&gt; 11 % 3\n2\n&gt;&gt;&gt; 5 ** 3\n125\nこのように、REPLは簡単な計算機として用いることができます。なお、Pythonにおける2項算術演算子は以下の通りです。\n\n\n\n演算子\n機能\n\n\n\n\n+\n可算\n\n\n-\n減算\n\n\n*\n乗算\n\n\n**\nべき乗\n\n\n/\n除算\n\n\n//\n整数除算（余りを切り捨て）\n\n\n%\n剰余\n\n\n\n上記の表は教科書のセクション3.1にもありますので確認しておいてください。\nなお3つ以上の数の演算を行うには、演算子の優先順位に気を付けなければならないのはRと同じです。たとえば\n&gt;&gt;&gt; 2 + 3 * 5\n17\nのように掛け算は足し算よりも先に評価されます。演算子の評価順序を明確にしたいときは、丸カッコを使います。\n&gt;&gt;&gt; (2 + 3) * 5\n25\n演算子の優先順位については教科書のセクション3.6(pp. 107)に解説がありますので、読んでおいてください。ただし、計算式においては、演算子の評価順序には頼り過ぎると読みにくいコードになってしまうので、むしろ丸カッコを積極的に使うことが望ましいです。\n\n\n次の計算をPythonで実行したらどのような結果が得られるかを予測しなさい。\n# Q1\n&gt;&gt;&gt;(5 % 3) ** (7 // 2)\n# Q2\n&gt;&gt;&gt;(5.5 - 2.5 + 3.0) * 2.0\n上記Q1, Q2の予測をREPLで確かめられたら、同じように様々な計算を自分で考えてREPLで実行し、予測と一致するか確かめなさい。\n\nそれでは、次にもう少し高度なことをしてみます。以下のように入力して、変数xに整数1を代入し、xの値を表示してみましょう。\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; x\n1\nこのように、‘=’記号を使うと左辺の変数に右辺の値を代入できます。(Rでは、同様の操作に’&lt;-’という矢印演算子を用います。)\nそれでは、さらに変数を用いて色々な演算をしてみましょう。\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 2\n&gt;&gt;&gt; x + y + 3\n6\n&gt;&gt;&gt; z = y + 1\n&gt;&gt;&gt; x - z\n-2\n&gt;&gt;&gt; x = z ** y\n&gt;&gt;&gt; x\n9\n&gt;&gt;&gt; x = x - 1\n&gt;&gt;&gt; x\n8\nこのように、変数は演算の中で用いることができます。\n最後に”Hello, World!“を出力しておきましょう。これについても、Rと全く同じですので、説明はほとんど要らないでしょう。(実際、Rのコードと見分けがつきません。)\n&gt;&gt;&gt; print(\"Hello, World!\")\nHello, World!\nRと同じように、ダブルクォーテーションでくくられた部分は、Pythonにより文字列と解釈されます。printは、引数に与えられた文字列や数を画面に出力するだけの関数です。\nREPLを終了してAnaconda promptに戻るときは、次のように入力します。\n&gt;&gt;&gt;exit()\n\n\n\n\nそれでは次に、Pythonのコードをファイルに保存してコマンドラインから実行する方法を試してみましょう。Anaconda promptで次のように入力し、メモ帳を起動してください。\n(base) C:\\Users\\hogehoge&gt;notepad\nメモ帳が起動したら、次のように記述して、保存しましょう。保存する際、ファイル名はhelloにしてください。\nprint(\"Hello, World!\")\n次にファイルを保存して閉じ、Anaconda promptで次のように入力すると、ファイルに記述したPythonコードを実行することができます。\n(base) C:\\Users\\hogehoge&gt;python hello.txt\nHello, World!\n\nなお、Pythonコードを記述するファイル（スクリプトと呼ぶ）の名前には.txtではなく拡張子.pyを付けるのが普通ですので、覚えておきましょう。\nそれではもう一度同じファイルを開いて、もう少し中身を豪華にしてみましょう。\nprint(\"Hello, World!\")\nx = 1\ny = 2\nz = x + y\nprint(x)\nprint(y)\nprint(z)\nこれを実行すると、以下のようになります。\n(base) C:\\Users\\Kobayashi&gt;python hello.txt\nHello, World!\n1\n2\n3\n\nこのように、Pythonでは、文を改行で区切って並べることにより、上から順番に文が実行されていきます。文については教科書のセクション1.5.2に詳しい説明があるので良く読んでおいてください。\n\n\n5の5乗を計算して画面に出力するpower5_5.pyというファイルを作成し、実行しなさい。\n\n\n\n\n2進数や16進数については、多くの方が高校や大学で学んだことがあることでしょう。しかしながら、以降の説明で非常に重要ですので、ここでこれらの概念を簡単に復習しましょう。\nご存じの通り、私たちが普段使っている10で桁上がりする数字は、10進数と呼ばれます。一方、2で桁上がりする数を2進数、16で桁上がりする数を16進数と呼び、情報科学では10進数と並んで良く用いられる数の表し方です。\n2進数では、2で桁上がりするため、10進数における2～9の数字は現れません。また、16進数では、10進数における0～9だけでは1桁を表すのに足りないため、a～fのアルファベットを用います。具体的には、3つの数表記には、以下のような関係があります。\n\n\n\n10進数\n2進数\n16進数\n\n\n\n\n0\n0\n0\n\n\n1\n1\n1\n\n\n2\n10\n2\n\n\n3\n11\n3\n\n\n4\n100\n4\n\n\n5\n101\n5\n\n\n6\n110\n6\n\n\n7\n111\n7\n\n\n8\n1000\n8\n\n\n9\n1001\n9\n\n\n10\n1010\na\n\n\n11\n1011\nb\n\n\n12\n1100\nc\n\n\n13\n1101\nd\n\n\n14\n1110\ne\n\n\n15\n1111\nf\n\n\n16\n10000\n10\n\n\n\nある数が2進数で表記されていることを明確にするため、2進数の先頭に0bという接頭辞を付けることがあります(bはbinaryより)。同様に16進数には接頭辞0xをつけます(xはhexadecimalより)。たとえば、0x1eは0b11110すなわち10進数での30を表します（分かりましたか？）。\n10進数、2進数、16進数の間の変換に慣れておきましょう。とくに2進数と16進数の間の変換は重要です。これは全く難しくありません。インターネットなどにいくらでも情報がありますので、練習しておきましょう。\n10進数、2進数、16進数の間の変換は、Pythonを用いても行うことができます。次のPythonコードは、それぞれ、10進数の123を2進数、16進数に変換するものです。\n&gt;&gt;&gt; bin(123)\n'0b1111011'\n&gt;&gt;&gt; hex(123)\n'0x7b'\nこのように関数binとhexを使えば10進数をそれぞれ2進数、16進数に変換することができます。\nまた、逆の変換をするときは、次のように数字を入力するだけです。\n&gt;&gt;&gt; 0b1111011\n123\n&gt;&gt;&gt; 0x7b\n123\n\n\n\nパソコンは、様々な部品から構成されていますが、プログラミングの初心者がまず知っておかなければならないのが、CPUとメインメモリの働きです。メインメモリはランダムアクセスメモリ(Random Access Memory)とも呼ばれるので、RAMと表記されることもあります。\nCPUとメモリ(メインメモリ)は、記憶装置です。パソコンにはいくつもの記憶装置が内臓されていますが、どの記憶装置も、文字や整数や小数だけでなく、プログラムなど、すべての情報を0と1の配列に変換して記憶しています。\nCPUとメモリはどちらもトランジスタで構成された集積回路(IC, Integrated Circuit)ですが、次のような性質の違いがあります。\n\n\n\n\nCPU\nメモリ\n\n\n\n\n記憶容量\n非常に小さい\n大きい\n\n\n演算能力\n有り\n無し\n\n\n\nここで言う演算とは、足し算や引き算を含む様々な計算のことです。CPUは演算機能をもっていますが、ほんの少しの情報しか記憶できないので、CPUだけではちょっとしたプログラムも動かせません。そこで、まず容量の大きいメモリにプログラム全体を読み込ませます。プログラムは、CPUに対する命令の集まりです（と思って大体間違いありません）。CPUは、メモリに読み込んだ命令を１つずつ読み取って実行していきます。それでは、次に、プログラムなどの情報がどのようにメモリに保存されているのかを見ていきましょう。\n\n\n\nメモリは、たとえば001011010110001101011…のように、全ての情報を0と1の並びに変換して記憶しています。この0と1の並びは、8桁ずつの区画に区切られています。それぞれの区画には、アドレスと呼ばれる数字が振られていて、数字によってメモリ上の位置が指定できるようになっています。\nそれぞれの区画には、8桁の0と1が格納されているので、1つの区画は00000000から11111111までの256通りの状態を記憶することができます。この記憶容量のことをバイト(Byte)といいます。一方、1桁の0と1で記憶できる容量のことをビット(bit)と呼びます。よって、\n1バイト = 8ビット\nの関係が成り立ちます。\nメモリへの情報の読み書きは、必ずバイトを単位として行われます。ビットを単位として読み書きすることはできません。このように、バイトはパソコンにおける最も重要な情報量の単位です。\n\n\n\nmemory\n\n\nメモリについて考えるときは、上図のように、バイト単位のデータが積み重なったものと考えると良いです。上図では、合計128バイトの容量をもつメモリのイメージを図示しています。なお、バイトよりも大きい情報量の単位には、キロバイトやメガバイト、ギガバイトなどがあります。\n\n\n\n情報量の単位\nバイト換算\n\n\n\n\nキロバイト(KB)\n10の3乗=1,000バイト\n\n\nメガバイト(MB)\n10の6乗=1,000,000バイト\n\n\nギガバイト(GB)\n10の9乗=1,000,000,000バイト\n\n\nテラバイト(TB)\n10の12乗バイト\n\n\nペタバイト(PB)\n10の15乗バイト\n\n\nエクサバイト(EB)\n10の18乗バイト\n\n\nキビバイト(KiB)\n2の10乗=1,024バイト\n\n\nメビバイト(MiB)\n2の20乗=1,048,576バイト\n\n\nギビバイト(GiB)\n2の30乗=1,073,741,824バイト\n\n\nテビバイト(TiB)\n2の40乗バイト\n\n\nペビバイト(PiB)\n2の50乗バイト\n\n\nエクスビバイト(EiB)\n2の60乗バイト\n\n\n\nなお、キロバイト、メガバイト、ギガバイトという言葉が使われている場合でも、実際にはキビバイト(KiB)、メビバイト(MiB)、ギビバイト(GiB)を指す場合があるので、多少の注意が必要です。本講義でも、キビバイトやメビバイトは余り親しみのない言葉ですので、KiBやMiBと書いてキロバイト、メガバイトと発音しても良いことにします。ご注意ください。なおキビバイトとキロバイトの容量差は2%しかありませんので、通常この違いに神経質になる必要はありません。ギガバイトとギビバイトになると、7%の違いがありますので、ちょっと無視できないかもしれません。\n\n\n\n一方、CPUはレジスタと呼ばれる記憶装置を複数内臓しています。レジスタは、プログラム内の命令やデータ、メモリのアドレスなどを格納することができます。CPUはメモリに読み込まれたプログラムの中の命令をレジスタに読み込こんで実行したり、メモリのなかのデータをレジスタに読み込んで演算をほどこしたり、演算の結果をメモリに書き込んだりすることでコンピュータを動かしています。\nレジスタにはプログラマがプログラムから直接操作できるもの(数十個ある)と操作できないものがあります。プログラマが意識しなくてはならないのは前者の操作できるレジスタだけです。具体的にどのようなレジスタがいくつあるのかについては、CPUによって違ってきます。\nレジスタは、メモリと全く同じように0と1の情報を格納できます。レジスタには、64ビットコンピュータでは64ビット=8バイトの情報を格納することができます。32ビットコンピュータでは4バイトです。したがって、プログラムが一つのレジスタを使って一度に処理できるデータの量は64ビットコンピュータなら最大8バイト、32ビットコンピュータなら最大4バイトです。\nただし64ビットレジスタは下位の32ビットを使って32ビットレジスタとしても動作できるようになっています。従って、64ビットコンピュータでも、32ビット仕様のOSやアプリケーションが動作します。\n32ビットレジスタのサイズが4バイトであることに合わせて、32ビットOSはメモリのアドレスを4バイトで表現します。\n\n\n\n\n\n\n\n\n\n\n2進数表記\n16進数表記\n10進数表記\n\n\n\n\n最小の数字\n0b0\n0x0\n0\n\n\n最大の数字\n0b1111...1111\n0xffffffff\n4,294,967,295=2の32乗-1\n\n\n\n0xffffffff=4,294,967,295=0b1111…1111であることはPythonで簡単に確かめることができます。\n&gt;&gt;&gt; 0xffffffff\n4294967295\n&gt;&gt;&gt; bin(0xffffffff)\n'0b11111111111111111111111111111111'\n4バイトの数値が表現できるメモリアドレスの範囲は、上記の表にあるように0～2の32乗-1=4×2の30乗-1です。メモリは1区画あたり1バイトの容量をもつので、32ビットOSでは、4×2の30乗バイト、すなわち4GiBまでしか扱うことができません。したがって、それ以上のメモリを物理的に搭載しても、4GiBを超える部分はOSによって認識してもらえません。\n一方、64ビット対応したOSでは、メモリアドレスの表現に8バイト数値を使用します。したがって(少なくとも理論上は)0～2の64乗-1までのアドレス(16EiB=約18エクサバイト)を表現できます。これは極めて巨大な数ですので、64ビットOSではメモリの上限が問題になることは通常ありません。\n\n\n\nプログラムがメモリに読み込まれたあと、プログラムを構成する命令は、一つずつCPUに読みだされて実行されていきます。\n\n\n\nregister\n\n\nレジスタは0と1しか格納できないので、命令と命令からなるプログラムもまた、0と1の列でなくてはなりません。(当然、列の長さは8の倍数です。)こうした、CPUが理解できる、0と1で構成された命令をマシン語(機械語)と呼びます。大昔、コンピュータができたばかりでプログラミング言語がまだ存在していなかったころは、プログラマはマシン語を直接編集することでプログラムを作っていました。\n試しに、プログラムが実際にどのようなマシン語になっているかをディスプレイに打ち出してみることができます。これをダンプ(dump)と言います。たとえば、画面に”Hello, World!“と打ち出すプログラムをダンプしてみると、該当箇所は以下のようになります。\n...(前略)...\n00000060: 00100000 00000000 01010000 01100000 01001000 01100101   .P`He\n00000066: 01101100 01101100 01101111 00101100 00100000 01010111  llo, W\n0000006c: 01101111 01110010 01101100 01100100 00100001 00000000  orld!.\n00000072: 01001000 10111001 00000000 00000000 00000000 00000000  H.....\n00000078: 00000000 00000000 00000000 00000000 01001000 10000011  ....H.\n0000007e: 11101100 00100000 11101000 00000000 00000000 00000000  . ....\n00000084: 00000000 01001000 10000011 11000100 00100000 11001001  .H.. .\n0000008a: 11000011 00000010 00000000 00000000 00000000 00000010\n...(後略)...\nここで、1列目はファイルの先頭からのバイト数を16進数で表したものです。0x64バイトから0x70バイトまでがHello, World!という文字列を表し、0x72バイトから0x8aバイトまでが命令です。\nこのように、マシン語は人間にとっては非常に分かりづらいので、マシン語を直接操作しなくてもプログラムが作れるように、C言語などのプログラミング言語が作られました。\nなお、64ビット版のWindows 10にはダンプをするためのツールが標準搭載されていませんが、Gitをインストールするとbashターミナルでxxdコマンドが使えるようになります。一方Linuxにはxxdコマンドが標準で搭載されています。いずれのOSでも、ターミナルで次のように入力すれば実行可能ファイルを2進数にダンプできます。\nxxd -b a.out\nここでa.outが実行可能ファイルの名前です(Windowsの場合a.exeなどになります)。-bは2進数でダンプするオプションです。このオプションを付けないと、結果は16進数で表示されます。\n\n\n\nプログラミング言語を分類する方法は色々ありますが、まず覚えた方が良いのが、コンパイル型言語とインタープリタ型言語の違いです。\n\n\n\n\n\n\n\n\n\nコンパイル型\nインタープリタ型\n\n\n\n\n実行速度\n高速\n低速\n\n\nコンパイル\n必要\n不要\n\n\n例\nC言語、C++、FORTRAN、RUSTなど\nPython、R、Ruby、Perl、JavaScriptなど\n\n\n\n\n\nたとえばC言語のようなコンパイル型言語で”Hello, World!“を出力するプログラムについて考えましょう。その場合、まず次のようなプログラミング言語で書かれたテキストファイル（ソースファイルあるいはソースコードという）を準備します。\n#include &lt;stdio.h&gt;\nint main(void){\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\nこのファイル名をhello.cとしましょう。その後、コンパイルという操作により、このファイルを機械語に変換します。この操作を実行するソフトウェアのことをコンパイラと呼びます。たとえばLinuxには通常GCC(GNU Compiler Collection)というコンパイラがインストールされています。\nコンパイルを行うと、マシン語で書かれた別のファイルが作成されます。これを実行可能ファイルと呼びます。厳密には、hello.cをマシン語にコンパイルしただけでは実行ファイルにはならず、オブジェクトファイルと呼ばれるマシン語で書かれたファイルが出来上がります。コンパイラはさらにリンクという作業を行い、出来上がったオブジェクトファイルに必要な付属品を色々とくっつけて実行可能ファイルを作ります。\n\n\n\ncompile\n\n\nAnaconda仮想環境(第2回の講義資料参照)にGCCがインストール出来ている人は、実際にコンパイルしてみることができます。(GCCがインストール出来ていない人は、手順だけ追っておきましょう。)Anaconda PromptでGCCがインストールされた仮想環境を起動し、次のように入力してメモ帳を起動しましょう。\nnotepad hello.c\nメモ帳が起動したら、上記のHello, World!のCのソースコードをコピー＆ペーストして、保存し、閉じましょう。\n上記のようにしてソースファイルが作成できたら、以下のようにしてコンパイルします。\ngcc -Wall hello.c -o hello.exe\n-Wallは、コードに不適切な点があれば警告を発してくれるオプションです。また、-o hello.exeは、hello.exeという名前のファイルにコンパイルせよという意味です。\nhello.exeが正しく作成されていれば、Anaconda Promptで次のように入力することで実行できるはずです。\nhello.exe\n出力は以下の通りです。\nHello, World!\nコンパイル型の言語で書かれたソースファイルは直接実行することはできず、かならずコンパイルして実行可能ファイルを作る必要があります。\n実行可能ファイルは、CPUが直接解釈可能なマシン語で書かれているため、非常に高速に動作します。一方で、大きなプログラムはコンパイルに大変時間がかかるという欠点があります。また実行可能ファイルを構成するマシン語は、CPUのレジスタを直接操作する命令の集まりですので、CPUの異なるコンピュータでは動作しません。従って、プログラムを他のコンピュータに移植するときは、移植先のコンピュータでソースコードを再コンパイルする必要があります。\nなお、コンパイルとリンクを分けて行うには次のようにします。\ngcc -c hello.c\ngcc hello.o -o hello.exe\n一つめのコマンドがコンパイルを実行してオブジェクトファイルhello.oを作ります。二つ目のコマンドは、さらにリンクを行って実行可能ファイルhello.exeを作っています。\nオブジェクトファイルや実行可能ファイルを16進ダンプしてみることもできます。hello.cが置かれているフォルダでGit bash(第3回講義資料を参照)を開き、次のように入力してみましょう。\nxxd hello.o\n筆者の環境では、出力は以下のようになります。\n...(前略)...\n00000100: 4000 3040 2f34 0000 0000 0000 0000 0000  @.0@/4..........\n00000110: 0000 0000 3000 0000 8401 0000 0000 0000  ....0...........\n00000120: 0000 0000 0000 0000 4000 5040 5548 89e5  ........@.P@UH..\n00000130: 4883 ec20 e800 0000 0048 8d0d 0000 0000  H.. .....H......\n00000140: e800 0000 00b8 0000 0000 4883 c420 5dc3  ..........H.. ].\n00000150: 9090 9090 9090 9090 9090 9090 4865 6c6c  ............Hell\n00000160: 6f2c 2057 6f72 6c64 2100 0000 0108 0305  o, World!.......\n00000170: 0832 0403 0150 0000 0000 0000 2400 0000  .2...P......$...\n...(後略)...\nここで、一番左の列がファイル先頭からの位置をバイト数(16進数)で表したものですが、プログラムの命令が書かれているのは、0x12cバイト地点の5548 89e5 ...のところから、0x14fバイト地点の... c420 5dc3までです。そのあとマシン語で「命令なし」を意味する90が12個続いたあと、4865 6c6c 6f2c 2057 6f72 6c64 21と13バイトの数字が続いていますが、これは、ASCIIコードでHello, World!の13文字を意味します。このように、命令コードの直後に、必要なデータが添付されていることが分かります。\n\n\n\n一方、Pythonのようなインタープリタ型言語では、実行にコンパイルを必要としません。インタープリタ型言語では、ソースファイルは実行可能ファイルの源（ソース）ではないので、ソースファイルのことをスクリプトと呼ぶことがあります。また、インタープリタ型言語のことをスクリプト言語ということもあります。スクリプト言語では、スクリプトに記述されたコードはインタープリタと呼ばれるプログラム(アプリケーション)によって一つずつ読み取られ、実行されていきます。\n実際にはスクリプトファイルのテキスト文をそのまま読み取っていくのはインタープリタにとって不便なので、まずスクリプトはバイトコードと呼ばれるマシン語に似たものに変換されます。そのあと、バイトコードの中の命令が1行ずつ読み取られながらインタープリタによって実行されていくわけです。インタープリタはスクリプトからバイトコードを生成する作業と、バイトコードの命令を読み取って実行する作業を両方担当しています。Pythonインタープリタのうち、バイトコード実行を行う部分だけを指して、Pythonヴァーチャルマシン(PVM)と呼びます。\n\n\n\npvm\n\n\nPythonがバイトコードを生成するプロセスのことをコンパイルもしくはバイトコンパイルと呼ぶことがあるので注意が必要です。コンパイル言語でのコンパイルと違い、Pythonのバイトコンパイルはマシン語を生成しません。\n試しに”Hello world!“と印字するPythonのプログラムをバイトコンパイルしてみましょう。まず、このプログラムのPythonスクリプトは次のようになります。\nprint(\"Hello world!\")\nこのコードをバイトコンパイルして出来たバイトコードをダンプすると、以下のようになります。\n00000000: 550d 0d0a 0000 0000 7a7f bb60 1600 0000  U.......z..`....\n00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................\n00000020: 0002 0000 0040 0000 0073 0c00 0000 6500  .....@...s....e.\n00000030: 6400 8301 0100 6401 5300 2902 7a0d 4865  d.....d.S.).z.He\n00000040: 6c6c 6f2c 2057 6f72 6c64 214e 2901 da05  llo, World!N)...\n00000050: 7072 696e 74a9 0072 0200 0000 7202 0000  print..r....r...\n00000060: 00fa 0868 656c 6c6f 2e70 79da 083c 6d6f  ...hello.py..&lt;mo\n00000070: 6475 6c65 3e01 0000 00f3 0000 0000       dule&gt;.........\nHello, World!の文字列は0x3eバイトの位置(4865 6400...)から0x4a(...6c64 21)までにあります。よく似ていますが、これはバイトコードであり、マシン語ではありません。Pythonヴァーチャルマシンは、このバイトコードを実行していきます。\nバイトコードの特徴は、マシン語で記述されたコンパイル言語の実行可能ファイルと違って、CPUの仕様に依存していないことです。したがって、バイトコードはそのまま他のコンピュータで実行することができます。一方で、直接レジスタに命令を送り込むコンパイル言語に比べると、ヴァーチャルマシンを介さなくてはならないスクリプト言語はかなり低速になり、往々にして100倍くらいの実行時の速度差が出てしまいます。\nしかしながら、コンパイルの必要がないので、インタープリタ言語による開発時間はコンパイル言語よりもはるかに早いのが普通です。(C言語で書かれた非常に大きなプログラムですと、コンパイルだけで数時間かかってしまうこともあります。たとえばnode.jsというjavascriptのインタープリタをコンパイルすると半日くらいかかります。)\nこのコンパイル型言語とインタープリタ型言語の違いを利用して、Python等のインタープリタ型言語でスピーディにプロトタイプを作成し、その後、少しずつコンパイル型言語に置き換えていくという開発上の作戦が取られることも良くあります。\nもう一つ、皆さんに覚えておいて欲しいのは、インタープリタそれ自体がプログラムであり、これは通常コンパイル型言語で作成(実装)されているということです(ただしPyPyのような例外はあります)。たとえばPythonのインタープリタで最も一般的なのはC言語で実装されたCPythonというインタープリタで、ほとんどの方が使っているPythonはこれです。CPythonのソースコードは公開されているので誰でも読むことができ、C言語を知っていれば内容を理解できます。他にもJavaで実装されたJythonというインタープリタもあります。\n注)最近では、JITコンパイルという技術が発展し、Juliaのような双方の利点を取り入れた次世代型の言語が複数現れてきました。これにより、インタープリタ型言語とコンパイル型言語の境界線は不明瞭になりつつあります。\n\n\n\nなおプログラミング言語の中には、アセンブリ言語という特別なタイプの言語があります。アセンブリ言語は、01の並びであるマシン語を分かりやすい記号の列に「直訳」したものです。直訳したものですので、マシン語とアセンブリ言語はどちらの方向にでも変換可能です。アセンブリ言語からマシン語を生成する作業をアセンブル、その逆を逆アセンブルと言います。アセンブルを行うためのソフトウェアをアセンブラと呼びます。アセンブリ言語の特徴の一つは、マシン語の直訳であるため、レジスタの操作をプログラマが明示的に行う必要があるということです。\nたとえば、次のC言語のプログラムは、aという変数に1を代入し(正確には1という値で初期化し)、そのあとaに2を足すというだけのプログラムです。\nint MyAdd(void){\n  int a = 1;\n  a = a + 2;\n  return a;\n}\nこれをコンパイルして出来たオブジェクトファイルを逆アセンブルすると、次のようなアセンブリ言語のコードが得られます。\nmyadd.o:     file format pe-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;MyAdd&gt;:\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   48 83 ec 10             sub    rsp,0x10\n   8:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1\n   f:   83 45 fc 02             add    DWORD PTR [rbp-0x4],0x2\n  13:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  16:   48 83 c4 10             add    rsp,0x10\n  1a:   5d                      pop    rbp\n  1b:   c3                      ret\n  1c:   90                      nop\n  1d:   90                      nop\n  1e:   90                      nop\n  1f:   90                      nop\n\n\n\nassembly\n\n\nここでは詳しく説明できませんが、上のコードにおいて、rbpやrsp、eaxは全てレジスタの名前を表します。このように、アセンブリ言語では、レジスタを直接操作することが必要になってきます。(ちなみに”DWORD PTR [RBP-0X4]“などはメモリの領域を表します。)\nアセンブルと違ってコンパイルは不可逆変換なので、実行可能ファイルからコンパイル前のソースコードを復元することはできません。従って実行可能ファイルを分析するときは、通常、逆アセンブルを行ってアセンブリ言語に翻訳し、これを読解していきます。例えば、コンピュータウィルスの性質を解析する際にこういったスキルが必要になります。\nLinuxを使っている人は次のようにしてコンパイルと逆アセンブルを行うことができます。上のソースファイル名をmyadd.cとします。\ngcc -c myadd.c\nobjdump -d -M x86-64,intel myadd.o\nここでmyadd.oはコンパイルによって生成されたオブジェクトファイルです。\nAnaconda仮想環境にNASM(Netwide Assembler)をインストール済みの人は、アセンブリ言語のソースを書いてアセンブルしてみることもできます(NASMをインストールしていない人は、手順だけ追っておきましょう。)\n次のコードは、x86-64系PCのWindowsでしか動作しないNASMのコードで、Hello, World!を出力するものです。\n;hello.asm\nextern printf\nsection .data\n    msg db  \"Hello,World!\",0\nsection .text\n    global main\nmain:\n    mov rcx,msg\n    sub rsp,32\n    call printf\n    add rsp,32\nleave\nret\nこれをhello.asmという名前のファイルにノートパッド等を使ってコピー＆ペーストして保存します。\nアセンブルはAnaconda Promptで以下のように行います。\nnasm -f win64 hello.asm -l hello.lst\nアセンブルされたオブジェクトファイルはhello.objという名前で保存されます(hello.oではないので注意)。また、hello.lstファイルには、ソースコードの各命令とマシン語の対応表が出力されます。\n     1                                  ;hello.asm\n     2                                  extern printf\n     3                                  section .data\n     4 00000000 48656C6C6F2C20576F-         msg db  \"Hello, World!\",0\n     4 00000009 726C642100\n     5                                  section .text\n     6                                      global main\n     7                                  main:\n     8 00000000 48B9-                       mov rcx,msg\n     8 00000002 [0000000000000000]\n     9 0000000A 4883EC20                    sub rsp,32\n    10 0000000E E8(00000000)                call printf\n    11 00000013 4883C420                    add rsp,32\n    12 00000017 C9                      leave\n    13 00000018 C3                      ret\n1列目はメモリに配置されるときの相対的な位置をバイト数で表したもの、2列目は機械語の命令もしくはデータ、3列目は対応するアセンブリコードです。\nこれをみると分かるように、アセンブルされたマシン語の命令は、ソースコードの命令と全く同じ順序で並んでいることが分かります。\nhello.objをダンプしてみることにより、これらが実際に近接して配置されていることを確かめることができます。Git bashターミナルでhello.objを16進ダンプしてみましょう。\nxxd hello.obj\n...(前略)...\n00000040: 7400 0000 0000 0000 0000 0000 1900 0000  t...............\n00000050: 7200 0000 8b00 0000 0000 0000 0200 0000  r...............\n00000060: 2000 5060 4865 6c6c 6f2c 2057 6f72 6c64   .P`Hello, World\n00000070: 2100 48b9 0000 0000 0000 0000 4883 ec20  !.H.........H..\n00000080: e800 0000 0048 83c4 20c9 c302 0000 0002  .....H.. .......\n00000090: 0000 0001 000f 0000 0007 0000 0004 002e  ................\n...(後略)...\n第0x64バイト位置の4865 6c6c ...から0x70バイト位置の6c64 21までの13バイトがHello, World!です。また、その直後0x72位置の48b9 0000...から0x8aバイト位置...20c9 c3までが命令コードです。\n\n\n\n\nアセンブリ言語のように、レジスタやメモリといったハードウェアを直接操作する言語を低水準言語と呼びます。低水準言語は、抽象度が低い言語と表現されることもあります。一方、Pythonのように、レジスタやメモリと言ったものをプログラマが直接意識することなくプログラミングできるような言語は、高水準言語と呼ばれ、抽象度が高いと言われます。一般に、インタープリタ型言語のほうがコンパイル型言語よりも抽象度が高い傾向があります。また、時代が進むにしたがって、より高水準で抽象度の高い言語が登場してきたと言えます。\n高水準言語や低水準言語というのは、相対的なものであるととらえた方が良いでしょう。たとえば、従来C言語はアセンブリ言語と比較して高水準言語であると言われてきましたが、言語の高水準化が進むにつれ、たとえばPython等に比べると低水準言語であると言われるようにもなってきました。というのも、C言語ではレジスタを意識することはほとんどありませんが、メモリはかなり意識しないとコードが書けないからです。一方、Pythonでは、C言語よりも抽象度が高く、比較的メモリを意識しなくてもプログラミングができるようになっています。それでも、以降の講義で論じるように、メモリをある程度意識することはPythonを正しく使う上で重要であると言えます。\n\n\n\n当たり前ですが、プログラミングの上達において最も大切なことは、「プログラミングを楽しむ」ことだと思います。そのために大切なことは、「ストレスなくコーディングする」ということに尽きると思います。そして、そのためには、以下の2点が重要であると筆者は考えます。\n\n正しいタイピングをする\nエディターのキーバインドをマスターする\n\nもう一つコツを挙げるとすれば、誰もが言うことですが、コードを試すときは、写経するということです。写経とは、コードをコピー＆ペーストしたり、すでに他人が入力したコードを実行するのではなく、自分でタイピングして書き写すことです。\n\n\n正しいタイピングとは、タッチタイピング（いわゆるブラインドタッチ）のことです。タッチタイピングを解説したサイトはインターネットにたくさんありますので、ここでは改めて解説しません。以下の項目に注意して練習を重ねてください。\n\n最初は決して速く打とうとしてはいけない\n同じキーはいつも同じ指で叩く\nキーを叩くときは、基本そのキーに最も近い指で叩く\nキーボードを見ないでタイプするトレーニングをする\n人差し指～小指すべて使う\n\n数字や記号はつらいので、まずはアルファベットだけキーボードを見ないで打てるようになるように練習しましょう。そのうち見ないで打てるキーの数が増えてきます。タイピングソフトなどは必要ありません。ゆっくりで良いので、タッチタイピングの基本を守りつつプログラミングや文書作成をしていれば、自然に上達していきます。\n上達につれてタイプの速度は上がってきますが、目安として大体1分間に200タイプくらいでスピード的には十分ではないでしょうか。重要なのはストレスを無くすことであって、速度を上げることではありません。ゆっくりでもキーボードを見ずに正確に打てるようになれば、視線の移動がほとんど必要なくなるので、コーディング中に感じるストレスは圧倒的に小さくなります。\n\n\n\nコーディングのストレスを軽減するには、正しいタイピングを心がけるだけでなく、キーバインドを覚えることが重要です。本講義で言うキーバインドとは、編集中に文書の中を移動したり、編集に関連する様々な機能を呼び出したりするためのキーボードショートカットのことです。\nプログラミングの世界には大きく分けて、2種類のメジャーなキーバインドがあります。1つはEmacsキーバインド、もう一つはviキーバインドです。これらは、それぞれ、Emacs、viというエディターで用いられているキーバインドですが、多くのエディターでこれらの2つのキーバインドを使用することができるようになっています。\nEmacsキーバインドは直観的で覚えやすいのが特徴で、viキーバインドは「速い」のが特徴です。筆者はプログラミングにEmacs、設定ファイルなどの編集にviを使うという風に使い分けていますので、本講義でもプログラミングのためにはEmacsキーバインドを用いることを推奨したいと思います。Emacsキーバインドについては次回VS Codeを操作するときに詳しく説明します。\n\n\n\nコードを写経することにより、自分で書いてみると、そっくりそのまま書き写したはずがうまく動作しないということが往々にして生じます。その度に、「どこが間違っていたのか」考えさせられることになり、細部に目が行くことになります。また、単純にタイピングの練習にもなります。\n写経は、最初のうちは苦行かもしれません。前時代的なトレーニングと思われるかもしれません。なかなか先に進めないのでじれったい気持ちになるかもしれませんが、これは必要なプロセスです。どれだけプログラミングが上手になっても、皆さん写経をしておられます。逆に写経がストレスなくできるようになったら、一人前だと考えてください。\nしたがって、本講義では、入力済みのコードを配布しないことにします。どうしてもコピー＆ペーストが必要なときは、このサイトから行えばよいでしょう。\n\n\n\n\n今回は、以下の事項について学びました。\n\nPythonを学ぶ意義\nPythonを動かす2種類の基本的な方法\n本講義の目標\nプログラムがどのように動いているか\nプログラミング言語にはどのようなものがあるか\nプログラミング上達のコツ\n\n今回の講義でPythonのプログラムがどのように動いているか、大体分かったと思います。一方で、一つ一つのPythonの文がどのように動作しているのかまでは説明しませんでした。そういった詳細については今後の講義で解き明かして行くことにしましょう。\n基本的なプログラミングの練習は、基本的に独学でも可能なものです。自宅や研究室のパソコンにもPythonをインストールし、教科書を参照しながらPythonの操作をしっかりと練習しておいてください。\n\n\n\n\n『プログラムはなぜ動くのか(第2版)』(矢沢久雄 著/日経ソフトウェア監修) (2007) 日経BP社. ISBN 978-4-8222-8315-5.\n『Beginning x64 Assembly Programming』(Jo Van Hoey 著)(2019) Apress. ISBN-13: 978-1484250754.\n\nどちらも読み易い名著です。特に2は非常に英語が平易です。1はBorland C++/Windowsを仮定していますが、2はNASM/Ubuntu 18.04を仮定しています。\n\n\n\n\nここでは、メモリの上で整数や小数がどのように表現されているかを説明します。\n\n\n符号なし整数とは、正整数のみを表すことができるデータ型のことです。符号なし整数がメモリ上に記録される方法は特に難しいことはありません。単に正整数の2進数表現がそのまま格納されているだけです。例えば、2バイト=16ビットの領域に14という整数が格納されるときは、\n00000000 00001110\nのように格納されます。\n\n\n\n符号つき整数では、負の数と正の数を表すことができます。符号付き整数では、最も桁の大きいビットを符号を表すために用います。この符号ビットが0ならば0か正の整数を、1ならば負の整数を表します。残りの桁は、正整数ならば、符号なし整数と同じで、元の正数の2進数表現になっています。\n一方、負の数の場合は、元の数の絶対値の2の補数になっています。数nの2の補数とは、nのビット(0と1)を反転して、1をプラスしたものです。\nたとえば、14は上記のように表されますので、そのビットを反転したものは、\n11111111 11110001\nとなりますので、これに1を足したものは、\n11111111 11110010\nになります。これが-14の2の補数表現であり、メモリ上で-14という負数はこのように格納されています。\n実際、14と-14を足すと0になることが次のようになります。\n  00000000 00001110\n+ 11111111 11110010\n-------------------\n1 00000000 00000000\n一番左のあふれた一桁は無視されるので、和は0になることが分かります。\n符号つき整数の絶対値の上限は、符号なし整数の約半分になります。\n\n\n\nバイト数\n符号つき整数\n符号なし整数\n\n\n\n\n1\n-128 ～　127\n0 ～ 255\n\n\n2\n-32,768 ～ 32,767\n0 ～ 65,535\n\n\n4\n-2,147,483,648 ～ 2,147,483,647\n0 ～ 4,294,967,295\n\n\n8\n-2**63 ～ 2**63-1\n0 ～ 2**64-1\n\n\n\n即席ですが、任意の整数を2の補数表現に変換するPython関数を作りましたので参考にしてください(バグを見つけたら教えてください。)関数についてはまだ学んでいないので、現時点でこの関数を使える必要はありません。\n# %%\n# 整数を2の補数表現に変換する関数\ndef int_to_bits(num,length,endian='big'):\n    if type(num) is int:\n        num_bytes = num.to_bytes(length,endian,signed=True)\n        num_bin = bin(int(num_bytes.hex(),16))\n        if len(num_bin)-2 &lt; length * 8:\n            bit_str = (\"0\"*(length*8-len(num_bin)+2)) + num_bin[2:]\n        else:\n            bit_str = num_bin[2:]\n        byte_list = [bit_str[8*i:8*i+8] for i in range(length)]\n        print(\" \".join(byte_list))\n    else:\n        print(\"The first argument must be an integer.\")\nこの関数は次のように使います。\nint_to_bits(整数,バイト数,エンディアン)\nエンディアンは指定しなくても構いません。指定しない場合はビッグエンディアンになります(エンディアンについては下で説明しています)。\nたとえば、4バイト符号つき整数の-255を2の補数表現にするには、次のようにします。\nint_to_bits(-255,4)\n# 出力\n11111111 11111111 11111111 00000001\nリトルエンディアンにするときは、第3引数を’little’に指定してください。\nint_to_bits(-255,4,'little')\n# 出力\n00000001 11111111 11111111 11111111\n\n\n\n小数は、浮動小数点数というデータ型でメモリに格納されます。浮動小数点数には単精度浮動小数点数と倍精度浮動小数点数があります。単精度では一つの数値に32ビット(4バイト)、倍精度では64ビット(8バイト)を使います。\n浮動小数点数がどのように小数をメモリ上で表現するのか、単精度の場合を例にとって説明します。\nまず、全ての実数は次のように表現できることに注意しましょう。\n[符号] (m)×(10のn乗)\nただし、mは0.xxx...という形式の10進数小数です。たとえば、-123.45は、次のように表すことができます。\n- (0.12345)×(10の3乗)\nmを仮数、nを指数と呼びます。\n全く同様に、全ての実数は次のように表現できます。\n[符号] (m) * (2のn乗)\nただし、mは1.xxx...という形式の2進数小数です。たとえば、2進数小数101.1011は、次のように表すことができます。\n+ (1.011011)×(2の2乗)\nそこで単精度浮動小数点では、下図のように32ビットを上の桁から順に1ビット、8ビット、23ビットに区切り、それぞれ符号、指数、仮数を表すのに使います。\n\n\n\nfloat\n\n\nただし、仮数は常に1.xxx...という形をしているので、\"1.\"を省略し、xxx...の部分だけを23ビットに記憶します。たとえば、仮数が1.011011であれば、浮動小数点数の仮数部分23ビットは\n01101100 00000000 0000000\nのようになります。また、指数部分は、正負どちらの値でもありえますが、ここでは負の数を表すのに補数は使いません。代わりにイクセス表現を使います。イクセス表現では、指数部分8ビットを0～255の符号なし整数と見なしたとき、そこから、ちょうど中間の値127を引いたものを実際の指数とする表現方法です。\nたとえば、指数部分に記憶されているビット列が次のようになっていたとします。\n10000001\nこれは10進数符号なし整数に読み替えると129です。ここから127を引くと2ですので、実際の指数は2ということになります。\nまとめると、符号部分のビット、指数部分のビット列、仮数部分のビット列がそれぞれ\n# 符号ビット\n1\n# 指数部分8ビット\n10000001\n# 仮数部分23ビット\n01101100 00000000 0000000\nのようになっているとき、この単精度浮動小数点数は、\n[-] (1.011011)×(2の2乗) = -101.1011\nを表すことになります。これを10進数で表すと、-5.6875になります。言い換えると、-5.6875という小数は、浮動小数点数によって\n1-10000001-01101100 00000000 0000000\nという32ビットでメモリ上に記憶されていることになります。\nさて、上記の仮数部分を16進数で表し、指数部分をイクセス表現でなく実際の指数(10進数)に書き換えると、次のようになります。\n1-(+2)-6c 00 00\nただし右端の0だけは3ビットしかありませんので注意してください。\n倍精度の浮動小数点数ですと、仮数部分は52ビット=6バイト+4ビットありますので、-5.6875はメモリ上で、\n1-(+2)-6c 00 00 00 00 00 0\nと記憶されます。“6c”に続いて0が11個あることに注意してください。Pythonでは、この表現を次のようにして出力することができます。\n&gt;&gt;&gt; (-5.6875).hex()\n'-0x1.6c00000000000p+2'\nここで、pのあとの+2が指数、0x1.のあとの6c00000000000が指数部分に記録されているビット列を表します。\n\n\n\nエンディアンは、複数バイトを使う数値や文字が、どのバイトから先にメモリに格納されるかを表します。下の桁のバイトから順に格納されていく方式をリトルエンディアン、上の桁のバイトから順に格納されていく方式をビッグエンディアンと呼びます。エンディアンはCPUに依存しますが、現在パソコンで使われているCPUの多くはリトルエンディアン方式です。\nリトルエンディアンでは、下の桁のバイトのほうが上の桁よりもメモリ上で若いアドレスに格納されますので、例えば16ビット整数型としてメモリに保存された整数14をダンプすると、次のように、バイトが入れ替わって画面に表示されます。\n# 14はリトルエンディアンではこう見える\n00001110 00000000\n一方、ビッグエンディアンでは、上の桁のバイトのほうが下の桁よりも若いアドレスのメモリに格納されますので、14が格納されたメモリ領域をダンプすると、次のように画面に表示されます。\n# 14はビッグエンディアンではこう見える\n00000000 00001110\nこのように、下の桁から若いアドレスに順番に格納していくリトルエンディアン方式は、発想において自然ですが、ダンプしたときにひっくり返って表示されるので、読みにくいという難点があります。一方ビッグエンディアンでは表示された順そのままで読むことができます。\nエンディアンは普段はほとんど意識する必要がありませんが、文字や数値のバイト列表現を扱うときに、どうしても避けられない話題となってきますので、頭の片隅においておく必要があります。"
  },
  {
    "objectID": "programming2025/programming-1.html#pythonの実行方法",
    "href": "programming2025/programming-1.html#pythonの実行方法",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "まずはPythonを動かしてみましょう。Pythonを動かすには、様々な方法がありますが、そのうち、代表的なものは次の3つです。\n\nREPLで一行ずつ対話的(インターラクティブ)に実行\nPythonスクリプトを作成してコマンドラインから実行\nVSCode内でセル(コードブロック)ごとに対話的に実行(第2回講義参照)"
  },
  {
    "objectID": "programming2025/programming-1.html#replによる対話的実行",
    "href": "programming2025/programming-1.html#replによる対話的実行",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "まずはREPL(Read-Eval-Print Loop)を用いた対話的実行を行ってみましょう。\nウィンドウズを起動して、画面の左下の検索ウィンドウにAnacondaと打ち込んで、Anaconda Promptを起動しましょう（Anaconda Powershell Promptでも構いません）。Anacondaを起動したら、pythonと入力し、pythonの対話的インタープリタREPLを起動しましょう。プロンプトと呼ばれる\"&gt;&gt;&gt;\"記号が現れて、入力待ちの状態になります。\nREPLは、Pythonのコードを1行ごとに評価し、即時にその結果を表示してくれるシステムです。小さなコード断片の挙動を確かめる際などに便利です。\nPythonには、整数や計算式などはそれ自体がPythonのコードと見なされるという特徴があります。そのおかげで、PythonのREPLを計算機として用いることができます。たとえば、何でも良いので、簡単な足し算や引き算をREPLに入力してみましょう。（入力の最後にはEnterキーを押します。）\n&gt;&gt;&gt; 1 + 1\n2\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 3 * 2\n6\n&gt;&gt;&gt; 8 / 2\n4.0\n&gt;&gt;&gt; 11 // 3\n3\n&gt;&gt;&gt; 11 % 3\n2\n&gt;&gt;&gt; 5 ** 3\n125\nこのように、REPLは簡単な計算機として用いることができます。なお、Pythonにおける2項算術演算子は以下の通りです。\n\n\n\n演算子\n機能\n\n\n\n\n+\n可算\n\n\n-\n減算\n\n\n*\n乗算\n\n\n**\nべき乗\n\n\n/\n除算\n\n\n//\n整数除算（余りを切り捨て）\n\n\n%\n剰余\n\n\n\n上記の表は教科書のセクション3.1にもありますので確認しておいてください。\nなお3つ以上の数の演算を行うには、演算子の優先順位に気を付けなければならないのはRと同じです。たとえば\n&gt;&gt;&gt; 2 + 3 * 5\n17\nのように掛け算は足し算よりも先に評価されます。演算子の評価順序を明確にしたいときは、丸カッコを使います。\n&gt;&gt;&gt; (2 + 3) * 5\n25\n演算子の優先順位については教科書のセクション3.6(pp. 107)に解説がありますので、読んでおいてください。ただし、計算式においては、演算子の評価順序には頼り過ぎると読みにくいコードになってしまうので、むしろ丸カッコを積極的に使うことが望ましいです。\n\n\n次の計算をPythonで実行したらどのような結果が得られるかを予測しなさい。\n# Q1\n&gt;&gt;&gt;(5 % 3) ** (7 // 2)\n# Q2\n&gt;&gt;&gt;(5.5 - 2.5 + 3.0) * 2.0\n上記Q1, Q2の予測をREPLで確かめられたら、同じように様々な計算を自分で考えてREPLで実行し、予測と一致するか確かめなさい。\n\nそれでは、次にもう少し高度なことをしてみます。以下のように入力して、変数xに整数1を代入し、xの値を表示してみましょう。\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; x\n1\nこのように、‘=’記号を使うと左辺の変数に右辺の値を代入できます。(Rでは、同様の操作に’&lt;-’という矢印演算子を用います。)\nそれでは、さらに変数を用いて色々な演算をしてみましょう。\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 2\n&gt;&gt;&gt; x + y + 3\n6\n&gt;&gt;&gt; z = y + 1\n&gt;&gt;&gt; x - z\n-2\n&gt;&gt;&gt; x = z ** y\n&gt;&gt;&gt; x\n9\n&gt;&gt;&gt; x = x - 1\n&gt;&gt;&gt; x\n8\nこのように、変数は演算の中で用いることができます。\n最後に”Hello, World!“を出力しておきましょう。これについても、Rと全く同じですので、説明はほとんど要らないでしょう。(実際、Rのコードと見分けがつきません。)\n&gt;&gt;&gt; print(\"Hello, World!\")\nHello, World!\nRと同じように、ダブルクォーテーションでくくられた部分は、Pythonにより文字列と解釈されます。printは、引数に与えられた文字列や数を画面に出力するだけの関数です。\nREPLを終了してAnaconda promptに戻るときは、次のように入力します。\n&gt;&gt;&gt;exit()"
  },
  {
    "objectID": "programming2025/programming-1.html#コマンドラインによる実行",
    "href": "programming2025/programming-1.html#コマンドラインによる実行",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それでは次に、Pythonのコードをファイルに保存してコマンドラインから実行する方法を試してみましょう。Anaconda promptで次のように入力し、メモ帳を起動してください。\n(base) C:\\Users\\hogehoge&gt;notepad\nメモ帳が起動したら、次のように記述して、保存しましょう。保存する際、ファイル名はhelloにしてください。\nprint(\"Hello, World!\")\n次にファイルを保存して閉じ、Anaconda promptで次のように入力すると、ファイルに記述したPythonコードを実行することができます。\n(base) C:\\Users\\hogehoge&gt;python hello.txt\nHello, World!\n\nなお、Pythonコードを記述するファイル（スクリプトと呼ぶ）の名前には.txtではなく拡張子.pyを付けるのが普通ですので、覚えておきましょう。\nそれではもう一度同じファイルを開いて、もう少し中身を豪華にしてみましょう。\nprint(\"Hello, World!\")\nx = 1\ny = 2\nz = x + y\nprint(x)\nprint(y)\nprint(z)\nこれを実行すると、以下のようになります。\n(base) C:\\Users\\Kobayashi&gt;python hello.txt\nHello, World!\n1\n2\n3\n\nこのように、Pythonでは、文を改行で区切って並べることにより、上から順番に文が実行されていきます。文については教科書のセクション1.5.2に詳しい説明があるので良く読んでおいてください。\n\n\n5の5乗を計算して画面に出力するpower5_5.pyというファイルを作成し、実行しなさい。"
  },
  {
    "objectID": "programming2025/programming-1.html#進数と16進数",
    "href": "programming2025/programming-1.html#進数と16進数",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "2進数や16進数については、多くの方が高校や大学で学んだことがあることでしょう。しかしながら、以降の説明で非常に重要ですので、ここでこれらの概念を簡単に復習しましょう。\nご存じの通り、私たちが普段使っている10で桁上がりする数字は、10進数と呼ばれます。一方、2で桁上がりする数を2進数、16で桁上がりする数を16進数と呼び、情報科学では10進数と並んで良く用いられる数の表し方です。\n2進数では、2で桁上がりするため、10進数における2～9の数字は現れません。また、16進数では、10進数における0～9だけでは1桁を表すのに足りないため、a～fのアルファベットを用います。具体的には、3つの数表記には、以下のような関係があります。\n\n\n\n10進数\n2進数\n16進数\n\n\n\n\n0\n0\n0\n\n\n1\n1\n1\n\n\n2\n10\n2\n\n\n3\n11\n3\n\n\n4\n100\n4\n\n\n5\n101\n5\n\n\n6\n110\n6\n\n\n7\n111\n7\n\n\n8\n1000\n8\n\n\n9\n1001\n9\n\n\n10\n1010\na\n\n\n11\n1011\nb\n\n\n12\n1100\nc\n\n\n13\n1101\nd\n\n\n14\n1110\ne\n\n\n15\n1111\nf\n\n\n16\n10000\n10\n\n\n\nある数が2進数で表記されていることを明確にするため、2進数の先頭に0bという接頭辞を付けることがあります(bはbinaryより)。同様に16進数には接頭辞0xをつけます(xはhexadecimalより)。たとえば、0x1eは0b11110すなわち10進数での30を表します（分かりましたか？）。\n10進数、2進数、16進数の間の変換に慣れておきましょう。とくに2進数と16進数の間の変換は重要です。これは全く難しくありません。インターネットなどにいくらでも情報がありますので、練習しておきましょう。\n10進数、2進数、16進数の間の変換は、Pythonを用いても行うことができます。次のPythonコードは、それぞれ、10進数の123を2進数、16進数に変換するものです。\n&gt;&gt;&gt; bin(123)\n'0b1111011'\n&gt;&gt;&gt; hex(123)\n'0x7b'\nこのように関数binとhexを使えば10進数をそれぞれ2進数、16進数に変換することができます。\nまた、逆の変換をするときは、次のように数字を入力するだけです。\n&gt;&gt;&gt; 0b1111011\n123\n&gt;&gt;&gt; 0x7b\n123"
  },
  {
    "objectID": "programming2025/programming-1.html#コンピューターの仕組み",
    "href": "programming2025/programming-1.html#コンピューターの仕組み",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "パソコンは、様々な部品から構成されていますが、プログラミングの初心者がまず知っておかなければならないのが、CPUとメインメモリの働きです。メインメモリはランダムアクセスメモリ(Random Access Memory)とも呼ばれるので、RAMと表記されることもあります。\nCPUとメモリ(メインメモリ)は、記憶装置です。パソコンにはいくつもの記憶装置が内臓されていますが、どの記憶装置も、文字や整数や小数だけでなく、プログラムなど、すべての情報を0と1の配列に変換して記憶しています。\nCPUとメモリはどちらもトランジスタで構成された集積回路(IC, Integrated Circuit)ですが、次のような性質の違いがあります。\n\n\n\n\nCPU\nメモリ\n\n\n\n\n記憶容量\n非常に小さい\n大きい\n\n\n演算能力\n有り\n無し\n\n\n\nここで言う演算とは、足し算や引き算を含む様々な計算のことです。CPUは演算機能をもっていますが、ほんの少しの情報しか記憶できないので、CPUだけではちょっとしたプログラムも動かせません。そこで、まず容量の大きいメモリにプログラム全体を読み込ませます。プログラムは、CPUに対する命令の集まりです（と思って大体間違いありません）。CPUは、メモリに読み込んだ命令を１つずつ読み取って実行していきます。それでは、次に、プログラムなどの情報がどのようにメモリに保存されているのかを見ていきましょう。"
  },
  {
    "objectID": "programming2025/programming-1.html#メモリの仕組み",
    "href": "programming2025/programming-1.html#メモリの仕組み",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "メモリは、たとえば001011010110001101011…のように、全ての情報を0と1の並びに変換して記憶しています。この0と1の並びは、8桁ずつの区画に区切られています。それぞれの区画には、アドレスと呼ばれる数字が振られていて、数字によってメモリ上の位置が指定できるようになっています。\nそれぞれの区画には、8桁の0と1が格納されているので、1つの区画は00000000から11111111までの256通りの状態を記憶することができます。この記憶容量のことをバイト(Byte)といいます。一方、1桁の0と1で記憶できる容量のことをビット(bit)と呼びます。よって、\n1バイト = 8ビット\nの関係が成り立ちます。\nメモリへの情報の読み書きは、必ずバイトを単位として行われます。ビットを単位として読み書きすることはできません。このように、バイトはパソコンにおける最も重要な情報量の単位です。\n\n\n\nmemory\n\n\nメモリについて考えるときは、上図のように、バイト単位のデータが積み重なったものと考えると良いです。上図では、合計128バイトの容量をもつメモリのイメージを図示しています。なお、バイトよりも大きい情報量の単位には、キロバイトやメガバイト、ギガバイトなどがあります。\n\n\n\n情報量の単位\nバイト換算\n\n\n\n\nキロバイト(KB)\n10の3乗=1,000バイト\n\n\nメガバイト(MB)\n10の6乗=1,000,000バイト\n\n\nギガバイト(GB)\n10の9乗=1,000,000,000バイト\n\n\nテラバイト(TB)\n10の12乗バイト\n\n\nペタバイト(PB)\n10の15乗バイト\n\n\nエクサバイト(EB)\n10の18乗バイト\n\n\nキビバイト(KiB)\n2の10乗=1,024バイト\n\n\nメビバイト(MiB)\n2の20乗=1,048,576バイト\n\n\nギビバイト(GiB)\n2の30乗=1,073,741,824バイト\n\n\nテビバイト(TiB)\n2の40乗バイト\n\n\nペビバイト(PiB)\n2の50乗バイト\n\n\nエクスビバイト(EiB)\n2の60乗バイト\n\n\n\nなお、キロバイト、メガバイト、ギガバイトという言葉が使われている場合でも、実際にはキビバイト(KiB)、メビバイト(MiB)、ギビバイト(GiB)を指す場合があるので、多少の注意が必要です。本講義でも、キビバイトやメビバイトは余り親しみのない言葉ですので、KiBやMiBと書いてキロバイト、メガバイトと発音しても良いことにします。ご注意ください。なおキビバイトとキロバイトの容量差は2%しかありませんので、通常この違いに神経質になる必要はありません。ギガバイトとギビバイトになると、7%の違いがありますので、ちょっと無視できないかもしれません。"
  },
  {
    "objectID": "programming2025/programming-1.html#cpuの働き",
    "href": "programming2025/programming-1.html#cpuの働き",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "一方、CPUはレジスタと呼ばれる記憶装置を複数内臓しています。レジスタは、プログラム内の命令やデータ、メモリのアドレスなどを格納することができます。CPUはメモリに読み込まれたプログラムの中の命令をレジスタに読み込こんで実行したり、メモリのなかのデータをレジスタに読み込んで演算をほどこしたり、演算の結果をメモリに書き込んだりすることでコンピュータを動かしています。\nレジスタにはプログラマがプログラムから直接操作できるもの(数十個ある)と操作できないものがあります。プログラマが意識しなくてはならないのは前者の操作できるレジスタだけです。具体的にどのようなレジスタがいくつあるのかについては、CPUによって違ってきます。\nレジスタは、メモリと全く同じように0と1の情報を格納できます。レジスタには、64ビットコンピュータでは64ビット=8バイトの情報を格納することができます。32ビットコンピュータでは4バイトです。したがって、プログラムが一つのレジスタを使って一度に処理できるデータの量は64ビットコンピュータなら最大8バイト、32ビットコンピュータなら最大4バイトです。\nただし64ビットレジスタは下位の32ビットを使って32ビットレジスタとしても動作できるようになっています。従って、64ビットコンピュータでも、32ビット仕様のOSやアプリケーションが動作します。\n32ビットレジスタのサイズが4バイトであることに合わせて、32ビットOSはメモリのアドレスを4バイトで表現します。\n\n\n\n\n\n\n\n\n\n\n2進数表記\n16進数表記\n10進数表記\n\n\n\n\n最小の数字\n0b0\n0x0\n0\n\n\n最大の数字\n0b1111...1111\n0xffffffff\n4,294,967,295=2の32乗-1\n\n\n\n0xffffffff=4,294,967,295=0b1111…1111であることはPythonで簡単に確かめることができます。\n&gt;&gt;&gt; 0xffffffff\n4294967295\n&gt;&gt;&gt; bin(0xffffffff)\n'0b11111111111111111111111111111111'\n4バイトの数値が表現できるメモリアドレスの範囲は、上記の表にあるように0～2の32乗-1=4×2の30乗-1です。メモリは1区画あたり1バイトの容量をもつので、32ビットOSでは、4×2の30乗バイト、すなわち4GiBまでしか扱うことができません。したがって、それ以上のメモリを物理的に搭載しても、4GiBを超える部分はOSによって認識してもらえません。\n一方、64ビット対応したOSでは、メモリアドレスの表現に8バイト数値を使用します。したがって(少なくとも理論上は)0～2の64乗-1までのアドレス(16EiB=約18エクサバイト)を表現できます。これは極めて巨大な数ですので、64ビットOSではメモリの上限が問題になることは通常ありません。"
  },
  {
    "objectID": "programming2025/programming-1.html#マシン語",
    "href": "programming2025/programming-1.html#マシン語",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "プログラムがメモリに読み込まれたあと、プログラムを構成する命令は、一つずつCPUに読みだされて実行されていきます。\n\n\n\nregister\n\n\nレジスタは0と1しか格納できないので、命令と命令からなるプログラムもまた、0と1の列でなくてはなりません。(当然、列の長さは8の倍数です。)こうした、CPUが理解できる、0と1で構成された命令をマシン語(機械語)と呼びます。大昔、コンピュータができたばかりでプログラミング言語がまだ存在していなかったころは、プログラマはマシン語を直接編集することでプログラムを作っていました。\n試しに、プログラムが実際にどのようなマシン語になっているかをディスプレイに打ち出してみることができます。これをダンプ(dump)と言います。たとえば、画面に”Hello, World!“と打ち出すプログラムをダンプしてみると、該当箇所は以下のようになります。\n...(前略)...\n00000060: 00100000 00000000 01010000 01100000 01001000 01100101   .P`He\n00000066: 01101100 01101100 01101111 00101100 00100000 01010111  llo, W\n0000006c: 01101111 01110010 01101100 01100100 00100001 00000000  orld!.\n00000072: 01001000 10111001 00000000 00000000 00000000 00000000  H.....\n00000078: 00000000 00000000 00000000 00000000 01001000 10000011  ....H.\n0000007e: 11101100 00100000 11101000 00000000 00000000 00000000  . ....\n00000084: 00000000 01001000 10000011 11000100 00100000 11001001  .H.. .\n0000008a: 11000011 00000010 00000000 00000000 00000000 00000010\n...(後略)...\nここで、1列目はファイルの先頭からのバイト数を16進数で表したものです。0x64バイトから0x70バイトまでがHello, World!という文字列を表し、0x72バイトから0x8aバイトまでが命令です。\nこのように、マシン語は人間にとっては非常に分かりづらいので、マシン語を直接操作しなくてもプログラムが作れるように、C言語などのプログラミング言語が作られました。\nなお、64ビット版のWindows 10にはダンプをするためのツールが標準搭載されていませんが、Gitをインストールするとbashターミナルでxxdコマンドが使えるようになります。一方Linuxにはxxdコマンドが標準で搭載されています。いずれのOSでも、ターミナルで次のように入力すれば実行可能ファイルを2進数にダンプできます。\nxxd -b a.out\nここでa.outが実行可能ファイルの名前です(Windowsの場合a.exeなどになります)。-bは2進数でダンプするオプションです。このオプションを付けないと、結果は16進数で表示されます。"
  },
  {
    "objectID": "programming2025/programming-1.html#プログラミング言語の種類",
    "href": "programming2025/programming-1.html#プログラミング言語の種類",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "プログラミング言語を分類する方法は色々ありますが、まず覚えた方が良いのが、コンパイル型言語とインタープリタ型言語の違いです。\n\n\n\n\n\n\n\n\n\nコンパイル型\nインタープリタ型\n\n\n\n\n実行速度\n高速\n低速\n\n\nコンパイル\n必要\n不要\n\n\n例\nC言語、C++、FORTRAN、RUSTなど\nPython、R、Ruby、Perl、JavaScriptなど\n\n\n\n\n\nたとえばC言語のようなコンパイル型言語で”Hello, World!“を出力するプログラムについて考えましょう。その場合、まず次のようなプログラミング言語で書かれたテキストファイル（ソースファイルあるいはソースコードという）を準備します。\n#include &lt;stdio.h&gt;\nint main(void){\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\nこのファイル名をhello.cとしましょう。その後、コンパイルという操作により、このファイルを機械語に変換します。この操作を実行するソフトウェアのことをコンパイラと呼びます。たとえばLinuxには通常GCC(GNU Compiler Collection)というコンパイラがインストールされています。\nコンパイルを行うと、マシン語で書かれた別のファイルが作成されます。これを実行可能ファイルと呼びます。厳密には、hello.cをマシン語にコンパイルしただけでは実行ファイルにはならず、オブジェクトファイルと呼ばれるマシン語で書かれたファイルが出来上がります。コンパイラはさらにリンクという作業を行い、出来上がったオブジェクトファイルに必要な付属品を色々とくっつけて実行可能ファイルを作ります。\n\n\n\ncompile\n\n\nAnaconda仮想環境(第2回の講義資料参照)にGCCがインストール出来ている人は、実際にコンパイルしてみることができます。(GCCがインストール出来ていない人は、手順だけ追っておきましょう。)Anaconda PromptでGCCがインストールされた仮想環境を起動し、次のように入力してメモ帳を起動しましょう。\nnotepad hello.c\nメモ帳が起動したら、上記のHello, World!のCのソースコードをコピー＆ペーストして、保存し、閉じましょう。\n上記のようにしてソースファイルが作成できたら、以下のようにしてコンパイルします。\ngcc -Wall hello.c -o hello.exe\n-Wallは、コードに不適切な点があれば警告を発してくれるオプションです。また、-o hello.exeは、hello.exeという名前のファイルにコンパイルせよという意味です。\nhello.exeが正しく作成されていれば、Anaconda Promptで次のように入力することで実行できるはずです。\nhello.exe\n出力は以下の通りです。\nHello, World!\nコンパイル型の言語で書かれたソースファイルは直接実行することはできず、かならずコンパイルして実行可能ファイルを作る必要があります。\n実行可能ファイルは、CPUが直接解釈可能なマシン語で書かれているため、非常に高速に動作します。一方で、大きなプログラムはコンパイルに大変時間がかかるという欠点があります。また実行可能ファイルを構成するマシン語は、CPUのレジスタを直接操作する命令の集まりですので、CPUの異なるコンピュータでは動作しません。従って、プログラムを他のコンピュータに移植するときは、移植先のコンピュータでソースコードを再コンパイルする必要があります。\nなお、コンパイルとリンクを分けて行うには次のようにします。\ngcc -c hello.c\ngcc hello.o -o hello.exe\n一つめのコマンドがコンパイルを実行してオブジェクトファイルhello.oを作ります。二つ目のコマンドは、さらにリンクを行って実行可能ファイルhello.exeを作っています。\nオブジェクトファイルや実行可能ファイルを16進ダンプしてみることもできます。hello.cが置かれているフォルダでGit bash(第3回講義資料を参照)を開き、次のように入力してみましょう。\nxxd hello.o\n筆者の環境では、出力は以下のようになります。\n...(前略)...\n00000100: 4000 3040 2f34 0000 0000 0000 0000 0000  @.0@/4..........\n00000110: 0000 0000 3000 0000 8401 0000 0000 0000  ....0...........\n00000120: 0000 0000 0000 0000 4000 5040 5548 89e5  ........@.P@UH..\n00000130: 4883 ec20 e800 0000 0048 8d0d 0000 0000  H.. .....H......\n00000140: e800 0000 00b8 0000 0000 4883 c420 5dc3  ..........H.. ].\n00000150: 9090 9090 9090 9090 9090 9090 4865 6c6c  ............Hell\n00000160: 6f2c 2057 6f72 6c64 2100 0000 0108 0305  o, World!.......\n00000170: 0832 0403 0150 0000 0000 0000 2400 0000  .2...P......$...\n...(後略)...\nここで、一番左の列がファイル先頭からの位置をバイト数(16進数)で表したものですが、プログラムの命令が書かれているのは、0x12cバイト地点の5548 89e5 ...のところから、0x14fバイト地点の... c420 5dc3までです。そのあとマシン語で「命令なし」を意味する90が12個続いたあと、4865 6c6c 6f2c 2057 6f72 6c64 21と13バイトの数字が続いていますが、これは、ASCIIコードでHello, World!の13文字を意味します。このように、命令コードの直後に、必要なデータが添付されていることが分かります。\n\n\n\n一方、Pythonのようなインタープリタ型言語では、実行にコンパイルを必要としません。インタープリタ型言語では、ソースファイルは実行可能ファイルの源（ソース）ではないので、ソースファイルのことをスクリプトと呼ぶことがあります。また、インタープリタ型言語のことをスクリプト言語ということもあります。スクリプト言語では、スクリプトに記述されたコードはインタープリタと呼ばれるプログラム(アプリケーション)によって一つずつ読み取られ、実行されていきます。\n実際にはスクリプトファイルのテキスト文をそのまま読み取っていくのはインタープリタにとって不便なので、まずスクリプトはバイトコードと呼ばれるマシン語に似たものに変換されます。そのあと、バイトコードの中の命令が1行ずつ読み取られながらインタープリタによって実行されていくわけです。インタープリタはスクリプトからバイトコードを生成する作業と、バイトコードの命令を読み取って実行する作業を両方担当しています。Pythonインタープリタのうち、バイトコード実行を行う部分だけを指して、Pythonヴァーチャルマシン(PVM)と呼びます。\n\n\n\npvm\n\n\nPythonがバイトコードを生成するプロセスのことをコンパイルもしくはバイトコンパイルと呼ぶことがあるので注意が必要です。コンパイル言語でのコンパイルと違い、Pythonのバイトコンパイルはマシン語を生成しません。\n試しに”Hello world!“と印字するPythonのプログラムをバイトコンパイルしてみましょう。まず、このプログラムのPythonスクリプトは次のようになります。\nprint(\"Hello world!\")\nこのコードをバイトコンパイルして出来たバイトコードをダンプすると、以下のようになります。\n00000000: 550d 0d0a 0000 0000 7a7f bb60 1600 0000  U.......z..`....\n00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................\n00000020: 0002 0000 0040 0000 0073 0c00 0000 6500  .....@...s....e.\n00000030: 6400 8301 0100 6401 5300 2902 7a0d 4865  d.....d.S.).z.He\n00000040: 6c6c 6f2c 2057 6f72 6c64 214e 2901 da05  llo, World!N)...\n00000050: 7072 696e 74a9 0072 0200 0000 7202 0000  print..r....r...\n00000060: 00fa 0868 656c 6c6f 2e70 79da 083c 6d6f  ...hello.py..&lt;mo\n00000070: 6475 6c65 3e01 0000 00f3 0000 0000       dule&gt;.........\nHello, World!の文字列は0x3eバイトの位置(4865 6400...)から0x4a(...6c64 21)までにあります。よく似ていますが、これはバイトコードであり、マシン語ではありません。Pythonヴァーチャルマシンは、このバイトコードを実行していきます。\nバイトコードの特徴は、マシン語で記述されたコンパイル言語の実行可能ファイルと違って、CPUの仕様に依存していないことです。したがって、バイトコードはそのまま他のコンピュータで実行することができます。一方で、直接レジスタに命令を送り込むコンパイル言語に比べると、ヴァーチャルマシンを介さなくてはならないスクリプト言語はかなり低速になり、往々にして100倍くらいの実行時の速度差が出てしまいます。\nしかしながら、コンパイルの必要がないので、インタープリタ言語による開発時間はコンパイル言語よりもはるかに早いのが普通です。(C言語で書かれた非常に大きなプログラムですと、コンパイルだけで数時間かかってしまうこともあります。たとえばnode.jsというjavascriptのインタープリタをコンパイルすると半日くらいかかります。)\nこのコンパイル型言語とインタープリタ型言語の違いを利用して、Python等のインタープリタ型言語でスピーディにプロトタイプを作成し、その後、少しずつコンパイル型言語に置き換えていくという開発上の作戦が取られることも良くあります。\nもう一つ、皆さんに覚えておいて欲しいのは、インタープリタそれ自体がプログラムであり、これは通常コンパイル型言語で作成(実装)されているということです(ただしPyPyのような例外はあります)。たとえばPythonのインタープリタで最も一般的なのはC言語で実装されたCPythonというインタープリタで、ほとんどの方が使っているPythonはこれです。CPythonのソースコードは公開されているので誰でも読むことができ、C言語を知っていれば内容を理解できます。他にもJavaで実装されたJythonというインタープリタもあります。\n注)最近では、JITコンパイルという技術が発展し、Juliaのような双方の利点を取り入れた次世代型の言語が複数現れてきました。これにより、インタープリタ型言語とコンパイル型言語の境界線は不明瞭になりつつあります。\n\n\n\nなおプログラミング言語の中には、アセンブリ言語という特別なタイプの言語があります。アセンブリ言語は、01の並びであるマシン語を分かりやすい記号の列に「直訳」したものです。直訳したものですので、マシン語とアセンブリ言語はどちらの方向にでも変換可能です。アセンブリ言語からマシン語を生成する作業をアセンブル、その逆を逆アセンブルと言います。アセンブルを行うためのソフトウェアをアセンブラと呼びます。アセンブリ言語の特徴の一つは、マシン語の直訳であるため、レジスタの操作をプログラマが明示的に行う必要があるということです。\nたとえば、次のC言語のプログラムは、aという変数に1を代入し(正確には1という値で初期化し)、そのあとaに2を足すというだけのプログラムです。\nint MyAdd(void){\n  int a = 1;\n  a = a + 2;\n  return a;\n}\nこれをコンパイルして出来たオブジェクトファイルを逆アセンブルすると、次のようなアセンブリ言語のコードが得られます。\nmyadd.o:     file format pe-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;MyAdd&gt;:\n   0:   55                      push   rbp\n   1:   48 89 e5                mov    rbp,rsp\n   4:   48 83 ec 10             sub    rsp,0x10\n   8:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1\n   f:   83 45 fc 02             add    DWORD PTR [rbp-0x4],0x2\n  13:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]\n  16:   48 83 c4 10             add    rsp,0x10\n  1a:   5d                      pop    rbp\n  1b:   c3                      ret\n  1c:   90                      nop\n  1d:   90                      nop\n  1e:   90                      nop\n  1f:   90                      nop\n\n\n\nassembly\n\n\nここでは詳しく説明できませんが、上のコードにおいて、rbpやrsp、eaxは全てレジスタの名前を表します。このように、アセンブリ言語では、レジスタを直接操作することが必要になってきます。(ちなみに”DWORD PTR [RBP-0X4]“などはメモリの領域を表します。)\nアセンブルと違ってコンパイルは不可逆変換なので、実行可能ファイルからコンパイル前のソースコードを復元することはできません。従って実行可能ファイルを分析するときは、通常、逆アセンブルを行ってアセンブリ言語に翻訳し、これを読解していきます。例えば、コンピュータウィルスの性質を解析する際にこういったスキルが必要になります。\nLinuxを使っている人は次のようにしてコンパイルと逆アセンブルを行うことができます。上のソースファイル名をmyadd.cとします。\ngcc -c myadd.c\nobjdump -d -M x86-64,intel myadd.o\nここでmyadd.oはコンパイルによって生成されたオブジェクトファイルです。\nAnaconda仮想環境にNASM(Netwide Assembler)をインストール済みの人は、アセンブリ言語のソースを書いてアセンブルしてみることもできます(NASMをインストールしていない人は、手順だけ追っておきましょう。)\n次のコードは、x86-64系PCのWindowsでしか動作しないNASMのコードで、Hello, World!を出力するものです。\n;hello.asm\nextern printf\nsection .data\n    msg db  \"Hello,World!\",0\nsection .text\n    global main\nmain:\n    mov rcx,msg\n    sub rsp,32\n    call printf\n    add rsp,32\nleave\nret\nこれをhello.asmという名前のファイルにノートパッド等を使ってコピー＆ペーストして保存します。\nアセンブルはAnaconda Promptで以下のように行います。\nnasm -f win64 hello.asm -l hello.lst\nアセンブルされたオブジェクトファイルはhello.objという名前で保存されます(hello.oではないので注意)。また、hello.lstファイルには、ソースコードの各命令とマシン語の対応表が出力されます。\n     1                                  ;hello.asm\n     2                                  extern printf\n     3                                  section .data\n     4 00000000 48656C6C6F2C20576F-         msg db  \"Hello, World!\",0\n     4 00000009 726C642100\n     5                                  section .text\n     6                                      global main\n     7                                  main:\n     8 00000000 48B9-                       mov rcx,msg\n     8 00000002 [0000000000000000]\n     9 0000000A 4883EC20                    sub rsp,32\n    10 0000000E E8(00000000)                call printf\n    11 00000013 4883C420                    add rsp,32\n    12 00000017 C9                      leave\n    13 00000018 C3                      ret\n1列目はメモリに配置されるときの相対的な位置をバイト数で表したもの、2列目は機械語の命令もしくはデータ、3列目は対応するアセンブリコードです。\nこれをみると分かるように、アセンブルされたマシン語の命令は、ソースコードの命令と全く同じ順序で並んでいることが分かります。\nhello.objをダンプしてみることにより、これらが実際に近接して配置されていることを確かめることができます。Git bashターミナルでhello.objを16進ダンプしてみましょう。\nxxd hello.obj\n...(前略)...\n00000040: 7400 0000 0000 0000 0000 0000 1900 0000  t...............\n00000050: 7200 0000 8b00 0000 0000 0000 0200 0000  r...............\n00000060: 2000 5060 4865 6c6c 6f2c 2057 6f72 6c64   .P`Hello, World\n00000070: 2100 48b9 0000 0000 0000 0000 4883 ec20  !.H.........H..\n00000080: e800 0000 0048 83c4 20c9 c302 0000 0002  .....H.. .......\n00000090: 0000 0001 000f 0000 0007 0000 0004 002e  ................\n...(後略)...\n第0x64バイト位置の4865 6c6c ...から0x70バイト位置の6c64 21までの13バイトがHello, World!です。また、その直後0x72位置の48b9 0000...から0x8aバイト位置...20c9 c3までが命令コードです。"
  },
  {
    "objectID": "programming2025/programming-1.html#抽象度",
    "href": "programming2025/programming-1.html#抽象度",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "アセンブリ言語のように、レジスタやメモリといったハードウェアを直接操作する言語を低水準言語と呼びます。低水準言語は、抽象度が低い言語と表現されることもあります。一方、Pythonのように、レジスタやメモリと言ったものをプログラマが直接意識することなくプログラミングできるような言語は、高水準言語と呼ばれ、抽象度が高いと言われます。一般に、インタープリタ型言語のほうがコンパイル型言語よりも抽象度が高い傾向があります。また、時代が進むにしたがって、より高水準で抽象度の高い言語が登場してきたと言えます。\n高水準言語や低水準言語というのは、相対的なものであるととらえた方が良いでしょう。たとえば、従来C言語はアセンブリ言語と比較して高水準言語であると言われてきましたが、言語の高水準化が進むにつれ、たとえばPython等に比べると低水準言語であると言われるようにもなってきました。というのも、C言語ではレジスタを意識することはほとんどありませんが、メモリはかなり意識しないとコードが書けないからです。一方、Pythonでは、C言語よりも抽象度が高く、比較的メモリを意識しなくてもプログラミングができるようになっています。それでも、以降の講義で論じるように、メモリをある程度意識することはPythonを正しく使う上で重要であると言えます。"
  },
  {
    "objectID": "programming2025/programming-1.html#プログラミング上達のコツ",
    "href": "programming2025/programming-1.html#プログラミング上達のコツ",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "当たり前ですが、プログラミングの上達において最も大切なことは、「プログラミングを楽しむ」ことだと思います。そのために大切なことは、「ストレスなくコーディングする」ということに尽きると思います。そして、そのためには、以下の2点が重要であると筆者は考えます。\n\n正しいタイピングをする\nエディターのキーバインドをマスターする\n\nもう一つコツを挙げるとすれば、誰もが言うことですが、コードを試すときは、写経するということです。写経とは、コードをコピー＆ペーストしたり、すでに他人が入力したコードを実行するのではなく、自分でタイピングして書き写すことです。\n\n\n正しいタイピングとは、タッチタイピング（いわゆるブラインドタッチ）のことです。タッチタイピングを解説したサイトはインターネットにたくさんありますので、ここでは改めて解説しません。以下の項目に注意して練習を重ねてください。\n\n最初は決して速く打とうとしてはいけない\n同じキーはいつも同じ指で叩く\nキーを叩くときは、基本そのキーに最も近い指で叩く\nキーボードを見ないでタイプするトレーニングをする\n人差し指～小指すべて使う\n\n数字や記号はつらいので、まずはアルファベットだけキーボードを見ないで打てるようになるように練習しましょう。そのうち見ないで打てるキーの数が増えてきます。タイピングソフトなどは必要ありません。ゆっくりで良いので、タッチタイピングの基本を守りつつプログラミングや文書作成をしていれば、自然に上達していきます。\n上達につれてタイプの速度は上がってきますが、目安として大体1分間に200タイプくらいでスピード的には十分ではないでしょうか。重要なのはストレスを無くすことであって、速度を上げることではありません。ゆっくりでもキーボードを見ずに正確に打てるようになれば、視線の移動がほとんど必要なくなるので、コーディング中に感じるストレスは圧倒的に小さくなります。\n\n\n\nコーディングのストレスを軽減するには、正しいタイピングを心がけるだけでなく、キーバインドを覚えることが重要です。本講義で言うキーバインドとは、編集中に文書の中を移動したり、編集に関連する様々な機能を呼び出したりするためのキーボードショートカットのことです。\nプログラミングの世界には大きく分けて、2種類のメジャーなキーバインドがあります。1つはEmacsキーバインド、もう一つはviキーバインドです。これらは、それぞれ、Emacs、viというエディターで用いられているキーバインドですが、多くのエディターでこれらの2つのキーバインドを使用することができるようになっています。\nEmacsキーバインドは直観的で覚えやすいのが特徴で、viキーバインドは「速い」のが特徴です。筆者はプログラミングにEmacs、設定ファイルなどの編集にviを使うという風に使い分けていますので、本講義でもプログラミングのためにはEmacsキーバインドを用いることを推奨したいと思います。Emacsキーバインドについては次回VS Codeを操作するときに詳しく説明します。\n\n\n\nコードを写経することにより、自分で書いてみると、そっくりそのまま書き写したはずがうまく動作しないということが往々にして生じます。その度に、「どこが間違っていたのか」考えさせられることになり、細部に目が行くことになります。また、単純にタイピングの練習にもなります。\n写経は、最初のうちは苦行かもしれません。前時代的なトレーニングと思われるかもしれません。なかなか先に進めないのでじれったい気持ちになるかもしれませんが、これは必要なプロセスです。どれだけプログラミングが上手になっても、皆さん写経をしておられます。逆に写経がストレスなくできるようになったら、一人前だと考えてください。\nしたがって、本講義では、入力済みのコードを配布しないことにします。どうしてもコピー＆ペーストが必要なときは、このサイトから行えばよいでしょう。"
  },
  {
    "objectID": "programming2025/programming-1.html#まとめ",
    "href": "programming2025/programming-1.html#まとめ",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "今回は、以下の事項について学びました。\n\nPythonを学ぶ意義\nPythonを動かす2種類の基本的な方法\n本講義の目標\nプログラムがどのように動いているか\nプログラミング言語にはどのようなものがあるか\nプログラミング上達のコツ\n\n今回の講義でPythonのプログラムがどのように動いているか、大体分かったと思います。一方で、一つ一つのPythonの文がどのように動作しているのかまでは説明しませんでした。そういった詳細については今後の講義で解き明かして行くことにしましょう。\n基本的なプログラミングの練習は、基本的に独学でも可能なものです。自宅や研究室のパソコンにもPythonをインストールし、教科書を参照しながらPythonの操作をしっかりと練習しておいてください。"
  },
  {
    "objectID": "programming2025/programming-1.html#参考書",
    "href": "programming2025/programming-1.html#参考書",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "『プログラムはなぜ動くのか(第2版)』(矢沢久雄 著/日経ソフトウェア監修) (2007) 日経BP社. ISBN 978-4-8222-8315-5.\n『Beginning x64 Assembly Programming』(Jo Van Hoey 著)(2019) Apress. ISBN-13: 978-1484250754.\n\nどちらも読み易い名著です。特に2は非常に英語が平易です。1はBorland C++/Windowsを仮定していますが、2はNASM/Ubuntu 18.04を仮定しています。"
  },
  {
    "objectID": "programming2025/programming-1.html#補遺メモリ上での数の表現",
    "href": "programming2025/programming-1.html#補遺メモリ上での数の表現",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ここでは、メモリの上で整数や小数がどのように表現されているかを説明します。\n\n\n符号なし整数とは、正整数のみを表すことができるデータ型のことです。符号なし整数がメモリ上に記録される方法は特に難しいことはありません。単に正整数の2進数表現がそのまま格納されているだけです。例えば、2バイト=16ビットの領域に14という整数が格納されるときは、\n00000000 00001110\nのように格納されます。\n\n\n\n符号つき整数では、負の数と正の数を表すことができます。符号付き整数では、最も桁の大きいビットを符号を表すために用います。この符号ビットが0ならば0か正の整数を、1ならば負の整数を表します。残りの桁は、正整数ならば、符号なし整数と同じで、元の正数の2進数表現になっています。\n一方、負の数の場合は、元の数の絶対値の2の補数になっています。数nの2の補数とは、nのビット(0と1)を反転して、1をプラスしたものです。\nたとえば、14は上記のように表されますので、そのビットを反転したものは、\n11111111 11110001\nとなりますので、これに1を足したものは、\n11111111 11110010\nになります。これが-14の2の補数表現であり、メモリ上で-14という負数はこのように格納されています。\n実際、14と-14を足すと0になることが次のようになります。\n  00000000 00001110\n+ 11111111 11110010\n-------------------\n1 00000000 00000000\n一番左のあふれた一桁は無視されるので、和は0になることが分かります。\n符号つき整数の絶対値の上限は、符号なし整数の約半分になります。\n\n\n\nバイト数\n符号つき整数\n符号なし整数\n\n\n\n\n1\n-128 ～　127\n0 ～ 255\n\n\n2\n-32,768 ～ 32,767\n0 ～ 65,535\n\n\n4\n-2,147,483,648 ～ 2,147,483,647\n0 ～ 4,294,967,295\n\n\n8\n-2**63 ～ 2**63-1\n0 ～ 2**64-1\n\n\n\n即席ですが、任意の整数を2の補数表現に変換するPython関数を作りましたので参考にしてください(バグを見つけたら教えてください。)関数についてはまだ学んでいないので、現時点でこの関数を使える必要はありません。\n# %%\n# 整数を2の補数表現に変換する関数\ndef int_to_bits(num,length,endian='big'):\n    if type(num) is int:\n        num_bytes = num.to_bytes(length,endian,signed=True)\n        num_bin = bin(int(num_bytes.hex(),16))\n        if len(num_bin)-2 &lt; length * 8:\n            bit_str = (\"0\"*(length*8-len(num_bin)+2)) + num_bin[2:]\n        else:\n            bit_str = num_bin[2:]\n        byte_list = [bit_str[8*i:8*i+8] for i in range(length)]\n        print(\" \".join(byte_list))\n    else:\n        print(\"The first argument must be an integer.\")\nこの関数は次のように使います。\nint_to_bits(整数,バイト数,エンディアン)\nエンディアンは指定しなくても構いません。指定しない場合はビッグエンディアンになります(エンディアンについては下で説明しています)。\nたとえば、4バイト符号つき整数の-255を2の補数表現にするには、次のようにします。\nint_to_bits(-255,4)\n# 出力\n11111111 11111111 11111111 00000001\nリトルエンディアンにするときは、第3引数を’little’に指定してください。\nint_to_bits(-255,4,'little')\n# 出力\n00000001 11111111 11111111 11111111\n\n\n\n小数は、浮動小数点数というデータ型でメモリに格納されます。浮動小数点数には単精度浮動小数点数と倍精度浮動小数点数があります。単精度では一つの数値に32ビット(4バイト)、倍精度では64ビット(8バイト)を使います。\n浮動小数点数がどのように小数をメモリ上で表現するのか、単精度の場合を例にとって説明します。\nまず、全ての実数は次のように表現できることに注意しましょう。\n[符号] (m)×(10のn乗)\nただし、mは0.xxx...という形式の10進数小数です。たとえば、-123.45は、次のように表すことができます。\n- (0.12345)×(10の3乗)\nmを仮数、nを指数と呼びます。\n全く同様に、全ての実数は次のように表現できます。\n[符号] (m) * (2のn乗)\nただし、mは1.xxx...という形式の2進数小数です。たとえば、2進数小数101.1011は、次のように表すことができます。\n+ (1.011011)×(2の2乗)\nそこで単精度浮動小数点では、下図のように32ビットを上の桁から順に1ビット、8ビット、23ビットに区切り、それぞれ符号、指数、仮数を表すのに使います。\n\n\n\nfloat\n\n\nただし、仮数は常に1.xxx...という形をしているので、\"1.\"を省略し、xxx...の部分だけを23ビットに記憶します。たとえば、仮数が1.011011であれば、浮動小数点数の仮数部分23ビットは\n01101100 00000000 0000000\nのようになります。また、指数部分は、正負どちらの値でもありえますが、ここでは負の数を表すのに補数は使いません。代わりにイクセス表現を使います。イクセス表現では、指数部分8ビットを0～255の符号なし整数と見なしたとき、そこから、ちょうど中間の値127を引いたものを実際の指数とする表現方法です。\nたとえば、指数部分に記憶されているビット列が次のようになっていたとします。\n10000001\nこれは10進数符号なし整数に読み替えると129です。ここから127を引くと2ですので、実際の指数は2ということになります。\nまとめると、符号部分のビット、指数部分のビット列、仮数部分のビット列がそれぞれ\n# 符号ビット\n1\n# 指数部分8ビット\n10000001\n# 仮数部分23ビット\n01101100 00000000 0000000\nのようになっているとき、この単精度浮動小数点数は、\n[-] (1.011011)×(2の2乗) = -101.1011\nを表すことになります。これを10進数で表すと、-5.6875になります。言い換えると、-5.6875という小数は、浮動小数点数によって\n1-10000001-01101100 00000000 0000000\nという32ビットでメモリ上に記憶されていることになります。\nさて、上記の仮数部分を16進数で表し、指数部分をイクセス表現でなく実際の指数(10進数)に書き換えると、次のようになります。\n1-(+2)-6c 00 00\nただし右端の0だけは3ビットしかありませんので注意してください。\n倍精度の浮動小数点数ですと、仮数部分は52ビット=6バイト+4ビットありますので、-5.6875はメモリ上で、\n1-(+2)-6c 00 00 00 00 00 0\nと記憶されます。“6c”に続いて0が11個あることに注意してください。Pythonでは、この表現を次のようにして出力することができます。\n&gt;&gt;&gt; (-5.6875).hex()\n'-0x1.6c00000000000p+2'\nここで、pのあとの+2が指数、0x1.のあとの6c00000000000が指数部分に記録されているビット列を表します。\n\n\n\nエンディアンは、複数バイトを使う数値や文字が、どのバイトから先にメモリに格納されるかを表します。下の桁のバイトから順に格納されていく方式をリトルエンディアン、上の桁のバイトから順に格納されていく方式をビッグエンディアンと呼びます。エンディアンはCPUに依存しますが、現在パソコンで使われているCPUの多くはリトルエンディアン方式です。\nリトルエンディアンでは、下の桁のバイトのほうが上の桁よりもメモリ上で若いアドレスに格納されますので、例えば16ビット整数型としてメモリに保存された整数14をダンプすると、次のように、バイトが入れ替わって画面に表示されます。\n# 14はリトルエンディアンではこう見える\n00001110 00000000\n一方、ビッグエンディアンでは、上の桁のバイトのほうが下の桁よりも若いアドレスのメモリに格納されますので、14が格納されたメモリ領域をダンプすると、次のように画面に表示されます。\n# 14はビッグエンディアンではこう見える\n00000000 00001110\nこのように、下の桁から若いアドレスに順番に格納していくリトルエンディアン方式は、発想において自然ですが、ダンプしたときにひっくり返って表示されるので、読みにくいという難点があります。一方ビッグエンディアンでは表示された順そのままで読むことができます。\nエンディアンは普段はほとんど意識する必要がありませんが、文字や数値のバイト列表現を扱うときに、どうしても避けられない話題となってきますので、頭の片隅においておく必要があります。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "社会科のおもちゃ箱",
    "section": "",
    "text": "社会科の知識共有と、日々の授業づくりに役立てていただくための備忘録サイトです。教育現場での利用や、非営利の学習目的であれば、どなたでも自由にお使いいただけます。 各資料の著作権に配慮いただいた上で、ぜひ授業のヒントや学びに役立ててください。\n\n筆者紹介\n藤井 大和\nFujii Yamato\n\nかなり熱狂的な中日ドラゴンズファン\n\n\n\n\n\n\nノートコメント\n\n\n\n中日ドラゴンズ優勝が自分の正義です。高品質な資料共有に努めます。よろしくお願いいたします。",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "Chizugaku/1chizunomikata.html",
    "href": "Chizugaku/1chizunomikata.html",
    "title": "１　地図の特性と注意",
    "section": "",
    "text": "地図は、現実の地理的な情報を縮小して表現したものである。しかし、地図は正確に現実を反映しているわけではない。 なぜか。それは、地球は球体であり、地図は、その表面を無理矢理平面に表現しているからである。\nしたがって、地図を作成する際には、必ず何らかの歪みが生じる。 この歪みは、地図の種類や作成方法によって異なる。\n\n\n地図の正確性は、この距離、面積、角度、方位の４つの要素で評価される。すべての要素を完全に正確に表現することは不可能であり、地図は、目的に応じてどの要素を重視するかを選択して使う。\n\n\n\n地図の正確性を示す４つの要素",
    "crumbs": [
      "Home",
      "地図学",
      "1 地図の特性と注意"
    ]
  },
  {
    "objectID": "Chizugaku/1chizunomikata.html#地図",
    "href": "Chizugaku/1chizunomikata.html#地図",
    "title": "１　地図の特性と注意",
    "section": "",
    "text": "地図は、現実の地理的な情報を縮小して表現したものである。しかし、地図は正確に現実を反映しているわけではない。 なぜか。それは、地球は球体であり、地図は、その表面を無理矢理平面に表現しているからである。\nしたがって、地図を作成する際には、必ず何らかの歪みが生じる。 この歪みは、地図の種類や作成方法によって異なる。\n\n\n地図の正確性は、この距離、面積、角度、方位の４つの要素で評価される。すべての要素を完全に正確に表現することは不可能であり、地図は、目的に応じてどの要素を重視するかを選択して使う。\n\n\n\n地図の正確性を示す４つの要素",
    "crumbs": [
      "Home",
      "地図学",
      "1 地図の特性と注意"
    ]
  },
  {
    "objectID": "Chizugaku/1chizunomikata.html#各図法の正確性",
    "href": "Chizugaku/1chizunomikata.html#各図法の正確性",
    "title": "１　地図の特性と注意",
    "section": "各図法の正確性",
    "text": "各図法の正確性\n\n\n\n\n距離\n面積\n角度\n方位\n備考\n\n\n\n\nメルカトル図法\n×\n×\n〇\n南北のみ〇\n海図などで使用\n\n\n正距方位図法\n中心からのみ〇\n×\n×\n中心からのみ〇\nレーダーなどで使用\n\n\nモルワイデ図法",
    "crumbs": [
      "Home",
      "地図学",
      "1 地図の特性と注意"
    ]
  },
  {
    "objectID": "Chizugaku/index.html",
    "href": "Chizugaku/index.html",
    "title": "地図学",
    "section": "",
    "text": "１　地図の特性と注意\n２　メルカトル図法\n３　正距方位図法\n４　サンソン図法・モルワイデ図法",
    "crumbs": [
      "Home",
      "地図学",
      "地図学トップ"
    ]
  },
  {
    "objectID": "Chizugaku/index.html#資料一覧",
    "href": "Chizugaku/index.html#資料一覧",
    "title": "地図学",
    "section": "",
    "text": "１　地図の特性と注意\n２　メルカトル図法\n３　正距方位図法\n４　サンソン図法・モルワイデ図法",
    "crumbs": [
      "Home",
      "地図学",
      "地図学トップ"
    ]
  },
  {
    "objectID": "Chizugaku/index.html#すべての地図はどこか間違っている",
    "href": "Chizugaku/index.html#すべての地図はどこか間違っている",
    "title": "地図学",
    "section": "すべての地図はどこか間違っている",
    "text": "すべての地図はどこか間違っている\n日本に住む人間であれば、一度は地図に触れたことがあるであろう。観光情報雑誌やGoogle Mapを使いながら旅をしている読者も多いと思う。しかし、あなたが見ている地図は本当に正しいのだろうか。\n人々は地図を信じて疑わない。地図の見方がわからないなどの理由で、道に迷うことはあっても、地図が間違っていたために、道に迷ったりした経験はほとんどないだろう。しかし、それは、偶然その位置が間違っていなかっただけというケースや、その地図の使い方であれば問題がなかったというケースである。\nこの世に正しい地図などない。これははっきりと言わなければいけない。しかし、この言い方では語弊が生じかねないので、もう少しかみ砕く。この世にすべてを正確に表した地図はない。これが正しい言い方だ。",
    "crumbs": [
      "Home",
      "地図学",
      "地図学トップ"
    ]
  },
  {
    "objectID": "Chizugaku/index.html#地図リテラシーを付ける意義",
    "href": "Chizugaku/index.html#地図リテラシーを付ける意義",
    "title": "地図学",
    "section": "地図リテラシーを付ける意義",
    "text": "地図リテラシーを付ける意義\n勘のいい読者はお気づきであろうが、メルカトル図法など世の中にある地図の記法にはすべて歪みがあり、球体の地球を歪みなしで正確に記述することはできない。\nまた、多くの地図は、その地図の倍率によって、一定の法則の元、記述を省略することがあり、本当に正しい地形を記述しているかどうかすら怪しい場合もある。\nしかし、地図は「正しい」という顔をしてこちらに近づいてくる。人々はそれに対して、我々は正しい地図リテラシーをもって相対しなければならない。地図はたくさんの化粧をまとった美女だ。しかし、その魔力に取り込まれ、信じ込むと痛い目に合う。\nこのページでは、授業補助教材としての使用を目的とする。また、地図のリテラシーを向上させる知識を保管しておくことも一般公開する目的である。",
    "crumbs": [
      "Home",
      "地図学",
      "地図学トップ"
    ]
  },
  {
    "objectID": "Chizugaku/index.html#参考文献",
    "href": "Chizugaku/index.html#参考文献",
    "title": "地図学",
    "section": "参考文献",
    "text": "参考文献\n\n羽田康祐（2021）『地図リテラシー入門 地図の正しい読み方・描き方がわかる』, ベレ出版",
    "crumbs": [
      "Home",
      "地図学",
      "地図学トップ"
    ]
  },
  {
    "objectID": "Chizugaku/index.html#地図素材など",
    "href": "Chizugaku/index.html#地図素材など",
    "title": "地図学",
    "section": "地図素材など",
    "text": "地図素材など\nここで使われている地図は、全て沼津沼津高専様が公開している地図投影法学習のための地図画像素材集よりお借りした。感謝申し上げる。\n\n沼津高専　地図投影法学習のための地図画像素材集　https://user.numazu-ct.ac.jp/~tsato/tsato/graphics/map_projection/#t_p410",
    "crumbs": [
      "Home",
      "地図学",
      "地図学トップ"
    ]
  },
  {
    "objectID": "Chizugaku/4Moruwaide.html",
    "href": "Chizugaku/4Moruwaide.html",
    "title": "４　サンソン図法・モルワイデ図法",
    "section": "",
    "text": "ノート\n\n\n\n現在執筆途中です。\nこの章では、サンソン図法とモルワイデ図法について記述する。これは、似たような作り方をするので、同じページにて紹介する。",
    "crumbs": [
      "Home",
      "地図学",
      "4 サンソン図法・モルワイデ図法"
    ]
  },
  {
    "objectID": "Chizugaku/4Moruwaide.html#サンソン図法をつくろう",
    "href": "Chizugaku/4Moruwaide.html#サンソン図法をつくろう",
    "title": "４　サンソン図法・モルワイデ図法",
    "section": "サンソン図法をつくろう",
    "text": "サンソン図法をつくろう\nまずは、サンソン図法を作っていこう\nいつも通り、地球儀から地図を剥がしていくことから始めよう。\n\n①　地球儀から表面の地図部分を剥いてみる\nメルカトル図法と同じ剥き方にするとこうなる\n\nこれを単純に横に引き延ばせば、メルカトル図法になるが、今回は引き延ばし方を変える。\n\n\n② 中心に引き延ばして隙間をなくす\n伸ばし方を、真ん中変えてみよう\n\n\n\nサンソン図法の引き延ばし方\n\n\n\n\n③ 完成\n\n\n\nサンソン図法",
    "crumbs": [
      "Home",
      "地図学",
      "4 サンソン図法・モルワイデ図法"
    ]
  },
  {
    "objectID": "Chizugaku/4Moruwaide.html#モルワイデ図法のつくり方",
    "href": "Chizugaku/4Moruwaide.html#モルワイデ図法のつくり方",
    "title": "４　サンソン図法・モルワイデ図法",
    "section": "モルワイデ図法のつくり方",
    "text": "モルワイデ図法のつくり方\nモルワイデ図法は、サンソン図法を変えていくだけだ。\n緯度によって縦横比を調整し、全体の形が楕円形になるようにしただけである。\n\n\n\nモルワイデ図法",
    "crumbs": [
      "Home",
      "地図学",
      "4 サンソン図法・モルワイデ図法"
    ]
  },
  {
    "objectID": "Chizugaku/4Moruwaide.html#サンソン図法モルワイデ図法の特徴",
    "href": "Chizugaku/4Moruwaide.html#サンソン図法モルワイデ図法の特徴",
    "title": "４　サンソン図法・モルワイデ図法",
    "section": "サンソン図法・モルワイデ図法の特徴",
    "text": "サンソン図法・モルワイデ図法の特徴\n\n\n\n\n距離\n面積\n角度\n方位\n備考\n\n\n\n\nサンソン図法\n\n\n\n\n\n\n\nモルワイデ図法",
    "crumbs": [
      "Home",
      "地図学",
      "4 サンソン図法・モルワイデ図法"
    ]
  },
  {
    "objectID": "Chizugaku/2chizunouso.html",
    "href": "Chizugaku/2chizunouso.html",
    "title": "２　メルカトル図法",
    "section": "",
    "text": "地球は言わずもがな球体だ。地球儀は、地図を作るうえで問題となる距離・面積・方位・角度の４つをすべて正確に示す最強のツールだ。しかし、一度に世界全体を見るということができない。これが、最も痛い地球儀の欠点である。\nでは、ここから地図を作ってみよう\n\n\n\n\n\n沼津高専より\n\n\nこの状態では、正直なところ地図として使いにくい。地図間に空白があるので、非常に見にくい。\nでは、横方向に引き伸ばして隙間をなくしてみよう。\n\n\n\n\nこれでかなり地図っぽくなった。今の状態のこの地図を、正距円筒図法（または正方形図法）という。この地図は、引き延ばしたがために、角度・面積・方位のすべてが異なっており、距離も赤道上のみ正しくなるという地図になっている。（羽田(2021), p.174-175）これでは使いようがない。\nでは、せめて角度を正しくしよう。横方向に引き伸ばした分だけ、縦方向にも引き伸ばす。\n\n\n\n\nこうしてできたのが、1569年にGerardus Mercator（ゲラルドゥス・メルカトル）という地理学者が発明したメルカトル図法である。",
    "crumbs": [
      "Home",
      "地図学",
      "2 メルカトル図法"
    ]
  },
  {
    "objectID": "Chizugaku/2chizunouso.html#メルカトル図法を作る",
    "href": "Chizugaku/2chizunouso.html#メルカトル図法を作る",
    "title": "２　メルカトル図法",
    "section": "",
    "text": "地球は言わずもがな球体だ。地球儀は、地図を作るうえで問題となる距離・面積・方位・角度の４つをすべて正確に示す最強のツールだ。しかし、一度に世界全体を見るということができない。これが、最も痛い地球儀の欠点である。\nでは、ここから地図を作ってみよう\n\n\n\n\n\n沼津高専より\n\n\nこの状態では、正直なところ地図として使いにくい。地図間に空白があるので、非常に見にくい。\nでは、横方向に引き伸ばして隙間をなくしてみよう。\n\n\n\n\nこれでかなり地図っぽくなった。今の状態のこの地図を、正距円筒図法（または正方形図法）という。この地図は、引き延ばしたがために、角度・面積・方位のすべてが異なっており、距離も赤道上のみ正しくなるという地図になっている。（羽田(2021), p.174-175）これでは使いようがない。\nでは、せめて角度を正しくしよう。横方向に引き伸ばした分だけ、縦方向にも引き伸ばす。\n\n\n\n\nこうしてできたのが、1569年にGerardus Mercator（ゲラルドゥス・メルカトル）という地理学者が発明したメルカトル図法である。",
    "crumbs": [
      "Home",
      "地図学",
      "2 メルカトル図法"
    ]
  },
  {
    "objectID": "Chizugaku/2chizunouso.html#メルカトル図法の特性と歪み",
    "href": "Chizugaku/2chizunouso.html#メルカトル図法の特性と歪み",
    "title": "２　メルカトル図法",
    "section": "メルカトル図法の特性と歪み",
    "text": "メルカトル図法の特性と歪み\n\nメリット\n\n角度が正しい\nメルカトル図法は、南北の方位が正しいことと、角度が正しいことが最も大きなメリットである。\n角度の正しさは、航海をする上では非常に重要な要素だ。南北があっているのだから、航海は、北の方向からどの角度に進めばよいかを定めることができる。そうすれば行くべき正しい方向を決められる。\n\n\n緯線・経線が直交する\nどの位置にいるかというのが、緯線・経線で大まかに把握しやすい。当然、面積や距離がずれているので、正確には測れない。ただ、ほかの地図だと緯線・経線がグニャグニャで即座の把握は面倒になっている。\n\n\n赤道付近は距離・面積・角度・方位のすべてが正しい\n以上のような作り方をしているので、赤道付近はほとんど引き延ばされていない。よって、赤道付近は、すべてが正しい地図になっている。\nこの原理を応用したものが、後から紹介する[発展]横メルカトル図法である。\n\n\n\nデメリット\n\n距離が正しくない\n作成過程で横に引き延ばしているので、当然、距離は正しくない。\n\n\n面積が正しくない\n距離同様に面積も正しくない。実際にどれほど伸びているかを示している図が下である。\n\n赤道付近では、ほとんど歪みがないが、南北に行くほど歪みがおおきくなる。\nTrue size ofというサイトでは、このメルカトル図法によって、どれほど国の大きさが大きくなっているのかを視覚的に見ることができる。\n\n\n\n\n\n\n注意注意\n\n\n\nこのサイトで注意すべきなのは、緯度の高い地域で比較しても意味がないことである。メルカトル図法は、緯度が高いほど歪みが大きくなる。例えば、いくらロシアが以外にも小さい国だということを示すために、日本の地図をロシア近くに持って行っても、それは間違っている。\n比べるなら、赤道付近で行うべきであろう。そうすれば、正確な国の大きさが比較できる。\n\n\n実際の大きさを視覚的に地球儀で比べてみるなら、このWorld Sizeというサイトもおすすめだ。\n\n\n方位が正しくない\nメルカトル図法は、方位が正しいと誤解されがちである。確かに、メルカトル図法は、南北方向の方位は正しい。しかし、東西方向の方位は正しくない。\n日本の裏側はどこか。それは紛れもなく皆が「ブラジル」と答えるであろう。「裏側」ということは、日本から真東（もしくは真西）に進めば裏側にたどり着くはずだ。\nしかし、メルカトル図法で東に進むと、アメリカに突き当たる。メルカトル図法の地図において、日本の裏側はアメリカを示すのである。\n\n\n\n東京から真東に向かうと\n\n\n緯度が高いほど歪みが大きく、緯度が低いほど歪みが小さい地図であるから、よく考えてみれば当然だ。\n\n\n\nまとめると…\n\n\n\n\n\n\n\n\n\n\n\n距離\n面積\n角度\n方位\n\n\n\n\nメルカトル図法\n✖（赤道付近のみ〇）\n✖（赤道付近のみ〇）\nすべての地点で〇\n南北方向のみ〇（東西方向は✖）\n\n\n\n距離も面積も東西方位も異なるこのメルカトル図法は、決して世界地図のグローバルスタンダードにはなるべきではなかったのだが、現状は地図の需要の急拡大により、一目ですべての国がわかるメルカトル図法が「世界地図」として広く普及した。",
    "crumbs": [
      "Home",
      "地図学",
      "2 メルカトル図法"
    ]
  },
  {
    "objectID": "Chizugaku/2chizunouso.html#発展横メルカトル図法",
    "href": "Chizugaku/2chizunouso.html#発展横メルカトル図法",
    "title": "２　メルカトル図法",
    "section": "[発展]横メルカトル図法",
    "text": "[発展]横メルカトル図法\n先ほど伝えたようにメルカトル図法は、赤道付近以外はズレズレである。それは、赤道付近は引き延ばしていないからである。\n日本地図でこのメルカトル図法を使うと、あまりにも歪む。では、剥き方を変えてみたら、どうなるか。\n\n\n\n縦に剥く\n\n\nこうすれば、これまでの剥き方では赤道付近に来ていた正確な部分が、日本に来るではないか。\nで、これを引き延ばすと、こうなる。\n\n\n\n横メルカトル図法\n\n\nここから、日本の部分だけを切り出せば、距離・面積・角度・方位がほぼすべて等しい最強の地図ができるわけだ。これを横メルカトル図法という。\n\n\n\n横メルカトル図法の日本地図\n\n\nこの横メルカトル図法を国際基準に合わせた形が、現在の多くの地図で使われるUTM（ユニバーサル横メルカトル）図法手法であり、日本の地理院地図もこの書き方である。\nこのようにすることで、その地域を示す小さな地図は、この方法を使うことで、ほとんどズレなく書くことができるのである。\n地理学者メルカトルに感謝しなければなるまい。",
    "crumbs": [
      "Home",
      "地図学",
      "2 メルカトル図法"
    ]
  },
  {
    "objectID": "Chizugaku/3Seikyohouizuhou.html",
    "href": "Chizugaku/3Seikyohouizuhou.html",
    "title": "３　正距方位図法",
    "section": "",
    "text": "地図の中心から各地への距離と方位が正しくなるように描いた地図のことである。\n\n\n\n正距方位図法",
    "crumbs": [
      "Home",
      "地図学",
      "3 正距方位図法"
    ]
  },
  {
    "objectID": "Chizugaku/3Seikyohouizuhou.html#正距方位図法とは",
    "href": "Chizugaku/3Seikyohouizuhou.html#正距方位図法とは",
    "title": "３　正距方位図法",
    "section": "",
    "text": "地図の中心から各地への距離と方位が正しくなるように描いた地図のことである。\n\n\n\n正距方位図法",
    "crumbs": [
      "Home",
      "地図学",
      "3 正距方位図法"
    ]
  },
  {
    "objectID": "Chizugaku/3Seikyohouizuhou.html#正距方位図法をつくる",
    "href": "Chizugaku/3Seikyohouizuhou.html#正距方位図法をつくる",
    "title": "３　正距方位図法",
    "section": "正距方位図法をつくる",
    "text": "正距方位図法をつくる\nどこが歪むかは、作ってみるとわかりやすいので、作ってみよう。\nメルカトル図法同様に、地球儀を剥くところから始めてみよう。\n今度は、北極点が中心となるように上から剥いてみよう。\n\n① 地球儀から表面の地図部分を剥いてみる\n\n上から剥くとこうなる。\nこの状態では、正直なところ地図として使いにくい。地図間に空白があるので、非常に見にくい。\nでは、引き伸ばして隙間をなくしてみよう。\n\n\n② 横方向に引き延ばして隙間をなくす\n\n\n\n正距方位図法\n\n\nそうすれば完成だ。とても簡単だろう。",
    "crumbs": [
      "Home",
      "地図学",
      "3 正距方位図法"
    ]
  },
  {
    "objectID": "Chizugaku/3Seikyohouizuhou.html#正距方位図法の特徴",
    "href": "Chizugaku/3Seikyohouizuhou.html#正距方位図法の特徴",
    "title": "３　正距方位図法",
    "section": "正距方位図法の特徴",
    "text": "正距方位図法の特徴\nこのように、かなり大きな隙間を引き延ばしている。\nしかし、中心点からの距離と方位自体は何も変わっていないのがわかるだろう。\n\n\n\n\n距離\n面積\n角度\n方位\n備考\n\n\n\n\n正距方位図法\n中心点からのみ〇\n×\n×\n中心点からのみ〇\nレーダーなど\n\n\n\n中心点からの距離と方位は変わらないので、みんなが映画やゲームでよく見るシーンのレーダーは正距方位図法なのである。距離と方位はこれでよくわかる\n\n？？？「魚雷！10時方向！距離20！」\n\nこんなセリフは、正距方位図法があるからできるのだ。",
    "crumbs": [
      "Home",
      "地図学",
      "3 正距方位図法"
    ]
  },
  {
    "objectID": "Chizugaku/3Seikyohouizuhou.html#正距方位図法のデメリット",
    "href": "Chizugaku/3Seikyohouizuhou.html#正距方位図法のデメリット",
    "title": "３　正距方位図法",
    "section": "正距方位図法のデメリット",
    "text": "正距方位図法のデメリット\nいわずもがな、面積も角度もめちゃくちゃである。\n地図の見た目もかなり悪い。 南極大陸が円周を囲っているではないか。\nよって、一般的にはあまり使われない地図である。",
    "crumbs": [
      "Home",
      "地図学",
      "3 正距方位図法"
    ]
  },
  {
    "objectID": "Kyouiku/index.html",
    "href": "Kyouiku/index.html",
    "title": "教育",
    "section": "",
    "text": "高度少子化を迎えた日本の学校教育は、現在転換期を迎えている。"
  },
  {
    "objectID": "programming2025/geeks2.html",
    "href": "programming2025/geeks2.html",
    "title": "社会科のおもちゃ箱",
    "section": "",
    "text": "まだメモ書き程度です。\n/cpython/Include/cpython/dictobject.hより。\ntypedef struct _dictkeysobject PyDictKeysObject;\n\n/* The ma_values pointer is NULL for a combined table\n * or points to an array of PyObject* for a split table\n */\n\ntypedef struct {\n    PyObject_HEAD\n\n    /* Number of items in the dictionary */\n    Py_ssize_t ma_used;\n\n    /* Dictionary version: globally unique, value change each time\n       the dictionary is modified */\n    uint64_t ma_version_tag;\n\n    PyDictKeysObject *ma_keys;\n\n    /* If ma_values is NULL, the table is \"combined\": keys and values\n       are stored in ma_keys.\n\n       If ma_values is not NULL, the table is splitted:\n       keys are stored in ma_keys and values are stored in ma_values */\n    PyObject **ma_values;\n} PyDictObject;\n/cpython/Objects/dict-common.hより。\ntypedef struct {\n    /* Cached hash code of me_key. */\n    Py_hash_t me_hash;\n    PyObject *me_key;\n    PyObject *me_value; /* This field is only meaningful for combined tables */\n} PyDictKeyEntry;\n/* See dictobject.c for actual layout of DictKeysObject */\nstruct _dictkeysobject {\n    Py_ssize_t dk_refcnt;\n\n    /* Size of the hash table (dk_indices). It must be a power of 2. */\n    uint8_t dk_log2_size;\n\n    /* Kind of keys */\n    uint8_t dk_kind;\n\n    /* Version number -- Reset to 0 by any modification to keys */\n    uint32_t dk_version;\n\n    /* Number of usable entries in dk_entries. */\n    Py_ssize_t dk_usable;\n\n    /* Number of used entries in dk_entries. */\n    Py_ssize_t dk_nentries;\n\n    /* Actual hash table of dk_size entries. It holds indices in dk_entries,\n       or DKIX_EMPTY(-1) or DKIX_DUMMY(-2).\n\n       Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size).\n\n       The size in bytes of an indice depends on dk_size:\n\n       - 1 byte if dk_size &lt;= 0xff (char*)\n       - 2 bytes if dk_size &lt;= 0xffff (int16_t*)\n       - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)\n       - 8 bytes otherwise (int64_t*)\n\n       Dynamically sized, SIZEOF_VOID_P is minimum. */\n    char dk_indices[];  /* char is required to avoid strict aliasing. */\n\n    /* \"PyDictKeyEntry dk_entries[dk_usable];\" array follows:\n       see the DK_ENTRIES() macro */\n};"
  },
  {
    "objectID": "programming2025/geeks2.html#辞書のメモリ利用",
    "href": "programming2025/geeks2.html#辞書のメモリ利用",
    "title": "社会科のおもちゃ箱",
    "section": "",
    "text": "まだメモ書き程度です。\n/cpython/Include/cpython/dictobject.hより。\ntypedef struct _dictkeysobject PyDictKeysObject;\n\n/* The ma_values pointer is NULL for a combined table\n * or points to an array of PyObject* for a split table\n */\n\ntypedef struct {\n    PyObject_HEAD\n\n    /* Number of items in the dictionary */\n    Py_ssize_t ma_used;\n\n    /* Dictionary version: globally unique, value change each time\n       the dictionary is modified */\n    uint64_t ma_version_tag;\n\n    PyDictKeysObject *ma_keys;\n\n    /* If ma_values is NULL, the table is \"combined\": keys and values\n       are stored in ma_keys.\n\n       If ma_values is not NULL, the table is splitted:\n       keys are stored in ma_keys and values are stored in ma_values */\n    PyObject **ma_values;\n} PyDictObject;\n/cpython/Objects/dict-common.hより。\ntypedef struct {\n    /* Cached hash code of me_key. */\n    Py_hash_t me_hash;\n    PyObject *me_key;\n    PyObject *me_value; /* This field is only meaningful for combined tables */\n} PyDictKeyEntry;\n/* See dictobject.c for actual layout of DictKeysObject */\nstruct _dictkeysobject {\n    Py_ssize_t dk_refcnt;\n\n    /* Size of the hash table (dk_indices). It must be a power of 2. */\n    uint8_t dk_log2_size;\n\n    /* Kind of keys */\n    uint8_t dk_kind;\n\n    /* Version number -- Reset to 0 by any modification to keys */\n    uint32_t dk_version;\n\n    /* Number of usable entries in dk_entries. */\n    Py_ssize_t dk_usable;\n\n    /* Number of used entries in dk_entries. */\n    Py_ssize_t dk_nentries;\n\n    /* Actual hash table of dk_size entries. It holds indices in dk_entries,\n       or DKIX_EMPTY(-1) or DKIX_DUMMY(-2).\n\n       Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size).\n\n       The size in bytes of an indice depends on dk_size:\n\n       - 1 byte if dk_size &lt;= 0xff (char*)\n       - 2 bytes if dk_size &lt;= 0xffff (int16_t*)\n       - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)\n       - 8 bytes otherwise (int64_t*)\n\n       Dynamically sized, SIZEOF_VOID_P is minimum. */\n    char dk_indices[];  /* char is required to avoid strict aliasing. */\n\n    /* \"PyDictKeyEntry dk_entries[dk_usable];\" array follows:\n       see the DK_ENTRIES() macro */\n};"
  },
  {
    "objectID": "programming2025/programming-8.html",
    "href": "programming2025/programming-8.html",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "第8回　関数とモジュール\n\n関数\n\n練習1\n\nジェネレータ\n\n練習2\n練習3\n\n内包表記\n\n練習4\n\nif/if-elseつき内包表記\n\n練習5\n\nモジュールの種類\n\n外部ファイル\nビルトインモジュール\nbuiltinsモジュール\nmainモジュール\n\nモジュールを作る\nモジュールのリロード\nモジュールのバイトコード\n\n練習6\n\n名前空間\n\nグローバル名前空間\n練習7\nローカル名前空間\nビルトイン名前空間\n練習8\n\nスコープ\n\nグローバルスコープ\nローカルスコープ\nビルトインスコープ\n\nLEGBルール\n\n再帰関数\n\nglobal/nonlocal命令\n\n練習9\n\nクロージャ\n\n練習10\n\n記号表(高度な話題)\n\nトップレベル記号表の取得\nトップレベル記号表の精査\n記号表を精査する関数inspect_tbl\nローカル記号表の取得\nローカル記号表の精査\n\nまとめ\n参考書\n宿題(ホームワーク)\n課題(アサインメント)\n\n\n\n\nまずRにおける関数の作成を思い出しましょう。一例として、2つの引数の和を返すだけのmyadd関数を定義するには、次のように書くのでしたね。\nmyadd &lt;- function(a,b) {\n    z &lt;- a + b\n    return(z)\n}\n上記において、関数の中身(ボディ)は、中括弧の中で与えられます。a、bが引数であり、任意の数値を想定しています。関数returnを呼び出すことで関数の実行は終了し、returnの引数が戻り値として返されます。作成された関数は、無名のまま使うこともできますが、通常は何度も再利用するものです。そのため、myaddという名前(識別子)に、作成した関数オブジェクトを&lt;-演算子によって付値しています。これにより、識別子myaddに関数オブジェクトが結び付けられ、次のようにこの関数を何度でも呼び出せるようになります。\n&gt; res &lt;- myadd(2,8)\n&gt; print(res)\n[1] 10\nなお上記では、return(a+b)としても構いませんが、関数のボディの存在をわかりやすくするために、あえて複数行で記述しました。\n一方、Pythonの関数は、以下のdef命令を用いて作成し、必ず識別子への代入が行われます。(Pythonにもlambda式という無名関数はありますが、全く違う方法で作ります。残念ながらlambda式では複数行ブロックをもつ関数を作ることはできません。lambda式については教科書のセクション8.4.4に詳しく説明がありますのでよく読んでおいてください。)上記のRコードはPythonで書き直すと次のようになります。\ndef myadd(a,b):\n    z = a + b       # 関数ブロック\n    return z        #\n\nprint(myadd(5,4))\nprint(myadd(10,-2))\n# 出力\n9\n8\nifブロックやforブロックと同じように、関数の内容もまた、インデントを用いたブロックによって表現します。戻り値はreturn命令で返します。Pythonのdefやdelとおなじような命令であって、関数ではないことに注意しましょう。したがって、returnにはカッコは必要ありません。\nreturn命令を省略すると、関数はNoneオブジェクトを返します。Noneは「空っぽ」を意味するオブジェクトであり、メモリ上に常駐していて常に再利用されます。たとえば次の関数helloは、return命令を呼び出しませんので、その戻り値はNoneとなります。\ndef hello():\n    print('Hello, World!')\n\nx = hello()\nprint(x is None)\n# 出力\nHello, World!\nTrue\nまた、関数を終了させたいが、戻り値はいらないという場合は、単にreturnと書くと、Noneを返して終了します。何らかの理由で関数の実行を途中で終了したい場合に有用です。\n# %%\ndef hello(name):\n    if name == '':\n        print('hello,world!')\n        return\n    print('hello,' + name)\n\nhello('')\nhello('taro')\n# 出力\nhello,world!\nhello,taro\n本講義では省略しますが、Pythonの関数は引数のデフォルト値やキーワード引数など、様々な形式の引数を設定することが可能です。教科書のセクション8.3に詳しく説明されているので、良く読んでおきましょう。\n\n\n数値のリストを引数にとり、リストの全ての要素の3乗の和を求める関数sumcubeを作成しなさい。たとえば、次の関数呼び出しの戻り値は36になります。\nsumcube([1,2,3])\n\n\n\n\nreturn命令の代わりにyield命令を使うと、関数はジェネレータ関数という特別な関数になります。ジェネレータ関数は、戻り値として、ジェネレータオブジェクトを返します。(ジェネレータ関数とジェネレータオブジェクトのどちらもジェネレータと呼ぶことがあるので注意してください。)\n\n\n\ngenerator\n\n\nジェネレータオブジェクトは、イテラブルなオブジェクトであり、主にループ処理で用いることができます。ループ処理でループインデックスに代入されるのは、yieldの戻り値です。ただし、注意しなくてはならないのは、yieldは作業を中断するだけで、関数ブロックの処理を終了しないということです。\nたとえば、次のようなジェネレータは、19以下の偶数を順番にループインデックスに返します。\n# %%\n# ジェネレータ関数の定義\ndef yield_even():\n    for i in range(20):\n        if i%2 == 0:\n            yield i\n\n# ジェネレータの活用\nfor i in yield_even():\n    print(i)\n# 出力\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\nなお、ジェネレータオブジェクトはイテレータでもあります。従って、next関数によって値を取得することができます。\nジェネレーターオブジェクトはイテラブルであるため、listコンストラクタやsetコンストラクタ、tupleコンストラクタに渡すことで、リストや集合、タプルを作ることができます。\nprint(list(yield_even()))\nprint(set(yield_even()))\nprint(tuple(yield_even()))\n# 出力\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}\n(0, 2, 4, 6, 8, 10, 12, 14, 16, 18)\nただし、あくまでも、有限回の呼び出しでStopIteration例外を発生するジェネレータである必要があります。練習2で作ったような、無限回nextで呼び出せるジェネレータをこのように使わないよう注意しましょう。\n上記の方法で辞書を作成するには、ジェネレータはキーと値のタプルを返すものでなくてはなりません。たとえば、次の例は、20未満の偶数をキー、その自乗を値としてもつ辞書を作成するコードです。\ndef yield_even():\n    for i in range(20):\n        if i % 2 == 0:\n            yield i,i**2\n\nprint(dict(yield_even()))\n# 出力\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64, 10: 100, 12: 144, 14: 196, 16: 256, 18: 324}\nジェネレータから得られた値をそのまま使うのではなく、若干の編集を加えてリストや集合にしたい場合は、次に説明する内包表記を用いることができます。\ndef yield_even():\n    for i in range(20):\n        if i%2 == 0:\n            yield i\n\n# 内包表記(奇数の列)\nx = [i + 1 for i in yield_even()]\nprint(x)\n# 出力\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n\n呼び出すたびに1のn乗、2のn乗、3のn乗…という風に、正整数のn乗を返すジェネレータオブジェクトを生成するジェネレータ関数genpowを定義しなさい。この関数の引数は、指数nです。\nたとえば、次のように書くと、xはnext(x)を実行するたびに正整数の3乗を返すジェネレータオブジェクトになります。\nx = genpow(3)\nヒント: whileを用いた無限ループを活用します。\n\n\n\n練習2の応用です。genpowを修正して、指数nに加えて、整数の上限maxを引数に加えなさい。たとえば、次のように書くと、xはnext(x)の呼び出しによって最大10**3まで返せるジェネレータオブジェクトになります。ただし、maxに負の数を与えると、練習2のgenpowと同じで上限値はなくなり、next(x)は任意の回数呼び出せるようになるとします。\nx = genpow(max,n)\n\n\n\n\n脱線しますが、折角ですので、ここで内包表記についてお話ししておきます。内包表記は、ループ処理の結果をリスト、辞書、集合などのコンテナ型オブジェクトにまとめるためのPython特有の構文であり、慣れるとコードをコンパクトに書くのに非常に有用です。以下が、内包表記の基本形です。\n# リスト内包表記\n[iを含む表現 for i in ループ範囲]\n# セット(集合)内包表記\n{iを含む表現 for i in ループ範囲}\n# 辞書内包表記\n{iを含む表現:iを含む表現 for i in ループ範囲}\n例えば、100までの偶数の自乗をすべて収めたリストを作るときは、次のように書きます。\n&gt;&gt;&gt; [i**2 for i in range(0,100,2)]\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]\n同じことをforループでやるとすると、たとえば次のようになります。\n# %%\nx = []\nfor i in range(0,100,2):\n    x.append(i**2)\n\nprint(x)\n# 出力\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]\nセット内包表記は[]を{}にするだけですが、リストと違い重複を除去できます。次のコードは、100までの偶数の自乗を5で割った余りを集めたリストと集合を計算するためのものです。\n&gt;&gt;&gt; [i**2 % 5 for i in range(0,100,2)]\n[0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4]\n&gt;&gt;&gt; {i**2 % 5 for i in range(0,100,2)}\n{0, 1, 4}\n辞書内包表記は少し特徴的です。たとえば次は、“hello,world!”という文字列のそれぞれの文字をキーとし、キーの大文字を値とする辞書を作成するコードです。やはりこの場合も、キーの重複は取り除かれます。\n&gt;&gt;&gt; x = {c:c.upper() for c in \"hello,world!\"}\n&gt;&gt;&gt; x\n{'h': 'H', 'e': 'E', 'l': 'L', 'o': 'O', ',': ',', 'w': 'W', 'r': 'R', 'd': 'D', '!': '!'}\n辞書で内包表記でキーの重複が取り除かれる際には、最新の値が採用されるので注意が必要です。たとえば、次のコードは、キーと値を入れ替えた辞書を作るものです。値は一意とは限らないので、重複部分は除去され、最新のペアだけが残ります。\n# %%\nx = {'foo':1,'bar':2,'baz':1}\n{j:i for i,j in x.items()}\n# 出力\n{1: 'baz', 2: 'bar'}\n\n\n文字列’Python’から1文字目を1回、2文字目を2回、…n文字目をn回繰り返した文字列’Pyyttthhhhooooonnnnnn’をリスト内包表記を使って作成しなさい。\n\n\n\n\n先に挙げた、100までの偶数の自乗を含むリストは、次のようにifと組み合わせた内包表記によっても作成できます。\n# %%\nx = [i**2 for i in range(100) if i%2 ==0]\nprint(x)\n# 出力\n\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]\n上記では、iが2で割り切れるときのみi**2をリストに加える、という意味になります。\nところが、iが2で割り切れるときはi**2をリストに加え、そうでないときは0を加えよ、という命令にしたいときは、下のようにかなり異なる表現になります。\n# %%\nx = [i**2 if i%2==0 else 0 for i in range(100)]\nprint(x)\n実はこの表現においては、単文のif-else構文が使われています。単文のif-elseは次のように用います。\n式A if 条件 else 式B\nこのように書くと、「条件が成り立っていれば式A、さもなくば式B」という意味になります。本来内包表記とは直接関係がなく、どこでも用いることができます。たとえばxにiの絶対値を代入したい場合は次のように書くことができます。(実際にはabsという絶対値を返すビルトイン関数があります。)\nx = i if i&gt;=0 else -i\nこのように、ifつき内包表記とif-elseつき内包表記は全く別のものですので、両者を組み合わせることもできます(おすすめはしませんが)。たとえば、「7の倍数のうち、3の倍数は自乗し、3で割り切れない数はそのまま格納したリスト」は次のように表現できます。\n# %%\nx = [i**2 if i%3==0 else i for i in range(100) if i%7==0]\nprint(x)\n# 出力\n\n[0, 7, 14, 441, 28, 35, 1764, 49, 56, 3969, 70, 77, 7056, 91, 98]\nこのように、内包表記は非常に高い表現力をもっています。forループの結果をリストに格納したい、ということはプログラミングをやっていると頻発しますので、この機会にぜひ覚えておきましょう。\n\n\n文字列”this practice is too difficult for most students”に含まれているアルファベット(空白は含まない)のうち、3回以上用いられているものだけを集めた集合を内包表記で作りなさい。\n\n\n\n\nさて、自作した関数を複数のプログラムで再利用したい場合には、モジュールの仕組みを活用するのが便利です。これまでにも、sysモジュールやcopyモジュールを随所で活用してきましたが、ここでモジュールとはどのようなものかを明確にしておきましょう。\nモジュールは、Pythonスクリプトから読み込んで使用できる関数や変数、データ型、Pythonコードの集合のことを広く指します。\nPythonには以下の4種類のモジュールがあります。\n\n\n\n\n\n\n\n\n種類\n説明\n例\n\n\n\n\n外部ファイル\nPythonやCで作成され、importで呼び出して使う\ncopy\n\n\nビルトインモジュール\nインタープリタに組み込まれ、importで呼び出して使う(builtinsモジュールは例外)\nsys、math\n\n\nbuiltinsモジュール\nビルトイン関数・定数を定義している特別なビルトインモジュールで、起動時に自動で読み込まれる\nbuiltins\n\n\nmainモジュール\n主スクリプトの属するモジュール\n任意のスクリプト\n\n\n\n\n\n\nmodule_types\n\n\n\n\n全てのPythonスクリプトは他のPythonスクリプトにimport命令で読み込めるので、モジュールとして機能します。その他にも、たとえばCPythonインタープリタであれば、C言語やCythonと言った言語でモジュールを作成できます。こういった外部ファイルで提供されたモジュールは、import命令によって主プログラムに読み込んで使用することができます。たとえばcopyモジュールはcopy.pyというPythonスクリプトとして存在しており、import命令で読み込めます。\n\n\n\nそれに対して、ファイルの形では存在していないビルトインモジュールという特別なタイプのモジュールがあります。たとえばsysはビルトインモジュールであり、インタープリタに埋め込まれています。その他、数学関数を収めたmathもビルトインモジュールです。こういったものもimport文で読み込んで使うことができます。\nimportしたモジュールがビルトインかどうかは単にそのオブジェクトをprintしてみればわかります。\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; print(sys)\n&lt;module 'sys' (built-in)&gt;\n&gt;&gt;&gt; import copy\n&gt;&gt;&gt; print(copy)\n&lt;module 'copy' from '/usr/lib/python3.8/copy.py'&gt;\nビルトインモジュールの場合は、sysのように(built-in)と表示されます。一方、ファイルの場合は、copyのようにモジュールファイルのある場所が表示されます。\n\n\n\nビルトインモジュールの中には、ただ一つだけbuiltinsという特別なモジュールがあります。これは、たとえばprintなど、ビルトイン関数やTrueなどのビルトイン定数を定義しているモジュールです。builtinsだけは、importを必要とせず、__builtins__という別名でPythonの起動と同時に自動的に読み込まれます。試しに、__builtins__をprintしてみてください。\n&gt;&gt;&gt; print(__builtins__)\n&lt;module 'builtins' (built-in)&gt;\nこのように、__builtins__という名前がすでに定義されていて、その正体はbuiltinsというビルトインモジュールであることがわかります(とてもややこしいので混乱しないように注意してください)。これは、builtinsモジュールが__builtins__という別名で読み込まれているということを意味します。モジュールの別名読み込みは一般に次のようなimport-as文で行います。\nimport モジュール名 as 別名\nつまり、builtinsモジュールだけは、起動時に次のように読み込まれたのと同じ状態になるということです。\nimport builtins as __builtins__\nなぜこのようになっているかというのは、名前空間の節で説明します。\n\n\n\n最後に、mainというモジュールがあります(正確には__main__)。これは、実行時の主スクリプトの別名です。たとえばコマンドプロンプトで次のようにfile.pyスクリプトを実行したとします。\npython file.py\nこのとき、file.pyに記述された変数、関数、コード、データ型は全てmainモジュールに属することになります。\nこのように、Pythonスクリプトは全てモジュールとして機能しますが、その逆は必ずしも成り立ちません。モジュールはスクリプトよりも広い概念です。\n\n\n\n\nそれでは折角ですので、モジュールを自作してみましょう。といっても、二つのPythonスクリプトを作成し、一方をもう一方からimportするだけです。importする側がmainモジュールとなります。\nGitHubディレクトリの中にmy_first_moduleというフォルダを作ってVS Codeで開きましょう。そして、mymod1.pyというファイルを作って開きましょう。この中に、次のように記述します。\nx = 5\ndef hello():\n    print(\"Hello,World!\")\n記述を終えたら保存します。ここでの目的は、mymod1.pyの中で定義された変数xと関数helloを再利用することです。\n次に、mymain.pyというファイルを作成して開き、次のように記述してインタラクティブモードで実行してみましょう。\n# %%\nimport mymod1\n\nprint(mymod1.x)\nmymod1.hello()\nここで、mymod1.xによって、mymod1.pyで定義された変数xにアクセスしていることに注意してください。上手くimportできれば、次のように表示されるはずです。\n# 出力\n5\nHello,World!\nここで2点注意事項があります。\n\nimportでの読み込みは初回のみ有効であり、モジュールの再読み込み(リロード)には使えない。\n一度読み込まれたモジュールはバイトコンパイルされ、変更がない限り再利用され続ける。\n\n\n\n\n上記1は、モジュールを変更したら、一旦Pythonを再起動しないと、変更したモジュールをimportで読み込み直せないということを意味します。これを覚えておくことは大変重要です。\nたとえば、まずmymain.pyをインタラクティブモードで実行したあと、インタラクティブモードを起動したままで、mymod1.pyを次のように変更して保存してみましょう。\nx = 100\ndef hello():\n    print(\"Good bye,World!\")\nそして、mymain.pyをインタラクティブモードでもう一度実行してみてください。次のように、mymod1.pyの変更が反映されていないはずです。\n# 出力\n\n5\nHello,World!\nそれでは、一度インタラクティブモードを終了してください(Pythonを停止する)。それからもう一度同じmymain.pyのコードを実行してください。次のように、変更が反映されるはずです。\n100\nGood bye,World!\nPythonを終了せずにモジュールの再読み込みをするには、次のようにimportlibモジュールのreload関数を使う方法もあります。モジュールの開発中は、一々Pythonを再起動するよりもこちらのほうが便利でしょう。一度読み込まれたmymod1モジュールを再び読み込むには、次のように記述します。\nimport importlib\nimportlib.reload(mymod1)\n\n\n\nimport文によって読み込まれたPythonスクリプトのモジュールは、通常インタプリタによってバイトコンパイルされ__pycache__というディレクトリに保存されます。__pycache__はmainモジュールファイル(主スクリプト)が置かれていた場所に作られます。VS Code上で閲覧できるはずなので、開いてみてください。\n中には、mymod1.cpython-38.pycというバイナリファイルが作られているはずです。これがmymod1.pyをバイトコンパイルして出来たバイトコードです。\n通常、mainモジュールとして実行されるファイルは、実行のたびにバイトコンパイルされ、バイトコードがファイルに保存されることはありません(強制的にバイトコードを作ることは可能です)。一方、importされたファイルは(可能な限り)バイトコードを保存し、ファイル内容に変更がない限り再コンパイルしません。\nこのようにして、モジュールのバイトコンパイルにかける時間を節約することで、Pythonは実行までの時間を短縮する工夫をしています。通常モジュールのバイトコンパイルを意識する必要はありませんが、教養として知っておきましょう。\n\n\n主スクリプトを強制的にバイトコンパイルするには、コンソール(Anaconda prompt)上で次のように入力します。\npython -m compileall script.py\nここでscript.pyはスクリプト名です。このようにして作成された主スクリプトのバイトコードは通常のモジュールと同じく__pycache__内に作成され、テキストで書かれたスクリプトと全く同じように実行できます。\n“Hello, World!”と出力するスクリプトを作成してコンパイルし、作成されたバイトコードを見つけてください。また、そのバイトコードを実行してください。\n\n\n\n\n名前空間とは、mainを始めとするモジュールの中で定義された記号(識別子)の一覧および、それらの記号が参照するオブジェクトの対応表のことです。一つのモジュールには、次の3種類の名前空間が存在します。\n\n\n\n\n\n\n\n名前空間\n含まれる記号\n\n\n\n\nローカル名前空間\n関数のなかで定義された記号\n\n\nグローバル名前空間\nモジュールファイルのトップレベル(関数の外)で定義された記号\n\n\nビルトイン名前空間\n__builtins__で定義されている記号\n\n\n\n記号がどの名前空間に属するかは、それがどこで最初に定義されたかによって決まります。最初から定義されている記号を除き、記号が定義されるのは代入が起きるときです。従って、モジュールのトップレベル、つまり関数の外で値を代入された変数はグローバル変数となり、関数の中で値を代入された変数はローカル変数となります。\n\n\nそれぞれの名前空間は、具体的に辞書の形で取り出すことができます。グローバル名前空間の辞書はビルトイン関数globalsを使って取得できます。\nまず、Pythonを起動してすぐglobalsを呼び出すと次のようになります。\n&gt;&gt;&gt; globals()\n{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__doc__': None, '__package__': None}\n&gt;&gt;&gt; len(globals())\n4\nこのように、グローバル名前空間には起動直後にすでに幾つかの変数が定義されていることが分かります。グローバル名前空間で定義されている変数をグローバル変数と呼びます。\n\n\n\nグローバル変数\n意味\n\n\n\n\n__builtins__\nビルトイン名前空間\n\n\n__name__\nモジュールの名前\n\n\n\nこのうち重要なのは、__builtins__と__name__です。モジュールがmainモジュールとして直接Pythonによって実行された場合、__name__には\"__main__\"が設定されますが、他のファイルによってimportされた場合には__name__にはモジュールのファイル名が設定されます。これにより、モジュールは自分が主スクリプトとして実行されているのか、他のモジュールにimportされているのかを見分けることができます。\n一方、__builtins__はビルトイン名前空間を表します。これについては、ビルトイン名前空間のところで解説します。\nモジュールのトップレベルで変数を作成してみましょう。\n&gt;&gt;&gt; x = \"I am global.\"\n&gt;&gt;&gt; 'x' in globals()\nTrue\n&gt;&gt;&gt; globals()['x']\n'I am global.'\n&gt;&gt;&gt;\nこのように、xをトップレベルで定義すると、globals()辞書に変数xが定義され、グローバル変数となったことが分かります。\n\n\n\n次のような振る舞いをする関数printmodを定義したPythonスクリプトmymod2.pyを作成し、挙動をテストしなさい。\nprintmodは次のような関数とします。mymod2.pyがスクリプトからimportされているときは、“Script mymod2.py is imported by another script.”と印字し、mymod2.pyが主スクリプトとして実行されているときは、“Script mymod2.py is executed as the main module.”と印字します。\n\n\n\nローカル名前空間は、各関数につき一つずつ存在しており、関数内で定義された記号とそれが参照するオブジェクトの対応を与えます。ローカル名前空間で定義された変数をローカル変数と呼びます。ローカル名前空間を辞書として取り出すには、関数内でビルトイン関数のlocalsを呼び出します。\n# %%\n\nx = 1\ndef f(y):\n    z = 3\n    print(locals())\n\nf(2)\n# 出力\n\n{'y': 2, 'z': 3}\n上記では、関数fの中でlocalsを呼び出したので、fの名前空間が辞書として出力されました。この名前空間には、fの中で定義されている変数であるyとzが登録されています。\nなお、Pythonのリファレンスマニュアルにあるように、locals()の戻り値である辞書を編集してはいけません。locals()の戻り値は名前空間を辞書にコピーしたものであって名前空間そのものではないため、locals()に加えた変更はローカル名前空間に反映されません。\n\n\n\nビルトイン名前空間は、TrueやNoneといった全てのビルトイン定数とビルトイン関数を定義している名前空間です。ビルトイン名前空間は、builtinsモジュールの__dict__属性(変数)に辞書として格納されています。builtinsは起動時にすでに__builtins__という別名で読み込まれているため、これを使うことができます。\n&gt;&gt;&gt; __builtins__.__dict__\n{'__name__': 'builtins', '__doc__': \"Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.\", '__package__': '', '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, ...(以下省略)\n&gt;&gt;&gt; len(__builtins__.__dict__)\n154\n上記のように、150個以上のビルトイン関数・定数・データ型等が定義されていることがわかります(具体的な数はPythonバージョンや処理系に依存しえます。)\nここで、__builtins__という名前の働きについて説明します。 (__builtins__の働きは、現在のモジュールがmainかどうかによって少し違います。以下では、話を単純にするため、現在のモジュールがmainであると仮定します。)\n上述のように、モジュールがmainとして実行されると、builtinsモジュールが__builtins__という別名で読み込まれます。Pythonがビルトイン関数の名前を参照するとき、実際には、この__builtins__という名前で読み込まれたモジュールのグローバル名前空間が検索されます。(したがって、研究目的以外では絶対に行うべきではありませんが、別のモジュールを__builtins__という名前で上書きインポートすることにより、Pythonはそのモジュールのグローバル名前空間をビルトイン名前空間と『誤認』することになります。)\nPythonのリファレンスマニュアルによると、Pythonが__builtins__という名前をどのように使うかはPythonの実装に依存しているようです。リファレンスマニュアルには、以下のようにこの__builtins__をプログラムの中で使うべきでないと明記されています。\n\nUsers should not touch __builtins__; it is strictly an implementation detail. Users wanting to override values in the builtins namespace should import the builtins module and modify its attributes appropriately.\n\n上記にあるように、ビルトイン名前空間を操作したいときは、builtinsモジュールを別途importしてそれを操作するのが正しい方法です。\nたとえば次のようにすると、ビルトイン名前空間にxという変数を追加することができ、printなどのビルトイン関数と同じようにプログラムのどこからでも呼び出すことができるようになります。\n&gt;&gt;&gt; import builtins\n&gt;&gt;&gt; builtins.x = 5\n&gt;&gt;&gt; __builtins__.__dict__['x']\n5\n&gt;&gt;&gt; x\n5\n\n\n\nビルトイン名前空間に追加された変数は、プログラム全体から参照可能になることを次のようにして確かめてください。\n次のような3つのスクリプトを作成し、main.pyを実行してください。\n# main.py\nimport mymod3\nimport mymod4\n\nprint(\"In main: \",x)\n# mymod3.py\nimport builtins\nbuiltins.x = 1\n# mymod4.py\nprint(\"In mymod4: \",x)\n\n\n\n\nPythonで変数名や関数名がどのように使われるかを理解するには、名前空間だけでなくスコープの概念を理解する必要があります。\nスコープとは、モジュールファイルのなかで、ある名前空間の記号が、記号単体で参照できるコードの範囲を指します。ここで記号単体とは、たとえばxのように書くことです。sys.xのように書くことは記号単体とは言いません。スコープは、それぞれの名前空間に一つずつ存在します。変数xのスコープというと、通常xが属する名前空間のスコープを指します。\nグローバル名前空間のスコープをグローバルスコープ、ローカル名前空間のスコープをローカルスコープ、ビルトイン名前空間のスコープをビルトインスコープと呼びます。\n\n\n\nスコープ名\n対応する名前空間\n範囲\n\n\n\n\nグローバルスコープ\nグローバル名前空間\nモジュール全体\n\n\nローカルスコープ\n各関数のローカル名前空間\n関数ブロック\n\n\nビルトインスコープ\nビルトイン名前空間\nプログラム全体\n\n\n\n\n\nグローバルスコープは、モジュールのトップレベルで代入された記号を記号単体で使うことができるコードの範囲です。トップレベルで代入された変数や関数は、モジュールファイルのどこからでも記号単体で参照できますので、グローバルスコープはモジュールファイル全体ということになります。グローバルという言葉が紛らわしいですが、グローバル名前空間の記号はモジュールの外からは参照できません。\n\n\n\n一方関数内で定義された記号はその関数の中でしか記号単体で参照できないので、ローカルスコープは対応する関数の関数ブロックに等しくなります。\n\n\n\nビルトイン名前空間の記号は文字通り、どこからでも記号単体で参照できます。従ってビルトインスコープはプログラム全体を指す最も広いスコープです。\n\n\n\n\n一般にスコープは入れ子の関係にあります。たとえば関数のローカルスコープは、モジュールのグローバルスコープに含まれています。内側のスコープでは、両方の名前空間が参照できるので、ある記号が参照されたとき、Pythonはどちらの名前空間を先に検索するのかを決定する必要があります。\nPythonは、内側から外側へ向かって名前空間を検索します。具体的には、以下のような順番で、名前空間を検索します。\n\nローカル名前空間(Local)\n外側の関数のローカル名前空間(Enclosing)\nグローバル名前空間(Global)\nビルトイン名前空間(Built-in)\n\n\n\n\nlegb\n\n\n1〜4のどの名前空間を参照しても記号が見つからなかったとき、Pythonはエラー(NameError)を出します。この検索パターンをLEGBルールと呼びます。\n注意しなくてはならないのは、関数の内側では、一つの記号は関数ブロックを通して必ず同じ名前空間を参照するということです。\nたとえば、次のコードのコードは、間違ったコードとして非常に有名なものです。\n# %%\nx = 5\n\ndef f():\n    print(x)\n    x = 3\n    print(x)\n\nf()\nこれを書いたプログラマは、関数fの中で、まず5を出力し、次に3を出力することを意図していますが、これを実行すると、次のようなエラーが出ます。\n# 出力\n\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n\n...(中略)...\n\n      239 \n      240 def f():\n----&gt; 241     print(x)\n      242     x = 3\n      243     print(x)\n\nUnboundLocalError: local variable 'x' referenced before assignment\n最後のUnboundLocalErrorの行に注目しましょう。このエラーは、「値が割り当てられる前にxが参照された」というものです。\nなぜこのようなエラーが出たかというと、x=3というxへの代入操作が関数内に存在していることにより、xがfのローカル名前空間にエントリーし、関数ブロックの全域でローカル変数とみなされるからです。従って、1回目のprint(x)で、xが定義されていない、というエラーが出るわけです。\n同様ですが、もっと分かりにくいコードは次のようなものです。\n# %%\nx = 5\n\ndef f():\n    x += 1\n    print(x)\n\nf()\n出力は以下の通りです。\n# 出力\n\n---------------------------------------------------------------------------\n\n...(中略)...\n      249 \n      250 def f():\n----&gt; 251     x += 1\n      252     print(x)\n      253 \n\nUnboundLocalError: local variable 'x' referenced before assignment\nx += 1は、x = x + 1と同じ意味です。これはxへの代入を伴いますが、その時点で、xはfのローカル名前空間に属するローカル変数とみなされます。x = x + 1の右辺は、xの値を参照していますので、「まだ定義されていないローカル変数が参照された」というエラーが出るわけです。\nしかしながら、次のような操作では、エラーが出ません。なぜなら、関数内部でxが指すオブジェクトへの変更は行われましたが、xの代入は行われていないため、xはグローバル変数のままだからです。\n# %%\n# %%\nx = [1,2,3]\n\ndef f():\n    print(x)\n    x.append(4)\n\nf()\nprint(x)\n\n\nローカル名前空間に記号が見当たらないときは、一つ外側の名前空間にアクセスするため、関数の内部で自分自身を参照することが可能になります。\nたとえば、次の関数は、自分自身のデータ型を返すおかしな関数です。\n# %%\ndef typer():\n    return type(typer)\n\nprint(typer())\n# 出力\n&lt;class 'function'&gt;\nもう少し馬鹿々々しくない次の関数は、xが正整数のときにxの階乗x!を返す関数です。\n# %%\ndef f(x):\n    if type(x) is int and x &gt; 0:\n        if x &gt; 1:\n            return x*f(x-1)\n        else:\n            return x\n    else:\n        print('x must be a positive integer')\n        return\nf(5)\n# 出力\n120\n\n\n\n\n関数の内側で、グローバル変数を編集したり、外側の関数のローカル変数を編集することも可能です。そのためには、global命令とnonlocal命令を使います。\n# %%\n# %%\nx = 5\n\ndef f():\n    global x\n    x += 1\n\nf()\nprint(x)\n# 出力\n6\nまた、入れ子になった関数で外側の名前空間の変数を編集するには、nonlocal命令を使います。\n# %%\nx = 0\n\ndef outer():\n    x = 0\n\n    def inner():\n        nonlocal x\n        x += 1\n        print(\"At inner:\",x)\n\n    inner()\n    print(\"At outer:\",x)\n\nouter()\nprint(\"At global:\",x)\n# 出力\n\nAt inner: 1\nAt outer: 1\nAt global: 0\n残念ながら、関数の入れ子において2つ以上上の階層の名前空間を指定する命令は存在しません。したがって、次の例において、fの名前空間を直接指定する命令はありません。\n# %%\nx = 0\n\ndef f():\n    x = 0\n    \n    def g():\n        x = 0\n        \n        def h():\n            nonlocal x\n            x += 1\n            print(\"At h:\",x)\n\n        h()\n        print(\"At g:\",x)\n\n    g()\n    print(\"At f:\",x)\n\nf()\nprint(\"At global:\",x)\nAt h: 1\nAt g: 1\nAt f: 0\nAt global: 0\n\n\n上記の3重入れ子関数において、nonlocalをglobalに変えたときにどうなるか予測し、実際に実行して結果を確かめなさい。\n\n\n\n\nnonlocal宣言の最も重要な応用が、クロージャと呼ばれる独特のプログラミングテクニックです。ある程度複雑なプログラムになると、関数呼び出しにおいて、呼び出すごとに関数の挙動を変化させたい場合が生じます。そのような場合にクロージャが役に立ちます。\nたとえば、任意のオブジェクトを引数にとり、過去の呼び出しにおいて引数として渡した全てのオブジェクトを格納したリストを戻り値として返す関数を考えてみましょう。これは次のように実現できます。\ndef closure():\n    args = []\n    def inner(arg):\n        nonlocal args\n        args.append(arg)\n        return args\n    return inner\n\nfunc = closure()\nこれでfuncは、呼び出す度にこれまでの引数のリストを返す関数になります。試してみてください。\n通常は、関数のローカル名前空間は、関数の呼び出しが終了した時点で消失します。しかし上の関数closureの場合、内部の関数innerがclosureの名前空間をnonlocal宣言によって参照しています。したがって、innerが存在し続ける限り、closureの名前空間も存在し続けなければなりません。closureは自身の名前空間を参照する関数innerを戻り値として変数(func)に代入させて存続させることによって、名前空間の消失を防ぐというトリックを使っています。\n\n\n\nclosure\n\n\nジェネレータとクロージャはどちらも履歴をもつ点で一見似ていますが、ジェネレータは始めに与えたルールに従って次々とオブジェクトを生成するに過ぎません。一方、クロージャは呼び出しごとに引数をとって挙動を操作することができるので、より複雑な操作が可能になります。\n\n\n引数を一つとり、これまで引数に与えた数字の中で最大であればTrueを、さもなくばFalseを返すクロージャclmaxを作成しなさい。ただし、一度目の呼び出しは必ずTrueを返すとする。\n\n\n\n\nこのように、Pythonでは、入れ子になったスコープのせいで関数内のある記号がどの名前空間を指しているのかがプログラマからみて分かりにくくなるという問題が生じ得ます。\nこの問題を研究するにあたって役に立つのが記号表(シンボルテーブル)です。記号表は、関数ブロックで使われている各記号と名前空間の関係を表した表であり、各関数ブロックとモジュールのトップレベルに対して一つずつ存在します。ローカル名前空間が、「関数内で定義されている記号の一覧」を与えるのに対して、関数の記号表は、「関数内で使われている記号の一覧」を与えることに注意してください。したがって、ある関数の記号表には、その関数の名前空間には属さない記号も現れます。\n記号表はPythonコードの構文解析後、バイトコンパイルの直前にインタープリタによって作成され、これを用いてバイトコンパイルが行われます(リファレンスマニュアル参照)。\n\n\nPythonにはsymtableというPythonコードの記号表を取得するモジュールがあります(Pythonのバージョンは3.8.8以上を使ってください。それより前だと変な挙動をする可能性があります。)。たとえば次のようなPythonコードにはグローバル名前空間が一つとローカル名前空間が2つあります。\n# %%\nx = 1\ndef f():\n    x = 2\n    y = 3\n\ndef g():\n    y = x + 1\n    print(y)\nこのコードにおいて、まずトップレベルの記号表を取得するには次のようにします。\n# %%\nimport symtable\n\ncode = \"\"\"\nx = 1\ndef f():\n    x = 2\n    y = 3\n\ndef g():\n    y = x + 1\n    print(y)\n\"\"\"\n\ntbl = symtable.symtable(code,\"main.py\",\"exec\")\nprint(tbl)      # トップレベルの記号表を出力\nprint()\n\ntop_syms = tbl.get_symbols()\nprint(top_syms) # 記号表の中の記号の一覧\nここで、symtableモジュールのsymtable関数を使っていますが、この関数は第1引数にPythonコード、第2引数に仮想的な主スクリプトの名前を与えます。第3引数は通常”exec”を指定すれば良いです。戻り値はSymbolTable型のオブジェクトですが、これがモジュールmainのトップレベルの記号表です。上記のコードでは変数tblに代入しています。\n記号表(SymbolTable)オブジェクトは、get_symbolsメソッドにより、記号の一覧をリストで取得できます。上記では、このリストを変数top_symsに代入しています。各記号は、Symbol型のオブジェクトです。\n# 出力\n\n&lt;SymbolTable for top in main.py&gt;\n\n[&lt;symbol 'x'&gt;, &lt;symbol 'f'&gt;, &lt;symbol 'g'&gt;]\n上記のように、トップレベルの記号表は、グローバルで定義された記号x、f、gのエントリーを持っていることが分かります。\n\n\n\n記号オブジェクトがもつis_globalメソッドは、記号がグローバルであればTrueを返します。実際、x、f、gが全てグローバル変数であることが次のようにして確認できます。\n# %%\nprint(\"Symbols in \" + tbl.get_name() + ':\\n')\n\nfor sym in top_syms:\n    print(sym,\"global:\",sym.is_global())\nここで、get_nameメソッドは、記号表の名前を取得するためのものです。\n# 出力\nSymbols in top:\n\n&lt;symbol 'x'&gt; global: True\n&lt;symbol 'f'&gt; global: True\n&lt;symbol 'g'&gt; global: True\n次に、各グローバル変数が、それ自身の記号表をもっているかどうか調べることにします。変数が関数の識別子であるならば、記号表をもっているはずですので、fとgは記号表をもっているはずです。記号表をもっているかどうか確認するには、is_namespaceメソッドを使います。\n# %%\nprint(\"Symbols in \" + tbl.get_name() + ':\\n')\n\nfor sym in top_syms:\n    print(sym,\"has table:\",sym.is_namespace())\n# 出力\n\nSymbols in top:\n\n&lt;symbol 'x'&gt; has table: False\n&lt;symbol 'f'&gt; has table: True\n&lt;symbol 'g'&gt; has table: True\n予想されたように、fとgは記号表を持ちます。\n同様に、is_localメソッドは、記号が、その記号表のある場所で定義されていればTrueを返します。従って、少々紛らわしいですが、x、f、gは全てグローバル変数ですが、is_localメソッドはTrueを返します。\n# %%\nprint(\"Symbols in \" + tbl.get_name() + ':\\n')\n\nfor sym in top_syms:\n    print(sym,\"is defined here:\",sym.is_local())\n# 出力\n\nSymbols in top:\n\n&lt;symbol 'x'&gt; is defined here: True\n&lt;symbol 'f'&gt; is defined here: True\n&lt;symbol 'g'&gt; is defined here: True\n\n\n\n上記のコードは今後再利用することになりますので、この時点で関数にしてしまいましょう。\n# %%\n# 記号表内の記号を調べる関数\n\ndef inspect_tbl(tbl):\n    print(\"Symbols in \" + tbl.get_name() + \":\\n\")\n    methods = [\"is_global()\",\"is_local()\",\"is_namespace()\"]\n    phrases = [\"is global:\",\"is local:\",\"has table:\"]\n    for method,phrase in zip(methods,phrases):\n        for sym in tbl.get_symbols():\n            print(sym,phrase,eval(\"sym.\" + method))\n        print()\nここで、二つばかり新しいテクニックが使われています。一つは、evalという関数で、これは引数に与えた文字列をコードとして評価し、その戻り値を返す関数です。\nもう一つは、zip関数で、これは複数のイテラブルを結合して一つのイテラブルを作る関数です。出来上がったイテラブルは、もとのイテラブルをタプルにしてループインデックスに渡します。したがって、\nfor method,phrase in zip(methods,phrases):\nと書くことによって、第i回目のループでは、methodsの第i要素がmethodに、phrasesの第i要素がphraseに代入されます。\nさて、inspect_tbl関数を、トップレベルの記号表tblに適用してみましょう。\n# %%\ninspect_tbl(tbl)\n# 出力\n\nSymbols in top:\n\n&lt;symbol 'x'&gt; is global: True\n&lt;symbol 'f'&gt; is global: True\n&lt;symbol 'g'&gt; is global: True\n\n&lt;symbol 'x'&gt; is local: True\n&lt;symbol 'f'&gt; is local: True\n&lt;symbol 'g'&gt; is local: True\n\n&lt;symbol 'x'&gt; has table: False\n&lt;symbol 'f'&gt; has table: True\n&lt;symbol 'g'&gt; has table: True\n\n\n\n記号が記号表を持つ場合(つまり関数である場合)、get_namespacesメソッドもしくはget_namespaceメソッドのどちらかで記号表を取得できます。この二つのメソッドの違いは以下の通りです。\n\n\n\nメソッド\n記号表をもつ場合\n記号表を持たない場合\n\n\n\n\nget_namespace\n記号表を返す\nエラーを出す\n\n\nget_namespaces\n記号表のリストを返す\n空のタプルを返す\n\n\n\n従って、エラーへの対処が面倒な場合はget_namespacesのほうが便利です。(なお実際にはほとんど無いと思いますが、一つの名前空間で同じ名前の関数が複数回定義されれば、一つの記号が複数の記号表を持ちます。このような場合、やはりget_namespaceはエラーを出します。)\nいま扱っているtblトップレベル記号表には、fとgという二つの関数を表す記号がありますので、これらの記号表を取得してみましょう。f、gはそれぞれtop_symsリストの第2、3要素であったことに注意してください。\n# %%\nf_tbl = top_syms[1].get_namespace()\ng_tbl = top_syms[2].get_namespace()\nprint(f_tbl)\nprint(g_tbl)\n# 出力\n\n&lt;Function SymbolTable for f in main.py&gt;\n&lt;Function SymbolTable for g in main.py&gt;\n\n\n\nそれではfとgのローカル記号表が取得できましたので、これらをinspect_tblで精査します。まずはfの記号表からです。\n# %%\ninspect_tbl(f_tbl)\n# 出力\n\nSymbols in f:\n\n&lt;symbol 'x'&gt; is global: False\n&lt;symbol 'y'&gt; is global: False\n\n&lt;symbol 'x'&gt; is local: True\n&lt;symbol 'y'&gt; is local: True\n\n&lt;symbol 'x'&gt; has table: False\n&lt;symbol 'y'&gt; has table: False\nこれを見ると分かるように、fの記号表には、記号xとyが存在しますが、どちらもローカル変数で、記号表を持たないことが分かります。\n次にg_tbl記号表を精査しましょう。\n# %%\ninspect_tbl(g_tbl)\n# 出力\n\nSymbols in g:\n\n&lt;symbol 'y'&gt; is global: False\n&lt;symbol 'x'&gt; is global: True\n\n&lt;symbol 'y'&gt; is local: True\n&lt;symbol 'x'&gt; is local: False\n\n&lt;symbol 'y'&gt; has table: False\n&lt;symbol 'x'&gt; has table: False\nこれを見ると分かるように、gのなかで参照はされているが代入はされていない記号xはグローバル変数であることが分かります。一方、yには値が代入されているので、ローカル変数になっています。このように、記号表を用いれば、関数ブロックにおいて、ある記号がどの名前空間を参照しているのかを特定することができます。\n上記のコードのような単純な例だと、記号表の恩恵はあまり感じられないかもしれません。そこで、記号表の役割を実感できる例を、ホームワークで出題することにします。\n最後に、is_localやis_global以外にもSymbol型はたくさんのメソッドを持っていて、名前解決の研究に非常に有用であることを述べておきます。以下、上に用いたメソッドとその他幾つかをまとめておきます。\n\n\n\n\n\n\n\nメソッド\n機能\n\n\n\n\nis_local\n記号がそのブロックで定義されていればTrue\n\n\nis_global\n記号がグローバルならばTrue(ただしトップに定義が無くてもTrueになる)\n\n\nis_referenced\n記号がそのブロックで使われていればTrue\n\n\nis_nonlocal\n記号がnonlocalならTrue\n\n\nis_namespace\n記号が記号テーブルを持つならばTrue\n\n\nget_namespaces\n記号がもつ記号テーブルのリストを返す\n\n\n\n他にもたくさんの興味深いメソッドがありますのでリファレンスマニュアルを参照してください。\n\n\n\n\n今回の講義では、以下の点について学びました。\n\n関数\nジェネレータ\n内包表記\nモジュール\n名前空間\nスコープ\nLEGBルール\n記号表\n\n名前空間やスコープはPythonの中核をなす概念なのでしっかり把握しておきましょう。\n\n\n\n\n『はじめてのPython』(Mark Lutz著、夏目 大 訳)(2009) オライリージャパン(第3版) ISBN-13: 978-4873113937.\n『CPython Internals: Your Guide to The Python 3 Interpreter』(A. Shaw, The real python.com tutorial team)(2021) Real Python. ISBN-13: 978-1775093343.\nPythonリファレンスマニュアル(symtable)"
  },
  {
    "objectID": "programming2025/programming-8.html#関数",
    "href": "programming2025/programming-8.html#関数",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "まずRにおける関数の作成を思い出しましょう。一例として、2つの引数の和を返すだけのmyadd関数を定義するには、次のように書くのでしたね。\nmyadd &lt;- function(a,b) {\n    z &lt;- a + b\n    return(z)\n}\n上記において、関数の中身(ボディ)は、中括弧の中で与えられます。a、bが引数であり、任意の数値を想定しています。関数returnを呼び出すことで関数の実行は終了し、returnの引数が戻り値として返されます。作成された関数は、無名のまま使うこともできますが、通常は何度も再利用するものです。そのため、myaddという名前(識別子)に、作成した関数オブジェクトを&lt;-演算子によって付値しています。これにより、識別子myaddに関数オブジェクトが結び付けられ、次のようにこの関数を何度でも呼び出せるようになります。\n&gt; res &lt;- myadd(2,8)\n&gt; print(res)\n[1] 10\nなお上記では、return(a+b)としても構いませんが、関数のボディの存在をわかりやすくするために、あえて複数行で記述しました。\n一方、Pythonの関数は、以下のdef命令を用いて作成し、必ず識別子への代入が行われます。(Pythonにもlambda式という無名関数はありますが、全く違う方法で作ります。残念ながらlambda式では複数行ブロックをもつ関数を作ることはできません。lambda式については教科書のセクション8.4.4に詳しく説明がありますのでよく読んでおいてください。)上記のRコードはPythonで書き直すと次のようになります。\ndef myadd(a,b):\n    z = a + b       # 関数ブロック\n    return z        #\n\nprint(myadd(5,4))\nprint(myadd(10,-2))\n# 出力\n9\n8\nifブロックやforブロックと同じように、関数の内容もまた、インデントを用いたブロックによって表現します。戻り値はreturn命令で返します。Pythonのdefやdelとおなじような命令であって、関数ではないことに注意しましょう。したがって、returnにはカッコは必要ありません。\nreturn命令を省略すると、関数はNoneオブジェクトを返します。Noneは「空っぽ」を意味するオブジェクトであり、メモリ上に常駐していて常に再利用されます。たとえば次の関数helloは、return命令を呼び出しませんので、その戻り値はNoneとなります。\ndef hello():\n    print('Hello, World!')\n\nx = hello()\nprint(x is None)\n# 出力\nHello, World!\nTrue\nまた、関数を終了させたいが、戻り値はいらないという場合は、単にreturnと書くと、Noneを返して終了します。何らかの理由で関数の実行を途中で終了したい場合に有用です。\n# %%\ndef hello(name):\n    if name == '':\n        print('hello,world!')\n        return\n    print('hello,' + name)\n\nhello('')\nhello('taro')\n# 出力\nhello,world!\nhello,taro\n本講義では省略しますが、Pythonの関数は引数のデフォルト値やキーワード引数など、様々な形式の引数を設定することが可能です。教科書のセクション8.3に詳しく説明されているので、良く読んでおきましょう。\n\n\n数値のリストを引数にとり、リストの全ての要素の3乗の和を求める関数sumcubeを作成しなさい。たとえば、次の関数呼び出しの戻り値は36になります。\nsumcube([1,2,3])"
  },
  {
    "objectID": "programming2025/programming-8.html#ジェネレータ",
    "href": "programming2025/programming-8.html#ジェネレータ",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "return命令の代わりにyield命令を使うと、関数はジェネレータ関数という特別な関数になります。ジェネレータ関数は、戻り値として、ジェネレータオブジェクトを返します。(ジェネレータ関数とジェネレータオブジェクトのどちらもジェネレータと呼ぶことがあるので注意してください。)\n\n\n\ngenerator\n\n\nジェネレータオブジェクトは、イテラブルなオブジェクトであり、主にループ処理で用いることができます。ループ処理でループインデックスに代入されるのは、yieldの戻り値です。ただし、注意しなくてはならないのは、yieldは作業を中断するだけで、関数ブロックの処理を終了しないということです。\nたとえば、次のようなジェネレータは、19以下の偶数を順番にループインデックスに返します。\n# %%\n# ジェネレータ関数の定義\ndef yield_even():\n    for i in range(20):\n        if i%2 == 0:\n            yield i\n\n# ジェネレータの活用\nfor i in yield_even():\n    print(i)\n# 出力\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\nなお、ジェネレータオブジェクトはイテレータでもあります。従って、next関数によって値を取得することができます。\nジェネレーターオブジェクトはイテラブルであるため、listコンストラクタやsetコンストラクタ、tupleコンストラクタに渡すことで、リストや集合、タプルを作ることができます。\nprint(list(yield_even()))\nprint(set(yield_even()))\nprint(tuple(yield_even()))\n# 出力\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}\n(0, 2, 4, 6, 8, 10, 12, 14, 16, 18)\nただし、あくまでも、有限回の呼び出しでStopIteration例外を発生するジェネレータである必要があります。練習2で作ったような、無限回nextで呼び出せるジェネレータをこのように使わないよう注意しましょう。\n上記の方法で辞書を作成するには、ジェネレータはキーと値のタプルを返すものでなくてはなりません。たとえば、次の例は、20未満の偶数をキー、その自乗を値としてもつ辞書を作成するコードです。\ndef yield_even():\n    for i in range(20):\n        if i % 2 == 0:\n            yield i,i**2\n\nprint(dict(yield_even()))\n# 出力\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64, 10: 100, 12: 144, 14: 196, 16: 256, 18: 324}\nジェネレータから得られた値をそのまま使うのではなく、若干の編集を加えてリストや集合にしたい場合は、次に説明する内包表記を用いることができます。\ndef yield_even():\n    for i in range(20):\n        if i%2 == 0:\n            yield i\n\n# 内包表記(奇数の列)\nx = [i + 1 for i in yield_even()]\nprint(x)\n# 出力\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n\n呼び出すたびに1のn乗、2のn乗、3のn乗…という風に、正整数のn乗を返すジェネレータオブジェクトを生成するジェネレータ関数genpowを定義しなさい。この関数の引数は、指数nです。\nたとえば、次のように書くと、xはnext(x)を実行するたびに正整数の3乗を返すジェネレータオブジェクトになります。\nx = genpow(3)\nヒント: whileを用いた無限ループを活用します。\n\n\n\n練習2の応用です。genpowを修正して、指数nに加えて、整数の上限maxを引数に加えなさい。たとえば、次のように書くと、xはnext(x)の呼び出しによって最大10**3まで返せるジェネレータオブジェクトになります。ただし、maxに負の数を与えると、練習2のgenpowと同じで上限値はなくなり、next(x)は任意の回数呼び出せるようになるとします。\nx = genpow(max,n)"
  },
  {
    "objectID": "programming2025/programming-8.html#内包表記",
    "href": "programming2025/programming-8.html#内包表記",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "脱線しますが、折角ですので、ここで内包表記についてお話ししておきます。内包表記は、ループ処理の結果をリスト、辞書、集合などのコンテナ型オブジェクトにまとめるためのPython特有の構文であり、慣れるとコードをコンパクトに書くのに非常に有用です。以下が、内包表記の基本形です。\n# リスト内包表記\n[iを含む表現 for i in ループ範囲]\n# セット(集合)内包表記\n{iを含む表現 for i in ループ範囲}\n# 辞書内包表記\n{iを含む表現:iを含む表現 for i in ループ範囲}\n例えば、100までの偶数の自乗をすべて収めたリストを作るときは、次のように書きます。\n&gt;&gt;&gt; [i**2 for i in range(0,100,2)]\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]\n同じことをforループでやるとすると、たとえば次のようになります。\n# %%\nx = []\nfor i in range(0,100,2):\n    x.append(i**2)\n\nprint(x)\n# 出力\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]\nセット内包表記は[]を{}にするだけですが、リストと違い重複を除去できます。次のコードは、100までの偶数の自乗を5で割った余りを集めたリストと集合を計算するためのものです。\n&gt;&gt;&gt; [i**2 % 5 for i in range(0,100,2)]\n[0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4, 0, 4, 1, 1, 4]\n&gt;&gt;&gt; {i**2 % 5 for i in range(0,100,2)}\n{0, 1, 4}\n辞書内包表記は少し特徴的です。たとえば次は、“hello,world!”という文字列のそれぞれの文字をキーとし、キーの大文字を値とする辞書を作成するコードです。やはりこの場合も、キーの重複は取り除かれます。\n&gt;&gt;&gt; x = {c:c.upper() for c in \"hello,world!\"}\n&gt;&gt;&gt; x\n{'h': 'H', 'e': 'E', 'l': 'L', 'o': 'O', ',': ',', 'w': 'W', 'r': 'R', 'd': 'D', '!': '!'}\n辞書で内包表記でキーの重複が取り除かれる際には、最新の値が採用されるので注意が必要です。たとえば、次のコードは、キーと値を入れ替えた辞書を作るものです。値は一意とは限らないので、重複部分は除去され、最新のペアだけが残ります。\n# %%\nx = {'foo':1,'bar':2,'baz':1}\n{j:i for i,j in x.items()}\n# 出力\n{1: 'baz', 2: 'bar'}\n\n\n文字列’Python’から1文字目を1回、2文字目を2回、…n文字目をn回繰り返した文字列’Pyyttthhhhooooonnnnnn’をリスト内包表記を使って作成しなさい。"
  },
  {
    "objectID": "programming2025/programming-8.html#ifif-elseつき内包表記",
    "href": "programming2025/programming-8.html#ifif-elseつき内包表記",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "先に挙げた、100までの偶数の自乗を含むリストは、次のようにifと組み合わせた内包表記によっても作成できます。\n# %%\nx = [i**2 for i in range(100) if i%2 ==0]\nprint(x)\n# 出力\n\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604]\n上記では、iが2で割り切れるときのみi**2をリストに加える、という意味になります。\nところが、iが2で割り切れるときはi**2をリストに加え、そうでないときは0を加えよ、という命令にしたいときは、下のようにかなり異なる表現になります。\n# %%\nx = [i**2 if i%2==0 else 0 for i in range(100)]\nprint(x)\n実はこの表現においては、単文のif-else構文が使われています。単文のif-elseは次のように用います。\n式A if 条件 else 式B\nこのように書くと、「条件が成り立っていれば式A、さもなくば式B」という意味になります。本来内包表記とは直接関係がなく、どこでも用いることができます。たとえばxにiの絶対値を代入したい場合は次のように書くことができます。(実際にはabsという絶対値を返すビルトイン関数があります。)\nx = i if i&gt;=0 else -i\nこのように、ifつき内包表記とif-elseつき内包表記は全く別のものですので、両者を組み合わせることもできます(おすすめはしませんが)。たとえば、「7の倍数のうち、3の倍数は自乗し、3で割り切れない数はそのまま格納したリスト」は次のように表現できます。\n# %%\nx = [i**2 if i%3==0 else i for i in range(100) if i%7==0]\nprint(x)\n# 出力\n\n[0, 7, 14, 441, 28, 35, 1764, 49, 56, 3969, 70, 77, 7056, 91, 98]\nこのように、内包表記は非常に高い表現力をもっています。forループの結果をリストに格納したい、ということはプログラミングをやっていると頻発しますので、この機会にぜひ覚えておきましょう。\n\n\n文字列”this practice is too difficult for most students”に含まれているアルファベット(空白は含まない)のうち、3回以上用いられているものだけを集めた集合を内包表記で作りなさい。"
  },
  {
    "objectID": "programming2025/programming-8.html#モジュールの種類",
    "href": "programming2025/programming-8.html#モジュールの種類",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "さて、自作した関数を複数のプログラムで再利用したい場合には、モジュールの仕組みを活用するのが便利です。これまでにも、sysモジュールやcopyモジュールを随所で活用してきましたが、ここでモジュールとはどのようなものかを明確にしておきましょう。\nモジュールは、Pythonスクリプトから読み込んで使用できる関数や変数、データ型、Pythonコードの集合のことを広く指します。\nPythonには以下の4種類のモジュールがあります。\n\n\n\n\n\n\n\n\n種類\n説明\n例\n\n\n\n\n外部ファイル\nPythonやCで作成され、importで呼び出して使う\ncopy\n\n\nビルトインモジュール\nインタープリタに組み込まれ、importで呼び出して使う(builtinsモジュールは例外)\nsys、math\n\n\nbuiltinsモジュール\nビルトイン関数・定数を定義している特別なビルトインモジュールで、起動時に自動で読み込まれる\nbuiltins\n\n\nmainモジュール\n主スクリプトの属するモジュール\n任意のスクリプト\n\n\n\n\n\n\nmodule_types\n\n\n\n\n全てのPythonスクリプトは他のPythonスクリプトにimport命令で読み込めるので、モジュールとして機能します。その他にも、たとえばCPythonインタープリタであれば、C言語やCythonと言った言語でモジュールを作成できます。こういった外部ファイルで提供されたモジュールは、import命令によって主プログラムに読み込んで使用することができます。たとえばcopyモジュールはcopy.pyというPythonスクリプトとして存在しており、import命令で読み込めます。\n\n\n\nそれに対して、ファイルの形では存在していないビルトインモジュールという特別なタイプのモジュールがあります。たとえばsysはビルトインモジュールであり、インタープリタに埋め込まれています。その他、数学関数を収めたmathもビルトインモジュールです。こういったものもimport文で読み込んで使うことができます。\nimportしたモジュールがビルトインかどうかは単にそのオブジェクトをprintしてみればわかります。\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; print(sys)\n&lt;module 'sys' (built-in)&gt;\n&gt;&gt;&gt; import copy\n&gt;&gt;&gt; print(copy)\n&lt;module 'copy' from '/usr/lib/python3.8/copy.py'&gt;\nビルトインモジュールの場合は、sysのように(built-in)と表示されます。一方、ファイルの場合は、copyのようにモジュールファイルのある場所が表示されます。\n\n\n\nビルトインモジュールの中には、ただ一つだけbuiltinsという特別なモジュールがあります。これは、たとえばprintなど、ビルトイン関数やTrueなどのビルトイン定数を定義しているモジュールです。builtinsだけは、importを必要とせず、__builtins__という別名でPythonの起動と同時に自動的に読み込まれます。試しに、__builtins__をprintしてみてください。\n&gt;&gt;&gt; print(__builtins__)\n&lt;module 'builtins' (built-in)&gt;\nこのように、__builtins__という名前がすでに定義されていて、その正体はbuiltinsというビルトインモジュールであることがわかります(とてもややこしいので混乱しないように注意してください)。これは、builtinsモジュールが__builtins__という別名で読み込まれているということを意味します。モジュールの別名読み込みは一般に次のようなimport-as文で行います。\nimport モジュール名 as 別名\nつまり、builtinsモジュールだけは、起動時に次のように読み込まれたのと同じ状態になるということです。\nimport builtins as __builtins__\nなぜこのようになっているかというのは、名前空間の節で説明します。\n\n\n\n最後に、mainというモジュールがあります(正確には__main__)。これは、実行時の主スクリプトの別名です。たとえばコマンドプロンプトで次のようにfile.pyスクリプトを実行したとします。\npython file.py\nこのとき、file.pyに記述された変数、関数、コード、データ型は全てmainモジュールに属することになります。\nこのように、Pythonスクリプトは全てモジュールとして機能しますが、その逆は必ずしも成り立ちません。モジュールはスクリプトよりも広い概念です。"
  },
  {
    "objectID": "programming2025/programming-8.html#モジュールを作る",
    "href": "programming2025/programming-8.html#モジュールを作る",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "それでは折角ですので、モジュールを自作してみましょう。といっても、二つのPythonスクリプトを作成し、一方をもう一方からimportするだけです。importする側がmainモジュールとなります。\nGitHubディレクトリの中にmy_first_moduleというフォルダを作ってVS Codeで開きましょう。そして、mymod1.pyというファイルを作って開きましょう。この中に、次のように記述します。\nx = 5\ndef hello():\n    print(\"Hello,World!\")\n記述を終えたら保存します。ここでの目的は、mymod1.pyの中で定義された変数xと関数helloを再利用することです。\n次に、mymain.pyというファイルを作成して開き、次のように記述してインタラクティブモードで実行してみましょう。\n# %%\nimport mymod1\n\nprint(mymod1.x)\nmymod1.hello()\nここで、mymod1.xによって、mymod1.pyで定義された変数xにアクセスしていることに注意してください。上手くimportできれば、次のように表示されるはずです。\n# 出力\n5\nHello,World!\nここで2点注意事項があります。\n\nimportでの読み込みは初回のみ有効であり、モジュールの再読み込み(リロード)には使えない。\n一度読み込まれたモジュールはバイトコンパイルされ、変更がない限り再利用され続ける。"
  },
  {
    "objectID": "programming2025/programming-8.html#モジュールのリロード",
    "href": "programming2025/programming-8.html#モジュールのリロード",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "上記1は、モジュールを変更したら、一旦Pythonを再起動しないと、変更したモジュールをimportで読み込み直せないということを意味します。これを覚えておくことは大変重要です。\nたとえば、まずmymain.pyをインタラクティブモードで実行したあと、インタラクティブモードを起動したままで、mymod1.pyを次のように変更して保存してみましょう。\nx = 100\ndef hello():\n    print(\"Good bye,World!\")\nそして、mymain.pyをインタラクティブモードでもう一度実行してみてください。次のように、mymod1.pyの変更が反映されていないはずです。\n# 出力\n\n5\nHello,World!\nそれでは、一度インタラクティブモードを終了してください(Pythonを停止する)。それからもう一度同じmymain.pyのコードを実行してください。次のように、変更が反映されるはずです。\n100\nGood bye,World!\nPythonを終了せずにモジュールの再読み込みをするには、次のようにimportlibモジュールのreload関数を使う方法もあります。モジュールの開発中は、一々Pythonを再起動するよりもこちらのほうが便利でしょう。一度読み込まれたmymod1モジュールを再び読み込むには、次のように記述します。\nimport importlib\nimportlib.reload(mymod1)"
  },
  {
    "objectID": "programming2025/programming-8.html#モジュールのバイトコード",
    "href": "programming2025/programming-8.html#モジュールのバイトコード",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "import文によって読み込まれたPythonスクリプトのモジュールは、通常インタプリタによってバイトコンパイルされ__pycache__というディレクトリに保存されます。__pycache__はmainモジュールファイル(主スクリプト)が置かれていた場所に作られます。VS Code上で閲覧できるはずなので、開いてみてください。\n中には、mymod1.cpython-38.pycというバイナリファイルが作られているはずです。これがmymod1.pyをバイトコンパイルして出来たバイトコードです。\n通常、mainモジュールとして実行されるファイルは、実行のたびにバイトコンパイルされ、バイトコードがファイルに保存されることはありません(強制的にバイトコードを作ることは可能です)。一方、importされたファイルは(可能な限り)バイトコードを保存し、ファイル内容に変更がない限り再コンパイルしません。\nこのようにして、モジュールのバイトコンパイルにかける時間を節約することで、Pythonは実行までの時間を短縮する工夫をしています。通常モジュールのバイトコンパイルを意識する必要はありませんが、教養として知っておきましょう。\n\n\n主スクリプトを強制的にバイトコンパイルするには、コンソール(Anaconda prompt)上で次のように入力します。\npython -m compileall script.py\nここでscript.pyはスクリプト名です。このようにして作成された主スクリプトのバイトコードは通常のモジュールと同じく__pycache__内に作成され、テキストで書かれたスクリプトと全く同じように実行できます。\n“Hello, World!”と出力するスクリプトを作成してコンパイルし、作成されたバイトコードを見つけてください。また、そのバイトコードを実行してください。"
  },
  {
    "objectID": "programming2025/programming-8.html#名前空間",
    "href": "programming2025/programming-8.html#名前空間",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "名前空間とは、mainを始めとするモジュールの中で定義された記号(識別子)の一覧および、それらの記号が参照するオブジェクトの対応表のことです。一つのモジュールには、次の3種類の名前空間が存在します。\n\n\n\n\n\n\n\n名前空間\n含まれる記号\n\n\n\n\nローカル名前空間\n関数のなかで定義された記号\n\n\nグローバル名前空間\nモジュールファイルのトップレベル(関数の外)で定義された記号\n\n\nビルトイン名前空間\n__builtins__で定義されている記号\n\n\n\n記号がどの名前空間に属するかは、それがどこで最初に定義されたかによって決まります。最初から定義されている記号を除き、記号が定義されるのは代入が起きるときです。従って、モジュールのトップレベル、つまり関数の外で値を代入された変数はグローバル変数となり、関数の中で値を代入された変数はローカル変数となります。\n\n\nそれぞれの名前空間は、具体的に辞書の形で取り出すことができます。グローバル名前空間の辞書はビルトイン関数globalsを使って取得できます。\nまず、Pythonを起動してすぐglobalsを呼び出すと次のようになります。\n&gt;&gt;&gt; globals()\n{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__doc__': None, '__package__': None}\n&gt;&gt;&gt; len(globals())\n4\nこのように、グローバル名前空間には起動直後にすでに幾つかの変数が定義されていることが分かります。グローバル名前空間で定義されている変数をグローバル変数と呼びます。\n\n\n\nグローバル変数\n意味\n\n\n\n\n__builtins__\nビルトイン名前空間\n\n\n__name__\nモジュールの名前\n\n\n\nこのうち重要なのは、__builtins__と__name__です。モジュールがmainモジュールとして直接Pythonによって実行された場合、__name__には\"__main__\"が設定されますが、他のファイルによってimportされた場合には__name__にはモジュールのファイル名が設定されます。これにより、モジュールは自分が主スクリプトとして実行されているのか、他のモジュールにimportされているのかを見分けることができます。\n一方、__builtins__はビルトイン名前空間を表します。これについては、ビルトイン名前空間のところで解説します。\nモジュールのトップレベルで変数を作成してみましょう。\n&gt;&gt;&gt; x = \"I am global.\"\n&gt;&gt;&gt; 'x' in globals()\nTrue\n&gt;&gt;&gt; globals()['x']\n'I am global.'\n&gt;&gt;&gt;\nこのように、xをトップレベルで定義すると、globals()辞書に変数xが定義され、グローバル変数となったことが分かります。\n\n\n\n次のような振る舞いをする関数printmodを定義したPythonスクリプトmymod2.pyを作成し、挙動をテストしなさい。\nprintmodは次のような関数とします。mymod2.pyがスクリプトからimportされているときは、“Script mymod2.py is imported by another script.”と印字し、mymod2.pyが主スクリプトとして実行されているときは、“Script mymod2.py is executed as the main module.”と印字します。\n\n\n\nローカル名前空間は、各関数につき一つずつ存在しており、関数内で定義された記号とそれが参照するオブジェクトの対応を与えます。ローカル名前空間で定義された変数をローカル変数と呼びます。ローカル名前空間を辞書として取り出すには、関数内でビルトイン関数のlocalsを呼び出します。\n# %%\n\nx = 1\ndef f(y):\n    z = 3\n    print(locals())\n\nf(2)\n# 出力\n\n{'y': 2, 'z': 3}\n上記では、関数fの中でlocalsを呼び出したので、fの名前空間が辞書として出力されました。この名前空間には、fの中で定義されている変数であるyとzが登録されています。\nなお、Pythonのリファレンスマニュアルにあるように、locals()の戻り値である辞書を編集してはいけません。locals()の戻り値は名前空間を辞書にコピーしたものであって名前空間そのものではないため、locals()に加えた変更はローカル名前空間に反映されません。\n\n\n\nビルトイン名前空間は、TrueやNoneといった全てのビルトイン定数とビルトイン関数を定義している名前空間です。ビルトイン名前空間は、builtinsモジュールの__dict__属性(変数)に辞書として格納されています。builtinsは起動時にすでに__builtins__という別名で読み込まれているため、これを使うことができます。\n&gt;&gt;&gt; __builtins__.__dict__\n{'__name__': 'builtins', '__doc__': \"Built-in functions, exceptions, and other objects.\\n\\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.\", '__package__': '', '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, ...(以下省略)\n&gt;&gt;&gt; len(__builtins__.__dict__)\n154\n上記のように、150個以上のビルトイン関数・定数・データ型等が定義されていることがわかります(具体的な数はPythonバージョンや処理系に依存しえます。)\nここで、__builtins__という名前の働きについて説明します。 (__builtins__の働きは、現在のモジュールがmainかどうかによって少し違います。以下では、話を単純にするため、現在のモジュールがmainであると仮定します。)\n上述のように、モジュールがmainとして実行されると、builtinsモジュールが__builtins__という別名で読み込まれます。Pythonがビルトイン関数の名前を参照するとき、実際には、この__builtins__という名前で読み込まれたモジュールのグローバル名前空間が検索されます。(したがって、研究目的以外では絶対に行うべきではありませんが、別のモジュールを__builtins__という名前で上書きインポートすることにより、Pythonはそのモジュールのグローバル名前空間をビルトイン名前空間と『誤認』することになります。)\nPythonのリファレンスマニュアルによると、Pythonが__builtins__という名前をどのように使うかはPythonの実装に依存しているようです。リファレンスマニュアルには、以下のようにこの__builtins__をプログラムの中で使うべきでないと明記されています。\n\nUsers should not touch __builtins__; it is strictly an implementation detail. Users wanting to override values in the builtins namespace should import the builtins module and modify its attributes appropriately.\n\n上記にあるように、ビルトイン名前空間を操作したいときは、builtinsモジュールを別途importしてそれを操作するのが正しい方法です。\nたとえば次のようにすると、ビルトイン名前空間にxという変数を追加することができ、printなどのビルトイン関数と同じようにプログラムのどこからでも呼び出すことができるようになります。\n&gt;&gt;&gt; import builtins\n&gt;&gt;&gt; builtins.x = 5\n&gt;&gt;&gt; __builtins__.__dict__['x']\n5\n&gt;&gt;&gt; x\n5\n\n\n\nビルトイン名前空間に追加された変数は、プログラム全体から参照可能になることを次のようにして確かめてください。\n次のような3つのスクリプトを作成し、main.pyを実行してください。\n# main.py\nimport mymod3\nimport mymod4\n\nprint(\"In main: \",x)\n# mymod3.py\nimport builtins\nbuiltins.x = 1\n# mymod4.py\nprint(\"In mymod4: \",x)"
  },
  {
    "objectID": "programming2025/programming-8.html#スコープ",
    "href": "programming2025/programming-8.html#スコープ",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "Pythonで変数名や関数名がどのように使われるかを理解するには、名前空間だけでなくスコープの概念を理解する必要があります。\nスコープとは、モジュールファイルのなかで、ある名前空間の記号が、記号単体で参照できるコードの範囲を指します。ここで記号単体とは、たとえばxのように書くことです。sys.xのように書くことは記号単体とは言いません。スコープは、それぞれの名前空間に一つずつ存在します。変数xのスコープというと、通常xが属する名前空間のスコープを指します。\nグローバル名前空間のスコープをグローバルスコープ、ローカル名前空間のスコープをローカルスコープ、ビルトイン名前空間のスコープをビルトインスコープと呼びます。\n\n\n\nスコープ名\n対応する名前空間\n範囲\n\n\n\n\nグローバルスコープ\nグローバル名前空間\nモジュール全体\n\n\nローカルスコープ\n各関数のローカル名前空間\n関数ブロック\n\n\nビルトインスコープ\nビルトイン名前空間\nプログラム全体\n\n\n\n\n\nグローバルスコープは、モジュールのトップレベルで代入された記号を記号単体で使うことができるコードの範囲です。トップレベルで代入された変数や関数は、モジュールファイルのどこからでも記号単体で参照できますので、グローバルスコープはモジュールファイル全体ということになります。グローバルという言葉が紛らわしいですが、グローバル名前空間の記号はモジュールの外からは参照できません。\n\n\n\n一方関数内で定義された記号はその関数の中でしか記号単体で参照できないので、ローカルスコープは対応する関数の関数ブロックに等しくなります。\n\n\n\nビルトイン名前空間の記号は文字通り、どこからでも記号単体で参照できます。従ってビルトインスコープはプログラム全体を指す最も広いスコープです。"
  },
  {
    "objectID": "programming2025/programming-8.html#legbルール",
    "href": "programming2025/programming-8.html#legbルール",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "一般にスコープは入れ子の関係にあります。たとえば関数のローカルスコープは、モジュールのグローバルスコープに含まれています。内側のスコープでは、両方の名前空間が参照できるので、ある記号が参照されたとき、Pythonはどちらの名前空間を先に検索するのかを決定する必要があります。\nPythonは、内側から外側へ向かって名前空間を検索します。具体的には、以下のような順番で、名前空間を検索します。\n\nローカル名前空間(Local)\n外側の関数のローカル名前空間(Enclosing)\nグローバル名前空間(Global)\nビルトイン名前空間(Built-in)\n\n\n\n\nlegb\n\n\n1〜4のどの名前空間を参照しても記号が見つからなかったとき、Pythonはエラー(NameError)を出します。この検索パターンをLEGBルールと呼びます。\n注意しなくてはならないのは、関数の内側では、一つの記号は関数ブロックを通して必ず同じ名前空間を参照するということです。\nたとえば、次のコードのコードは、間違ったコードとして非常に有名なものです。\n# %%\nx = 5\n\ndef f():\n    print(x)\n    x = 3\n    print(x)\n\nf()\nこれを書いたプログラマは、関数fの中で、まず5を出力し、次に3を出力することを意図していますが、これを実行すると、次のようなエラーが出ます。\n# 出力\n\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n\n...(中略)...\n\n      239 \n      240 def f():\n----&gt; 241     print(x)\n      242     x = 3\n      243     print(x)\n\nUnboundLocalError: local variable 'x' referenced before assignment\n最後のUnboundLocalErrorの行に注目しましょう。このエラーは、「値が割り当てられる前にxが参照された」というものです。\nなぜこのようなエラーが出たかというと、x=3というxへの代入操作が関数内に存在していることにより、xがfのローカル名前空間にエントリーし、関数ブロックの全域でローカル変数とみなされるからです。従って、1回目のprint(x)で、xが定義されていない、というエラーが出るわけです。\n同様ですが、もっと分かりにくいコードは次のようなものです。\n# %%\nx = 5\n\ndef f():\n    x += 1\n    print(x)\n\nf()\n出力は以下の通りです。\n# 出力\n\n---------------------------------------------------------------------------\n\n...(中略)...\n      249 \n      250 def f():\n----&gt; 251     x += 1\n      252     print(x)\n      253 \n\nUnboundLocalError: local variable 'x' referenced before assignment\nx += 1は、x = x + 1と同じ意味です。これはxへの代入を伴いますが、その時点で、xはfのローカル名前空間に属するローカル変数とみなされます。x = x + 1の右辺は、xの値を参照していますので、「まだ定義されていないローカル変数が参照された」というエラーが出るわけです。\nしかしながら、次のような操作では、エラーが出ません。なぜなら、関数内部でxが指すオブジェクトへの変更は行われましたが、xの代入は行われていないため、xはグローバル変数のままだからです。\n# %%\n# %%\nx = [1,2,3]\n\ndef f():\n    print(x)\n    x.append(4)\n\nf()\nprint(x)\n\n\nローカル名前空間に記号が見当たらないときは、一つ外側の名前空間にアクセスするため、関数の内部で自分自身を参照することが可能になります。\nたとえば、次の関数は、自分自身のデータ型を返すおかしな関数です。\n# %%\ndef typer():\n    return type(typer)\n\nprint(typer())\n# 出力\n&lt;class 'function'&gt;\nもう少し馬鹿々々しくない次の関数は、xが正整数のときにxの階乗x!を返す関数です。\n# %%\ndef f(x):\n    if type(x) is int and x &gt; 0:\n        if x &gt; 1:\n            return x*f(x-1)\n        else:\n            return x\n    else:\n        print('x must be a positive integer')\n        return\nf(5)\n# 出力\n120"
  },
  {
    "objectID": "programming2025/programming-8.html#globalnonlocal命令",
    "href": "programming2025/programming-8.html#globalnonlocal命令",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "関数の内側で、グローバル変数を編集したり、外側の関数のローカル変数を編集することも可能です。そのためには、global命令とnonlocal命令を使います。\n# %%\n# %%\nx = 5\n\ndef f():\n    global x\n    x += 1\n\nf()\nprint(x)\n# 出力\n6\nまた、入れ子になった関数で外側の名前空間の変数を編集するには、nonlocal命令を使います。\n# %%\nx = 0\n\ndef outer():\n    x = 0\n\n    def inner():\n        nonlocal x\n        x += 1\n        print(\"At inner:\",x)\n\n    inner()\n    print(\"At outer:\",x)\n\nouter()\nprint(\"At global:\",x)\n# 出力\n\nAt inner: 1\nAt outer: 1\nAt global: 0\n残念ながら、関数の入れ子において2つ以上上の階層の名前空間を指定する命令は存在しません。したがって、次の例において、fの名前空間を直接指定する命令はありません。\n# %%\nx = 0\n\ndef f():\n    x = 0\n    \n    def g():\n        x = 0\n        \n        def h():\n            nonlocal x\n            x += 1\n            print(\"At h:\",x)\n\n        h()\n        print(\"At g:\",x)\n\n    g()\n    print(\"At f:\",x)\n\nf()\nprint(\"At global:\",x)\nAt h: 1\nAt g: 1\nAt f: 0\nAt global: 0\n\n\n上記の3重入れ子関数において、nonlocalをglobalに変えたときにどうなるか予測し、実際に実行して結果を確かめなさい。"
  },
  {
    "objectID": "programming2025/programming-8.html#クロージャ",
    "href": "programming2025/programming-8.html#クロージャ",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "nonlocal宣言の最も重要な応用が、クロージャと呼ばれる独特のプログラミングテクニックです。ある程度複雑なプログラムになると、関数呼び出しにおいて、呼び出すごとに関数の挙動を変化させたい場合が生じます。そのような場合にクロージャが役に立ちます。\nたとえば、任意のオブジェクトを引数にとり、過去の呼び出しにおいて引数として渡した全てのオブジェクトを格納したリストを戻り値として返す関数を考えてみましょう。これは次のように実現できます。\ndef closure():\n    args = []\n    def inner(arg):\n        nonlocal args\n        args.append(arg)\n        return args\n    return inner\n\nfunc = closure()\nこれでfuncは、呼び出す度にこれまでの引数のリストを返す関数になります。試してみてください。\n通常は、関数のローカル名前空間は、関数の呼び出しが終了した時点で消失します。しかし上の関数closureの場合、内部の関数innerがclosureの名前空間をnonlocal宣言によって参照しています。したがって、innerが存在し続ける限り、closureの名前空間も存在し続けなければなりません。closureは自身の名前空間を参照する関数innerを戻り値として変数(func)に代入させて存続させることによって、名前空間の消失を防ぐというトリックを使っています。\n\n\n\nclosure\n\n\nジェネレータとクロージャはどちらも履歴をもつ点で一見似ていますが、ジェネレータは始めに与えたルールに従って次々とオブジェクトを生成するに過ぎません。一方、クロージャは呼び出しごとに引数をとって挙動を操作することができるので、より複雑な操作が可能になります。\n\n\n引数を一つとり、これまで引数に与えた数字の中で最大であればTrueを、さもなくばFalseを返すクロージャclmaxを作成しなさい。ただし、一度目の呼び出しは必ずTrueを返すとする。"
  },
  {
    "objectID": "programming2025/programming-8.html#記号表高度な話題",
    "href": "programming2025/programming-8.html#記号表高度な話題",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "このように、Pythonでは、入れ子になったスコープのせいで関数内のある記号がどの名前空間を指しているのかがプログラマからみて分かりにくくなるという問題が生じ得ます。\nこの問題を研究するにあたって役に立つのが記号表(シンボルテーブル)です。記号表は、関数ブロックで使われている各記号と名前空間の関係を表した表であり、各関数ブロックとモジュールのトップレベルに対して一つずつ存在します。ローカル名前空間が、「関数内で定義されている記号の一覧」を与えるのに対して、関数の記号表は、「関数内で使われている記号の一覧」を与えることに注意してください。したがって、ある関数の記号表には、その関数の名前空間には属さない記号も現れます。\n記号表はPythonコードの構文解析後、バイトコンパイルの直前にインタープリタによって作成され、これを用いてバイトコンパイルが行われます(リファレンスマニュアル参照)。\n\n\nPythonにはsymtableというPythonコードの記号表を取得するモジュールがあります(Pythonのバージョンは3.8.8以上を使ってください。それより前だと変な挙動をする可能性があります。)。たとえば次のようなPythonコードにはグローバル名前空間が一つとローカル名前空間が2つあります。\n# %%\nx = 1\ndef f():\n    x = 2\n    y = 3\n\ndef g():\n    y = x + 1\n    print(y)\nこのコードにおいて、まずトップレベルの記号表を取得するには次のようにします。\n# %%\nimport symtable\n\ncode = \"\"\"\nx = 1\ndef f():\n    x = 2\n    y = 3\n\ndef g():\n    y = x + 1\n    print(y)\n\"\"\"\n\ntbl = symtable.symtable(code,\"main.py\",\"exec\")\nprint(tbl)      # トップレベルの記号表を出力\nprint()\n\ntop_syms = tbl.get_symbols()\nprint(top_syms) # 記号表の中の記号の一覧\nここで、symtableモジュールのsymtable関数を使っていますが、この関数は第1引数にPythonコード、第2引数に仮想的な主スクリプトの名前を与えます。第3引数は通常”exec”を指定すれば良いです。戻り値はSymbolTable型のオブジェクトですが、これがモジュールmainのトップレベルの記号表です。上記のコードでは変数tblに代入しています。\n記号表(SymbolTable)オブジェクトは、get_symbolsメソッドにより、記号の一覧をリストで取得できます。上記では、このリストを変数top_symsに代入しています。各記号は、Symbol型のオブジェクトです。\n# 出力\n\n&lt;SymbolTable for top in main.py&gt;\n\n[&lt;symbol 'x'&gt;, &lt;symbol 'f'&gt;, &lt;symbol 'g'&gt;]\n上記のように、トップレベルの記号表は、グローバルで定義された記号x、f、gのエントリーを持っていることが分かります。\n\n\n\n記号オブジェクトがもつis_globalメソッドは、記号がグローバルであればTrueを返します。実際、x、f、gが全てグローバル変数であることが次のようにして確認できます。\n# %%\nprint(\"Symbols in \" + tbl.get_name() + ':\\n')\n\nfor sym in top_syms:\n    print(sym,\"global:\",sym.is_global())\nここで、get_nameメソッドは、記号表の名前を取得するためのものです。\n# 出力\nSymbols in top:\n\n&lt;symbol 'x'&gt; global: True\n&lt;symbol 'f'&gt; global: True\n&lt;symbol 'g'&gt; global: True\n次に、各グローバル変数が、それ自身の記号表をもっているかどうか調べることにします。変数が関数の識別子であるならば、記号表をもっているはずですので、fとgは記号表をもっているはずです。記号表をもっているかどうか確認するには、is_namespaceメソッドを使います。\n# %%\nprint(\"Symbols in \" + tbl.get_name() + ':\\n')\n\nfor sym in top_syms:\n    print(sym,\"has table:\",sym.is_namespace())\n# 出力\n\nSymbols in top:\n\n&lt;symbol 'x'&gt; has table: False\n&lt;symbol 'f'&gt; has table: True\n&lt;symbol 'g'&gt; has table: True\n予想されたように、fとgは記号表を持ちます。\n同様に、is_localメソッドは、記号が、その記号表のある場所で定義されていればTrueを返します。従って、少々紛らわしいですが、x、f、gは全てグローバル変数ですが、is_localメソッドはTrueを返します。\n# %%\nprint(\"Symbols in \" + tbl.get_name() + ':\\n')\n\nfor sym in top_syms:\n    print(sym,\"is defined here:\",sym.is_local())\n# 出力\n\nSymbols in top:\n\n&lt;symbol 'x'&gt; is defined here: True\n&lt;symbol 'f'&gt; is defined here: True\n&lt;symbol 'g'&gt; is defined here: True\n\n\n\n上記のコードは今後再利用することになりますので、この時点で関数にしてしまいましょう。\n# %%\n# 記号表内の記号を調べる関数\n\ndef inspect_tbl(tbl):\n    print(\"Symbols in \" + tbl.get_name() + \":\\n\")\n    methods = [\"is_global()\",\"is_local()\",\"is_namespace()\"]\n    phrases = [\"is global:\",\"is local:\",\"has table:\"]\n    for method,phrase in zip(methods,phrases):\n        for sym in tbl.get_symbols():\n            print(sym,phrase,eval(\"sym.\" + method))\n        print()\nここで、二つばかり新しいテクニックが使われています。一つは、evalという関数で、これは引数に与えた文字列をコードとして評価し、その戻り値を返す関数です。\nもう一つは、zip関数で、これは複数のイテラブルを結合して一つのイテラブルを作る関数です。出来上がったイテラブルは、もとのイテラブルをタプルにしてループインデックスに渡します。したがって、\nfor method,phrase in zip(methods,phrases):\nと書くことによって、第i回目のループでは、methodsの第i要素がmethodに、phrasesの第i要素がphraseに代入されます。\nさて、inspect_tbl関数を、トップレベルの記号表tblに適用してみましょう。\n# %%\ninspect_tbl(tbl)\n# 出力\n\nSymbols in top:\n\n&lt;symbol 'x'&gt; is global: True\n&lt;symbol 'f'&gt; is global: True\n&lt;symbol 'g'&gt; is global: True\n\n&lt;symbol 'x'&gt; is local: True\n&lt;symbol 'f'&gt; is local: True\n&lt;symbol 'g'&gt; is local: True\n\n&lt;symbol 'x'&gt; has table: False\n&lt;symbol 'f'&gt; has table: True\n&lt;symbol 'g'&gt; has table: True\n\n\n\n記号が記号表を持つ場合(つまり関数である場合)、get_namespacesメソッドもしくはget_namespaceメソッドのどちらかで記号表を取得できます。この二つのメソッドの違いは以下の通りです。\n\n\n\nメソッド\n記号表をもつ場合\n記号表を持たない場合\n\n\n\n\nget_namespace\n記号表を返す\nエラーを出す\n\n\nget_namespaces\n記号表のリストを返す\n空のタプルを返す\n\n\n\n従って、エラーへの対処が面倒な場合はget_namespacesのほうが便利です。(なお実際にはほとんど無いと思いますが、一つの名前空間で同じ名前の関数が複数回定義されれば、一つの記号が複数の記号表を持ちます。このような場合、やはりget_namespaceはエラーを出します。)\nいま扱っているtblトップレベル記号表には、fとgという二つの関数を表す記号がありますので、これらの記号表を取得してみましょう。f、gはそれぞれtop_symsリストの第2、3要素であったことに注意してください。\n# %%\nf_tbl = top_syms[1].get_namespace()\ng_tbl = top_syms[2].get_namespace()\nprint(f_tbl)\nprint(g_tbl)\n# 出力\n\n&lt;Function SymbolTable for f in main.py&gt;\n&lt;Function SymbolTable for g in main.py&gt;\n\n\n\nそれではfとgのローカル記号表が取得できましたので、これらをinspect_tblで精査します。まずはfの記号表からです。\n# %%\ninspect_tbl(f_tbl)\n# 出力\n\nSymbols in f:\n\n&lt;symbol 'x'&gt; is global: False\n&lt;symbol 'y'&gt; is global: False\n\n&lt;symbol 'x'&gt; is local: True\n&lt;symbol 'y'&gt; is local: True\n\n&lt;symbol 'x'&gt; has table: False\n&lt;symbol 'y'&gt; has table: False\nこれを見ると分かるように、fの記号表には、記号xとyが存在しますが、どちらもローカル変数で、記号表を持たないことが分かります。\n次にg_tbl記号表を精査しましょう。\n# %%\ninspect_tbl(g_tbl)\n# 出力\n\nSymbols in g:\n\n&lt;symbol 'y'&gt; is global: False\n&lt;symbol 'x'&gt; is global: True\n\n&lt;symbol 'y'&gt; is local: True\n&lt;symbol 'x'&gt; is local: False\n\n&lt;symbol 'y'&gt; has table: False\n&lt;symbol 'x'&gt; has table: False\nこれを見ると分かるように、gのなかで参照はされているが代入はされていない記号xはグローバル変数であることが分かります。一方、yには値が代入されているので、ローカル変数になっています。このように、記号表を用いれば、関数ブロックにおいて、ある記号がどの名前空間を参照しているのかを特定することができます。\n上記のコードのような単純な例だと、記号表の恩恵はあまり感じられないかもしれません。そこで、記号表の役割を実感できる例を、ホームワークで出題することにします。\n最後に、is_localやis_global以外にもSymbol型はたくさんのメソッドを持っていて、名前解決の研究に非常に有用であることを述べておきます。以下、上に用いたメソッドとその他幾つかをまとめておきます。\n\n\n\n\n\n\n\nメソッド\n機能\n\n\n\n\nis_local\n記号がそのブロックで定義されていればTrue\n\n\nis_global\n記号がグローバルならばTrue(ただしトップに定義が無くてもTrueになる)\n\n\nis_referenced\n記号がそのブロックで使われていればTrue\n\n\nis_nonlocal\n記号がnonlocalならTrue\n\n\nis_namespace\n記号が記号テーブルを持つならばTrue\n\n\nget_namespaces\n記号がもつ記号テーブルのリストを返す\n\n\n\n他にもたくさんの興味深いメソッドがありますのでリファレンスマニュアルを参照してください。"
  },
  {
    "objectID": "programming2025/programming-8.html#まとめ",
    "href": "programming2025/programming-8.html#まとめ",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "今回の講義では、以下の点について学びました。\n\n関数\nジェネレータ\n内包表記\nモジュール\n名前空間\nスコープ\nLEGBルール\n記号表\n\n名前空間やスコープはPythonの中核をなす概念なのでしっかり把握しておきましょう。"
  },
  {
    "objectID": "programming2025/programming-8.html#参考書",
    "href": "programming2025/programming-8.html#参考書",
    "title": "第8回　関数とモジュール",
    "section": "",
    "text": "『はじめてのPython』(Mark Lutz著、夏目 大 訳)(2009) オライリージャパン(第3版) ISBN-13: 978-4873113937.\n『CPython Internals: Your Guide to The Python 3 Interpreter』(A. Shaw, The real python.com tutorial team)(2021) Real Python. ISBN-13: 978-1775093343.\nPythonリファレンスマニュアル(symtable)"
  },
  {
    "objectID": "programming2025/programming-3.html",
    "href": "programming2025/programming-3.html",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "第3回 バージョン管理入門\n\nバージョン管理とは\nローカルとリモート\nGitHubアカウントの作成\nEmailアドレスのPrivate設定\nリモート課題レポジトリの作成\nGitの初期設定\nsshの設定\n\n鍵の作成\n秘密鍵の登録\n公開鍵の登録\n\nホストの登録\nローカル課題リポジトリの作成(ダウンロード)\nローカル課題リポジトリの編集\n変更のステージング\n変更のコミット\nリモートをローカルに同期(プッシュ)\nローカルをリモートに同期(プル)\nその他の操作\n主なGitコマンドまとめ\nまとめ\n参考書\n補遺\n\nsshポートの設定\n\n\n\n\n\nプログラミングをしていると、しばしば、以前の状態に戻したいということがあります。これを実現する最も単純な方法は、ときどきファイルにバージョン入りで別名をつけ、別ファイルとして保存しておくことでしょう。\nたとえば、code.pyというソースコードを編集している開発者がいるとします。ある時点で機能が安定したら、さらに機能を追加する前に、開発者はいつでもこのバージョンに戻ってこられるようにするために、code_ver1.pyという別名を付けてバージョン1として保存しておけば良いでしょう。同様に、code_ver2.py、code_ver3.pyというファイルが次々と出来上がっていくでしょう。\n開発期間が短ければ、これでも何とかなるかもしれません。しかし、比較的小さなプロジェクトでも、時間が経つにつれてファイルの数は膨大になるのが普通です。そうすると、どのバージョンがどんな状態だったかすぐに分からなくなります。\nこれを解決するために、開発者は、たとえばエクセルのようなスプレッドシードに、バージョン名とその内容、作成者の氏名、作成日時を記録していくかもしれません。\n\n\n\nversion\n\n\nこれはある種のバージョン管理であると言えます。これに、さらに以下のような機能を追加すればもっと便利でしょう。\n\n関連する複数のファイルのバージョンを一括して管理できる\nバージョン間の親子関係を表示できる\n異なるバージョンの内容を比較できる\n複数人が独立に作業できる\n\nGitはこうした機能を実現する仕組みです。Gitは、Linuxの開発者であるLinus TorvaldsがLinuxの共同開発を進めるために開発したツールです。Gitでは、アプリケーション開発など、一つのプロジェクトに関わる全てのファイルをリポジトリという特別な装置によって管理します。\nリポジトリは、通常、作業ディレクトリとよばれる一つのディレクトリの中に収められた状態で存在し、作業ディレクトリの中にあるファイルの現在の状態や過去のバージョンを管理しています。リポジトリの正体は、作業ディレクトリの中にある.gitという隠しフォルダです。\n\n\n\nrepository\n\n\n\n\n\n一方GitHubはインターネット上にリポジトリを置くためのサービスです。インターネット上のリポジトリをリモートリポジトリと呼びます。\n\n\n\ngit_image\n\n\nリモートリポジトリに対して、開発者のパソコン上に存在するリポジトリをローカルリポジトリと呼びます。GitHubを用いると、複数の開発者が共通のリモートリポジトリを介して共同開発を行うことができます。\nGitを用いると、リモートリポジトリとローカルリポジトリを同期させることができます。リモートリポジトリをローカルと同じ状態に同期させることをプッシュ、その逆をプルと言います。共同開発者は、プルによってローカルの状態を最新にしたあと、自分の担当部分の作業を進め、作業が終わったらプッシュによって作業の結果をリモートにアップロードすることができます。\n\n\n\nおもなGit用語\n意味\n\n\n\n\nプッシュ\nリモートの状態をローカルの状態に同期\n\n\nプル\nローカルの状態をリモートの状態に同期\n\n\nコミット\n作業をリポジトリの履歴に記録する\n\n\n\nGitHubのリモートリポジトリには、プライベートリポジトリとパブリックリポジトリがあります。パブリックリポジトリは誰でも見ることができ、パッケージ公開などに用いられます。一方パブリックリポジトリは自分と共同開発者だけが閲覧できるので、個人的な用途や、グループでの研究開発などに用いられます。\n\n\n\nリポジトリの種類\n書き込み権限\n閲覧権限\n\n\n\n\nプライベート\n自分と共同開発者\n自分と共同開発者\n\n\nパブリック\n自分と共同開発者\n誰でも\n\n\n\n本講義では、課題の提出にGitHub classroomというGitHubの教育用サービスを活用します。GitHubは、課題をリモートリポジトリとして学生に配布する機能を提供します。本講義では、課題リポジトリはプライベートリポジトリにしますので、学生個人と担当教員だけが閲覧できます。\n\n\n\nGitは今すぐにでも使うことができますが、GitHubを利用するには、まずGitHubのサイトでユーザー登録をしてアカウントを作成する必要があります。すでにアカウントをお持ちの方は本節を読み飛ばして構いません。\nインターネットブラウザでGitHubのサイトに行き、画面右上の”Sign up”をクリックします。\n“Create your account”という画面になりますので、以下の項目を入力します。\n\nEmailアドレス(原則として大学のアドレスを入力)\nパスワード(紛失しないよう厳重に管理すること)\nユーザー名\n広告の受け取りの可否(不要ならチェックしない)\n\n\n\n\nsignup2modified.PNG\n\n\nユーザーネームを作成するときは、以下の点にご注意ください。\n\n一度アカウントを作成したらユーザー名は(少なくとも在学中は)変更しないでください。\n長く使うものなので、よく考えて命名してください。\n他人の名前を使わないでください。\n生年月日などの個人情報は含めないでください。\nすべて英数字にしてください。\nアルファベットは小文字にすることをお勧めします。\n途中に連続しないハイフンを使うことができます。\n\nパスワードを決めるときは、以下の点にご注意ください。\n\n全て半角の英数字もしくは記号で構成してください。\n次の条件の少なくともどちらかを満たしてください。\n\n15文字以上。\n8文字以上で数字と小文字アルファベットを両方含む。\n\nパスワードは紛失しないように管理してください。\n\nユーザー名等の入力を終えたら、“Verify your account”の項目でロボットでないことを証明してください。\n\n\n\nsignup3.PNG\n\n\n“Create account”をクリックします。\n\n\n\nsignup4.PNG\n\n\n登録に用いたアドレスに8桁の検証コードが送信されるので、メールボックスを確認してコードを入力してください。\n\n\n\nsignup5modified.PNG\n\n\nこれでアカウントが作成されました。ユーザー名とパスワードを求められますので、入力してください。\n\n\n\nsnapshot.PNG\n\n\n次に”How many…“などパーソナライゼーションのための質問を幾つかされますが、画面下部のskip personalizationをクリックすれば全てスキップできます。\n\n\n\nskip_personalization.PNG\n\n\n\n\n\n\nアカウントを作成したら、Emailの公開設定をします。GitHubにログインして、GitHubのemail設定を開き、Keep my email address privateをONにしてください。これにより、Emailアドレスは非公開になります。Primary email addressの欄に次のように表示されていることを確認してください。\n\nBecause you have email privacy enabled, xxxx@xxxx.xx.xx will be used for account-related notifications as well as password resets. ????????+kouka-taro@users.noreply.github.com will be used for web-based Git operations, e.g., edits and merges.\n\nここで、xxxx@xxxx.xx.xxは大学のメールアドレスで、各種認証やGitHubからの連絡に用いられます。一方、????????+kouka-taro@users.noreply.github.comは、Gitのemailアドレスに設定するためのものです。\nなお、授業では非公開設定を推奨しますが、公開する必要がある場合は自己責任で行ってください。\n\n\n\nGitHub classroomの課題を行うに当たっては、まず課題の招待を受け入れ、自分専用の課題リポジトリをGitHub上に作成する必要があります。Moodleに記載されている「課題0の招待リンク」をクリックしましょう。\n以下のような画面になり、GitHub ClassroomがあなたのGitHubアカウントにアクセスする許可を求めてきますので、Authorize Classroomをクリックして許可します。\n\n\n\ngithub_classroom_permission\n\n\n“Join the classroom”という画面に切り替わりますので、“Identifiers”の一覧から自分の名前を選択します。(万が一自分の名前がない場合はご連絡ください。Moodleにユーザー登録されていない可能性があります。)ここで間違った名前を選択すると、教員による取り消し操作が必要になりますのでご注意ください。\n\n\n\njoin_classroom\n\n\n画面が切り替わりますので、“Accept this assignment”をクリックして課題を受け入れます。\n\n\n\naccept_assignment\n\n\nこれであなた専用の課題のリモートリポジトリが作成されました。リモートリポジトリの名前は、アカウント名がkouka-taroならば、\nassignment-pr21-0-kouka-taro\nのようになっているはずです。 KUT Econ Programming Courseにアクセスして、自分の課題リポジトリが出来ているか確認してください。\n\n\n\n次は、GitHubのアカウント上に作成したリモートのリポジトリをパソコン(ローカル)にダウンロードしましょう。これ以降は、Gitというアプリケーションを使っていくことになります。\n以前作成したGitHubディレクトリを右クリックし、“Git bash here”を選びます。すると、真っ暗なコンソールが開きます。bashというのは元々Linuxのコンソールで用いられているコマンド入力システム(コマンドラインシェルと呼ばれます)であり、Git bashはgitをWindows上で使いやすくするためにWindowsに移植されたWindows版bashです。Gitには色んな操作方法がありますが、Git bashのようなコンソールからコマンドを打ち込んで操作するのが最も基本的な操作方法ですので、ここではそれに従います。(使える機能は限定されていますが、VS Code上でGitの操作を行うこともできます)\nGitは使用前に以下の項目に関する初期設定が必要です。\n\nユーザー名\nEmailアドレス（GitHubのダミーemail）\nエディタにVSCodeを指定する\nsshの設定\n\nユーザー名を設定するには、次のようにコンソールに打ち込みます。注意: Taro Koukaのところは、自分の本名をアルファベット半角で入力してください!また、#記号に続く行は単なる説明なので、入力する必要はありません!\n# ユーザー名設定\ngit config --global user.name \"Taro Kouka\"\nEmailアドレスを設定するには、次のようにコンソールに打ち込みます。注意: ????????+kouka-taro@users.noreply.github.comのところには、githubが作成したダミーのemailアドレスを入力してください!\n# Email設定\ngit config --global user.email ????????+kouka-taro@users.noreply.github.com\nGitでは、「コミット」という操作を行う際にエディタを起動する必要があります。その際に用いるエディタをcodeにしておきましょう。ただし、Gitをインストールする際にVSCodeをエディターに設定した人は、この操作は必要ありませんのでスキップしてください。\n# エディタの設定\ngit config --global core.editor \"code --wait\"\n“–wait”オプションをつけないとうまく動作しないので気を付けてください。\nなお、VS Codeのパスを通していない人は、この設定も必要です。パスが通っているかどうか調べるには、git bash上で、次のように入力してみてください。バージョン番号が出力されれば、パスが通っています。\n# パスの確認\ncode --version\nバージョン番号が出力されずエラーが出る人はパスが通っていませんので、以下のようにしてパスを設定してください。VS Codeのショートカットを右クリックして、プロパティを選択し、「リンク先」に書いてあるパスをユーザー環境変数のPATHに追加します(システム環境変数ではありません)。実行ファイル名”Code.exe”はパスに含めないでください。これによってGitからも起動できるようになります。\n設定がうまく行ったか次のコマンドを入力して調べておきましょう。\n# 設定項目をリストアップ\ngit config --global --list\n出力が次のようになっていれば設定完了です。\nuser.name=Taro Kouka\nuser.email=????????-kouka-taro@users.noreply.github.com\ncore.editor=code --wait\n\n\n\n\n\ngithubはhttpsとsshという２つの方法で接続できますが、ここではssh接続を解説することにします。まず、git bashのコンソールで、次のように入力してください。注意: kouka.taro@*****.ac.jpは、Githubに登録したあなたの真のEmailアドレスに設定します。オプション-Cは大文字なので注意。\nssh-keygen -t rsa -b 4096 -C \"kouka.taro@*****.ac.jp\"\n秘密鍵ファイルの名前やパスフレーズなどを尋ねられますが、今回初めてSSHを使う人は全て空欄のままEnterキーを押して大丈夫です。(SSHを普段から使っていて詳しい人は、適切に設定してください。)合計3回Enterキーを押せば鍵が作られます。\nこれによりホームパスの下の.sshというフォルダの中に秘密鍵と公開鍵が作られます。ホームパスがわからない人は、gitで\necho $HOMEPATH\nもしくはコマンドプロンプトで\necho %HOMEPATH%\nと入力すれば出てきます。\n.sshフォルダの中にあるファイルは次の4つになります。\n\n\n\nファイル名\n機能\n\n\n\n\nid_rsa\n秘密鍵\n\n\nid_rsa.pub\n公開鍵\n\n\nconfig\n設定ファイル\n\n\nknown_hosts\nアクセスを許可する接続先のリスト\n\n\n\nこのうち、id_rsaとid_rsa.pubがすでに存在していれば無事に秘密鍵と公開鍵が作成できています。他のファイルはまだ無いかもしれません。\n\n\n\n鍵をつくったら、秘密鍵をパソコンに登録する必要があります。bashで次のように入力して、ssh-agentを起動してください。\neval \"$(ssh-agent)\"\nPid ...というようにプロセスIDが出力されればOKです。\n次に、秘密鍵の登録は次のように入力してください。\nssh-add ~/.ssh/id_rsa\nこれで秘密鍵がローカルのパソコンに登録されました。秘密鍵を登録するときは、必ず毎回ssh-agentを起動しないと駄目なので注意してください。\n\n\n\n次は、Githubに公開鍵を登録する必要があります。こちらにアクセスして、New SSH keyをクリックしてください。\nTitleは分かりやすい名前なら何でも構いませんが、たとえばclass,university,campusなどといったものにしておけば、どこで作った鍵だったか分かりやすくて良いかと思います。 Keyの欄に、id_rsa.pub(公開鍵)ファイルの中身をまるごとコピー＆ペーストしてください。\nファイルの中身をコピーするには、メモ帳やVS Codeで開いて全て選択してコピーする方法と、コマンドラインからクリップボードに貼り付ける方法があります。\nWindowsの場合、コマンドラインでやるときは、bashのコンソールで\nclip &lt; ~/.ssh/id_rsa.pub\nと入力すればクリップボードに貼り付けられます。一文字でも欠けると接続できませんので、コピー＆ペーストは慎重にしてください。\nTitleとKeyが入力できたら、Add SSH Keyをクリックして登録完了です。\n\n\n\n\nbashにて、\nssh -T git@github.com\nと入力してください。\nThe authenticity of host 'github.com (52.69.186.44)' can't be established.\nRSA key fingerprint is ...\nAre you sure you want to continue connecting (yes/no)? \nと出たら、yesと入力します。これでGitHubがknownhostsファイルに登録されます。そのあと、\nHi kouka-taro! You've successfully authenticated, but ...\nと出たらssh接続成功です。\n\n\n\n基本設定が完了したら、先ほど作成したリモート課題リポジトリをローカルにコピーしましょう。先程の手順で、Githubディレクトリでgit bashを開いてください。課題リポジトリをリモートからローカルにコピーするにはbashコンソールに次のように入力します。\ngit clone git@github.com:kut-econ/assignment-pr21-0-kouka-taro.git\nkouka-taroのところはご自身のGitHubアカウント名にしてください。これによってリモートのリポジトリが、ローカルのGitHubディレクトリ下にコピーされますので、エクスプローラで確認してみましょう。GitHubディレクトリの下に、assignment-…という名前のディレクトリが作成されていれば成功です。\nこのように、リモートリポジトリをローカルにコピーする操作をクローンと呼びますので覚えておきましょう。クローンするコマンドの一般形は次のようになります。\ngit clone repository_url\nrepository_urlはリモートリポジトリのurlです。このurlは、自分のリモート課題リポジトリにインターネットブラウザでアクセスすることにより調べることができます。KUT Econ Programming Courseのサイトで自分のリモート課題リポジトリのリンクを見つけ、クリックしてください。以下のようにリポジトリの内容が表示されます。\n\n\n\nremote_repo\n\n\n右上の緑色の”Code”というボタンから、クローンのためのリポジトリのurlをコピーできます。(sshリンクを選んでください。https接続している人は、httpsリンクで構いません。)\n\n\n\nローカルにリポジトリをクローンできたら、編集してみましょう。一度git bashを閉じてください(exitと入力します)。Windowsエクスプローラでローカルにコピーした課題リポジトリのフォルダを開いてください。以下三つのファイルがあるはずです。\n\nREADME.md\nassignment-text-0.md\nassignment-code-0.py\n\nエクスプローラ上で右クリックして「Codeで開く」を選択し、VS Codeを起動しましょう。上記3つのファイルをVS Codeで開いて内容を確認してみましょう。\nさて、これから、これらのファイルに編集を加えて、リモートリポジトリに変更をアップロードするという作業を行いますが、Gitの挙動を理解するために、慎重におこなってください。\nここでリポジトリの構造を説明しておきます。クローンによって作成されたディレクトリは作業ディレクトリと呼ばれ、リポジトリの本体はその中にあります。実際には、リポジトリの本体は.gitという隠しフォルダとして存在しています。リポジトリは、作業ディレクトリ内のファイルの過去の状態を記録しており、現在の状態と過去の状態を比較したり、作業ディレクトリの内容を過去の状態に戻したりする機能を提供します。この意味で、作業ディレクトリは、リポジトリの管理下にあると表現されることがあります。\nリポジトリの管理下にある作業ディレクトリの内部は、次の三つの領域から構成されています。\n\n作業エリア\nステージングエリア\nコミット履歴\n\n\n\n\nthree_areas\n\n\nWindowsエクスプローラによって閲覧できる作業ディレクトリ内のファイルは、(隠しフォルダ.gitを除き)すべて作業エリア内に存在します。ステージングエリアとコミット履歴は、gitコマンドによってのみ内容を確かめることができます。\n上記のうち、コミット履歴がリポジトリの中核部分であり、過去に記録したファイルの状態を全て収めています。\n一方ステージングエリアは作業エリアとコミット履歴を結ぶ中間的な領域であり、しばしばインデックスと(いう若干分かりにくい名前で)呼ばれることもあるので注意してください。ステージングエリアは、ファイルの変更をコミット履歴に記録するまえに、一時的に待機させる役割を持ちます。\n\n\n\nそれでは、作業エリア内のファイルを修正して、ステージングエリアに入れてみましょう。現在皆さんは、ローカル課題リポジトリの作業ディレクトリの中でVS Codeを起動ている状態にあるかと思います。assignment-0-code.pyを開いて、若干の修正を加えます。\n\n\n\nassignment-0-code-py\n\n\nこれは変数xに1を代入してその値を画面に出力するだけのコードです。x=1の下にy=2という行を挿入してみましょう。\n\n\n\nassignment-0-code-py-modified\n\n\nすると、画面左のサイドバーにある三つ目のボタンが変化して、1というマークがつきます。これは、変更箇所が1箇所存在するということを表します。\n\n\n\ndiff-button\n\n\nこのボタンをクリックしましょう。すると、エクスプローラに変更のあったファイルの一覧が表示されますので、assignment-0-code.pyを選択します。すると、ウィンドウが二つに分かれて、変更前と変更後を比較する画面になります。このように、リポジトリの管理下にある作業ディレクトリで追跡管理されているファイルを変更すると、どこに変化があったのかいつもチェックすることができます。\n\n\n\ndiff\n\n\nそれでは、この変更をステージングエリアに登録しましょう。bashコンソールで次のように入力してみてください。\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   assignment-0-code.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n“Changes not staged for commit”と表示されていますが、これは、「まだステージングされていない変更」という意味です。modified:の行には、変更があったファイル名(assignment-0-code.py)が表示されます。\nステージングするファイルは個別に選択することもできますが、ここでは変更の有ったファイルを全てステージングすることにしましょう。そのためには、次のように入力します。\ngit add -A\nこれでステージング完了です。ためしにgit statusしてみましょう。\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n        modified:   assignment-0-code.py\n上記のように表示が”Changes to be comitted”に変わっています。これは、「ステージングされたけど、まだコミットされていない変更」という意味です。\nこの時点で、assignment-0-code.pyの変更は、作業ディレクトリからステージングエリアに入れられました。この状態では、まだ変更はリポジトリに記録されていません。記録する変更の候補としてノミネートされただけです。ステージングエリアに入れられた変更をリポジトリに記録するには、コミットという作業によって変更をコミット履歴に登録する必要があります。\nステージングエリアに入ったがまだコミットされていない変更は次のようにリセット(アンステージ)することができます。\n$ git reset\nUnstaged changes after reset:\nM       assignment-0-code.py\nためしにgit statusして、状態がもとに戻っていることを確認してください。確認をおえたら、もう一度git add -Aによりステージングしておきましょう。\nなお、新しく作成したファイルは、作業エリア内にのみ存在しますが、一度もステージングしていないと、リポジトリはこのファイルに関する記録を何も持たないことになります(それが存在するということを除いて)。従って、新規ファイルはステージングして初めて内容の変更を追跡管理されることを覚えておいてください。\n\n\n\nステージングエリアに入れた変更をリポジトリに記録するには、コミットする必要があります。コミットには、常に1行以上のメッセージを付ける必要があります。1行だけのメッセージをつけるときは、次のようにします。\n$ git commit -m \"My first commit\"\n[master c70dbc9] My first commit\n 1 file changed, 1 insertion(+)\nここで”My first commit”がメッセージです。メッセージは、後からコミット履歴を調べたときに、個々のコミットが何のためのコミットであったか分かりやすくするためのものです。\nでは状態がどのように変化したか、git statusで調べてみましょう。\n$ git status\nOn branch master\nnothing to commit, working tree clean\n“nothing to commit”、つまり、コミットすべきものはもう何もない、と表示されています。これにより、ステージングエリア、コミット履歴が全て最新の状態、すなわち作業スペースと同じ状態になったことが分かります。\nコミットを取り消してコミット前(ステージングした状態)に戻すには、次のようにします。\n$ git reset --soft HEAD^\nUnstaged changes after reset:\nM       assignment-0-code.py\nここで”–soft”は、「コミット履歴だけ戻すけど、ステージングエリアまでは元にもどさない」という意味です。HEAD^は大雑把に言うと「現在地点より一つ前」という意味です。ステージングエリアも元に戻したい場合はさらにgit resetすれば良いでしょう。\nそれではせっかくもとに戻したので、別の方法でコミットしてみます。メッセージなしでgit commitしてみてください。\ngit commit\nすると、(Gitの初期設定とVS Codeのパス設定を正しくしていれば)VS Codeが起動して、コミットメッセージの入力を求められます。この状態では、複数行のメッセージをつけることができます。\n\n\n\ncommit-message\n\n\nその際、最初の1行にはシンプルなメッセージを書き、1行あけてより詳しいメッセージを書くようにしてください。\n\n\n\ncommit-code\n\n\nメッセージを書き終わったら、保存してVS Codeを終了すると、bashに戻ります。git statusしてコミット履歴とステージングエリアがともに最新になっているか確かめておいてください。\nなお、「面倒くさいのでステージングとコミットをまとめてやってしまいたい」という場合は、次のようにします。\ngit commit -a\n同様に、1行メッセージで済ませるときは、\ngit commit -a -m \"My message\"\nです。\n\n\n\nリポジトリの変更をコミットしたら、次はこれをリモートリポジトリにアップロードして課題提出完了となります。この作業をプッシュといいます。言い変えると、リモートの状態をローカルに同期させる作業ということになります。\nプッシュする前に、次のコマンドを実行しておくと便利です。\n$ git branch --set-upstream-to=origin/master\nBranch 'master' set up to track remote branch 'master' from 'origin'.\nこのコマンドを正確に説明するのは難しいですが、ごく大雑把にいうとoriginはリモートリポジトリを、masterはリモートの最新のコミットを表します。上記のコマンドは、(大雑把に言うと)「このリポジトリは、リモートリポジトリoriginのmasterと繋げてくださいね」といった意味合いになります。ちょっと不正確ですが、正しく説明しようとするとブランチの概念が必要になってきます(本講義ではブランチを詳しく説明することはしません)。\norigin/masterを上流ブランチといいます。上流ブランチが正しく設定されているかを確認するには、次のようにします。\n$ git status -sb\n## master...origin/master\n上記のように## master...origin/masterと出ていれば成功です。\nプッシュは次のコマンドでおこないます。\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 379 bytes | 379.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/kut-econ/assignment-pr21-0-kouka-taro.git\n   cb907d6..16ae7e9  master -&gt; master\nなお”–set-upstream-to”の設定を行わなかった場合は、代わりに\ngit push origin master\nもしくは\ngit push -u origin master\nと入力する必要があります。前者は上流ブランチの設定をしませんが、後者はpushと同時に上流ブランチをorigin/masterに設定します。\nプッシュの際にパスワードを尋ねられた場合は、GitHubのパスワードを入力してください。\n上記で、originはリモートリポジトリを表します。masterはリモートリポジトリの最新のコミットを表します。“git push origin master”は、リモートリポジトリ(origin)に保存されている最新のコミット(master)に、ローカルリポジトリの最新版をプッシュして上乗せ更新せよ、という意味になります。\nプッシュが完了すれば、課題提出成功となります。ちゃんとプッシュできたか確認するには、GitHubのサイトで確認するのが最も確実です。全ての課題リポジトリが保存されているKUT Econ Programming Courseのサイトにアクセスして、目当ての課題リポジトリ名を見つけましょう。課題リポジトリ名をクリックすると、リモートの中身を閲覧できますので、ちゃんとプッシュが成功しているか確かめておいてください。\n\n\n\n2台以上のパソコン(たとえば家と大学など)で同じ課題を行う場合、両方のパソコンで同じリモートリポジトリをクローンし、2台の作業を同期させたい場合があります。そのためには、プッシュするだけではなく、ローカルの状態をリモートの状態に同期させる逆の作業が必要になります。これをプルといいます。\n\n\n\npull\n\n\n2台目に初めてローカルリポジトリを作る時は、単にクローンすれば良いだけです。そのあとは、リモートに変更があるたびに、プルして同期します。プルは非常に簡単で、次のように入力するだけです。\ngit fetch\ngit pull\nこれだけです。fetchはリモートの状態を確かめるコマンドです。git fetchのあとにgit statusすれば、ローカルが何コミット分遅れているかが表示されますので、確かにローカルの方がリモートより遅れていることを確認しましょう。\n確かにリモートのほうが新しければ、git pullによってローカルをリモートに同期させることができます。\n\n\n\n次は、Gitのさらに発展的な操作について学んでいきましょう。次のパブリックリポジトリをGitHubディレクトリの下にクローンしてください。\npractice-pr21-0\nここから先は、VS CodeでリポジトリのREADMEを読んでください。\n\n\n\n最後に主要なGitコマンドをリストアップしておきましょう。\n\n\n\n\n\n\n\nコマンド\n用途\n\n\n\n\ngit clone\nリモートリポジトリをローカルにコピー\n\n\ngit status\nリポジトリの状態をチェック\n\n\ngit add -A\n作業エリアの変更をすべてステージ\n\n\ngit add filename\nファイルfilenameの変更をステージ\n\n\ngit commit -m \"Message\"\nメッセージ”Message”をつけてコミット\n\n\ngit commit\nコミット(メッセージはエディタで入力)\n\n\ngit branch --set-upstream-to=origin/master\nローカルと同期させるリモートを設定\n\n\ngit push\nリモートをローカルに同期\n\n\ngit pull\nローカルをリモートに同期\n\n\ngit reset\nステージングエリアをコミットせずに破棄\n\n\ngit reset --hard HEAD\n作業エリアとステージングエリアをコミットせずに共に破棄\n\n\ngit reset --soft HEAD^\nコミット履歴だけ一つ前に戻す\n\n\ngit reset --mixed HEAD^\nコミット履歴を一つ前に戻してステージングエリアもそれに合わせる\n\n\ngit reset --hard HEAD^\nコミット履歴を一つ前に戻して作業エリアとステージングエリアもそれに合わせる\n\n\ngit log\nコミット履歴を閲覧する\n\n\n\nGitには便利なコマンドが無数に存在しますので、インターネット等で調べ、少しずつGitの構造を理解していきましょう。\n\n\n\n本講義では、以下のことを学びました。\n\nバージョン管理の意義\nGitHubの登録\nリポジトリの操作\n\nクローン\nステージング\nコミット\nプッシュ\nプル\n各種リセット\n\n\n今回の講義では、課題を提出するために必要最低限のGitコマンドだけ学びました。本格的な開発にGitを使うためには、参考書を手に入れてより深く学ぶことをお勧めします(『独習Git』がお勧めです)。\n\n\n\n\n『1日で基本が身に付く!Git超入門』 (リブロワークス著) (2020) 技術評論社. ISBN-13 : 978-4297114404.\n『独習Git』 (Rick Umali著、吉川邦夫 訳) (2016) 翔泳社. ISBN-13 : 978-4798144610.\n\n\n\n\n\n\n\n\n大学の有線LANに繋がっているパソコンの場合は、sshのポートを正しく設定する必要があります。ただし、コンピュータールームのパソコンは、講義の中で自動プログラムにより設定を行ないますので、本項目の作業は不必要です。\n.sshフォルダの中に、configという名前のテキストファイルを作って、中に次のように記述して保存してください(コピペして整形し、プロキシの情報を正しく編集してください)。\nHost github.com\n  User git\n  HostName ssh.github.com\n  Port 443\n  IdentityFile ~/.ssh/id_rsa\n  ProxyCommand connect -H http://proxy.addr:0000 %h %p\nここで、http://proxy.addr:0000は適切なプロキシサーバーのアドレスとポート番号です。"
  },
  {
    "objectID": "programming2025/programming-3.html#バージョン管理とは",
    "href": "programming2025/programming-3.html#バージョン管理とは",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "プログラミングをしていると、しばしば、以前の状態に戻したいということがあります。これを実現する最も単純な方法は、ときどきファイルにバージョン入りで別名をつけ、別ファイルとして保存しておくことでしょう。\nたとえば、code.pyというソースコードを編集している開発者がいるとします。ある時点で機能が安定したら、さらに機能を追加する前に、開発者はいつでもこのバージョンに戻ってこられるようにするために、code_ver1.pyという別名を付けてバージョン1として保存しておけば良いでしょう。同様に、code_ver2.py、code_ver3.pyというファイルが次々と出来上がっていくでしょう。\n開発期間が短ければ、これでも何とかなるかもしれません。しかし、比較的小さなプロジェクトでも、時間が経つにつれてファイルの数は膨大になるのが普通です。そうすると、どのバージョンがどんな状態だったかすぐに分からなくなります。\nこれを解決するために、開発者は、たとえばエクセルのようなスプレッドシードに、バージョン名とその内容、作成者の氏名、作成日時を記録していくかもしれません。\n\n\n\nversion\n\n\nこれはある種のバージョン管理であると言えます。これに、さらに以下のような機能を追加すればもっと便利でしょう。\n\n関連する複数のファイルのバージョンを一括して管理できる\nバージョン間の親子関係を表示できる\n異なるバージョンの内容を比較できる\n複数人が独立に作業できる\n\nGitはこうした機能を実現する仕組みです。Gitは、Linuxの開発者であるLinus TorvaldsがLinuxの共同開発を進めるために開発したツールです。Gitでは、アプリケーション開発など、一つのプロジェクトに関わる全てのファイルをリポジトリという特別な装置によって管理します。\nリポジトリは、通常、作業ディレクトリとよばれる一つのディレクトリの中に収められた状態で存在し、作業ディレクトリの中にあるファイルの現在の状態や過去のバージョンを管理しています。リポジトリの正体は、作業ディレクトリの中にある.gitという隠しフォルダです。\n\n\n\nrepository"
  },
  {
    "objectID": "programming2025/programming-3.html#ローカルとリモート",
    "href": "programming2025/programming-3.html#ローカルとリモート",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "一方GitHubはインターネット上にリポジトリを置くためのサービスです。インターネット上のリポジトリをリモートリポジトリと呼びます。\n\n\n\ngit_image\n\n\nリモートリポジトリに対して、開発者のパソコン上に存在するリポジトリをローカルリポジトリと呼びます。GitHubを用いると、複数の開発者が共通のリモートリポジトリを介して共同開発を行うことができます。\nGitを用いると、リモートリポジトリとローカルリポジトリを同期させることができます。リモートリポジトリをローカルと同じ状態に同期させることをプッシュ、その逆をプルと言います。共同開発者は、プルによってローカルの状態を最新にしたあと、自分の担当部分の作業を進め、作業が終わったらプッシュによって作業の結果をリモートにアップロードすることができます。\n\n\n\nおもなGit用語\n意味\n\n\n\n\nプッシュ\nリモートの状態をローカルの状態に同期\n\n\nプル\nローカルの状態をリモートの状態に同期\n\n\nコミット\n作業をリポジトリの履歴に記録する\n\n\n\nGitHubのリモートリポジトリには、プライベートリポジトリとパブリックリポジトリがあります。パブリックリポジトリは誰でも見ることができ、パッケージ公開などに用いられます。一方パブリックリポジトリは自分と共同開発者だけが閲覧できるので、個人的な用途や、グループでの研究開発などに用いられます。\n\n\n\nリポジトリの種類\n書き込み権限\n閲覧権限\n\n\n\n\nプライベート\n自分と共同開発者\n自分と共同開発者\n\n\nパブリック\n自分と共同開発者\n誰でも\n\n\n\n本講義では、課題の提出にGitHub classroomというGitHubの教育用サービスを活用します。GitHubは、課題をリモートリポジトリとして学生に配布する機能を提供します。本講義では、課題リポジトリはプライベートリポジトリにしますので、学生個人と担当教員だけが閲覧できます。"
  },
  {
    "objectID": "programming2025/programming-3.html#githubアカウントの作成",
    "href": "programming2025/programming-3.html#githubアカウントの作成",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "Gitは今すぐにでも使うことができますが、GitHubを利用するには、まずGitHubのサイトでユーザー登録をしてアカウントを作成する必要があります。すでにアカウントをお持ちの方は本節を読み飛ばして構いません。\nインターネットブラウザでGitHubのサイトに行き、画面右上の”Sign up”をクリックします。\n“Create your account”という画面になりますので、以下の項目を入力します。\n\nEmailアドレス(原則として大学のアドレスを入力)\nパスワード(紛失しないよう厳重に管理すること)\nユーザー名\n広告の受け取りの可否(不要ならチェックしない)\n\n\n\n\nsignup2modified.PNG\n\n\nユーザーネームを作成するときは、以下の点にご注意ください。\n\n一度アカウントを作成したらユーザー名は(少なくとも在学中は)変更しないでください。\n長く使うものなので、よく考えて命名してください。\n他人の名前を使わないでください。\n生年月日などの個人情報は含めないでください。\nすべて英数字にしてください。\nアルファベットは小文字にすることをお勧めします。\n途中に連続しないハイフンを使うことができます。\n\nパスワードを決めるときは、以下の点にご注意ください。\n\n全て半角の英数字もしくは記号で構成してください。\n次の条件の少なくともどちらかを満たしてください。\n\n15文字以上。\n8文字以上で数字と小文字アルファベットを両方含む。\n\nパスワードは紛失しないように管理してください。\n\nユーザー名等の入力を終えたら、“Verify your account”の項目でロボットでないことを証明してください。\n\n\n\nsignup3.PNG\n\n\n“Create account”をクリックします。\n\n\n\nsignup4.PNG\n\n\n登録に用いたアドレスに8桁の検証コードが送信されるので、メールボックスを確認してコードを入力してください。\n\n\n\nsignup5modified.PNG\n\n\nこれでアカウントが作成されました。ユーザー名とパスワードを求められますので、入力してください。\n\n\n\nsnapshot.PNG\n\n\n次に”How many…“などパーソナライゼーションのための質問を幾つかされますが、画面下部のskip personalizationをクリックすれば全てスキップできます。\n\n\n\nskip_personalization.PNG"
  },
  {
    "objectID": "programming2025/programming-3.html#emailアドレスのprivate設定",
    "href": "programming2025/programming-3.html#emailアドレスのprivate設定",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "アカウントを作成したら、Emailの公開設定をします。GitHubにログインして、GitHubのemail設定を開き、Keep my email address privateをONにしてください。これにより、Emailアドレスは非公開になります。Primary email addressの欄に次のように表示されていることを確認してください。\n\nBecause you have email privacy enabled, xxxx@xxxx.xx.xx will be used for account-related notifications as well as password resets. ????????+kouka-taro@users.noreply.github.com will be used for web-based Git operations, e.g., edits and merges.\n\nここで、xxxx@xxxx.xx.xxは大学のメールアドレスで、各種認証やGitHubからの連絡に用いられます。一方、????????+kouka-taro@users.noreply.github.comは、Gitのemailアドレスに設定するためのものです。\nなお、授業では非公開設定を推奨しますが、公開する必要がある場合は自己責任で行ってください。"
  },
  {
    "objectID": "programming2025/programming-3.html#リモート課題レポジトリの作成",
    "href": "programming2025/programming-3.html#リモート課題レポジトリの作成",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "GitHub classroomの課題を行うに当たっては、まず課題の招待を受け入れ、自分専用の課題リポジトリをGitHub上に作成する必要があります。Moodleに記載されている「課題0の招待リンク」をクリックしましょう。\n以下のような画面になり、GitHub ClassroomがあなたのGitHubアカウントにアクセスする許可を求めてきますので、Authorize Classroomをクリックして許可します。\n\n\n\ngithub_classroom_permission\n\n\n“Join the classroom”という画面に切り替わりますので、“Identifiers”の一覧から自分の名前を選択します。(万が一自分の名前がない場合はご連絡ください。Moodleにユーザー登録されていない可能性があります。)ここで間違った名前を選択すると、教員による取り消し操作が必要になりますのでご注意ください。\n\n\n\njoin_classroom\n\n\n画面が切り替わりますので、“Accept this assignment”をクリックして課題を受け入れます。\n\n\n\naccept_assignment\n\n\nこれであなた専用の課題のリモートリポジトリが作成されました。リモートリポジトリの名前は、アカウント名がkouka-taroならば、\nassignment-pr21-0-kouka-taro\nのようになっているはずです。 KUT Econ Programming Courseにアクセスして、自分の課題リポジトリが出来ているか確認してください。"
  },
  {
    "objectID": "programming2025/programming-3.html#gitの初期設定",
    "href": "programming2025/programming-3.html#gitの初期設定",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "次は、GitHubのアカウント上に作成したリモートのリポジトリをパソコン(ローカル)にダウンロードしましょう。これ以降は、Gitというアプリケーションを使っていくことになります。\n以前作成したGitHubディレクトリを右クリックし、“Git bash here”を選びます。すると、真っ暗なコンソールが開きます。bashというのは元々Linuxのコンソールで用いられているコマンド入力システム(コマンドラインシェルと呼ばれます)であり、Git bashはgitをWindows上で使いやすくするためにWindowsに移植されたWindows版bashです。Gitには色んな操作方法がありますが、Git bashのようなコンソールからコマンドを打ち込んで操作するのが最も基本的な操作方法ですので、ここではそれに従います。(使える機能は限定されていますが、VS Code上でGitの操作を行うこともできます)\nGitは使用前に以下の項目に関する初期設定が必要です。\n\nユーザー名\nEmailアドレス（GitHubのダミーemail）\nエディタにVSCodeを指定する\nsshの設定\n\nユーザー名を設定するには、次のようにコンソールに打ち込みます。注意: Taro Koukaのところは、自分の本名をアルファベット半角で入力してください!また、#記号に続く行は単なる説明なので、入力する必要はありません!\n# ユーザー名設定\ngit config --global user.name \"Taro Kouka\"\nEmailアドレスを設定するには、次のようにコンソールに打ち込みます。注意: ????????+kouka-taro@users.noreply.github.comのところには、githubが作成したダミーのemailアドレスを入力してください!\n# Email設定\ngit config --global user.email ????????+kouka-taro@users.noreply.github.com\nGitでは、「コミット」という操作を行う際にエディタを起動する必要があります。その際に用いるエディタをcodeにしておきましょう。ただし、Gitをインストールする際にVSCodeをエディターに設定した人は、この操作は必要ありませんのでスキップしてください。\n# エディタの設定\ngit config --global core.editor \"code --wait\"\n“–wait”オプションをつけないとうまく動作しないので気を付けてください。\nなお、VS Codeのパスを通していない人は、この設定も必要です。パスが通っているかどうか調べるには、git bash上で、次のように入力してみてください。バージョン番号が出力されれば、パスが通っています。\n# パスの確認\ncode --version\nバージョン番号が出力されずエラーが出る人はパスが通っていませんので、以下のようにしてパスを設定してください。VS Codeのショートカットを右クリックして、プロパティを選択し、「リンク先」に書いてあるパスをユーザー環境変数のPATHに追加します(システム環境変数ではありません)。実行ファイル名”Code.exe”はパスに含めないでください。これによってGitからも起動できるようになります。\n設定がうまく行ったか次のコマンドを入力して調べておきましょう。\n# 設定項目をリストアップ\ngit config --global --list\n出力が次のようになっていれば設定完了です。\nuser.name=Taro Kouka\nuser.email=????????-kouka-taro@users.noreply.github.com\ncore.editor=code --wait"
  },
  {
    "objectID": "programming2025/programming-3.html#sshの設定",
    "href": "programming2025/programming-3.html#sshの設定",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "githubはhttpsとsshという２つの方法で接続できますが、ここではssh接続を解説することにします。まず、git bashのコンソールで、次のように入力してください。注意: kouka.taro@*****.ac.jpは、Githubに登録したあなたの真のEmailアドレスに設定します。オプション-Cは大文字なので注意。\nssh-keygen -t rsa -b 4096 -C \"kouka.taro@*****.ac.jp\"\n秘密鍵ファイルの名前やパスフレーズなどを尋ねられますが、今回初めてSSHを使う人は全て空欄のままEnterキーを押して大丈夫です。(SSHを普段から使っていて詳しい人は、適切に設定してください。)合計3回Enterキーを押せば鍵が作られます。\nこれによりホームパスの下の.sshというフォルダの中に秘密鍵と公開鍵が作られます。ホームパスがわからない人は、gitで\necho $HOMEPATH\nもしくはコマンドプロンプトで\necho %HOMEPATH%\nと入力すれば出てきます。\n.sshフォルダの中にあるファイルは次の4つになります。\n\n\n\nファイル名\n機能\n\n\n\n\nid_rsa\n秘密鍵\n\n\nid_rsa.pub\n公開鍵\n\n\nconfig\n設定ファイル\n\n\nknown_hosts\nアクセスを許可する接続先のリスト\n\n\n\nこのうち、id_rsaとid_rsa.pubがすでに存在していれば無事に秘密鍵と公開鍵が作成できています。他のファイルはまだ無いかもしれません。\n\n\n\n鍵をつくったら、秘密鍵をパソコンに登録する必要があります。bashで次のように入力して、ssh-agentを起動してください。\neval \"$(ssh-agent)\"\nPid ...というようにプロセスIDが出力されればOKです。\n次に、秘密鍵の登録は次のように入力してください。\nssh-add ~/.ssh/id_rsa\nこれで秘密鍵がローカルのパソコンに登録されました。秘密鍵を登録するときは、必ず毎回ssh-agentを起動しないと駄目なので注意してください。\n\n\n\n次は、Githubに公開鍵を登録する必要があります。こちらにアクセスして、New SSH keyをクリックしてください。\nTitleは分かりやすい名前なら何でも構いませんが、たとえばclass,university,campusなどといったものにしておけば、どこで作った鍵だったか分かりやすくて良いかと思います。 Keyの欄に、id_rsa.pub(公開鍵)ファイルの中身をまるごとコピー＆ペーストしてください。\nファイルの中身をコピーするには、メモ帳やVS Codeで開いて全て選択してコピーする方法と、コマンドラインからクリップボードに貼り付ける方法があります。\nWindowsの場合、コマンドラインでやるときは、bashのコンソールで\nclip &lt; ~/.ssh/id_rsa.pub\nと入力すればクリップボードに貼り付けられます。一文字でも欠けると接続できませんので、コピー＆ペーストは慎重にしてください。\nTitleとKeyが入力できたら、Add SSH Keyをクリックして登録完了です。"
  },
  {
    "objectID": "programming2025/programming-3.html#ホストの登録",
    "href": "programming2025/programming-3.html#ホストの登録",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "bashにて、\nssh -T git@github.com\nと入力してください。\nThe authenticity of host 'github.com (52.69.186.44)' can't be established.\nRSA key fingerprint is ...\nAre you sure you want to continue connecting (yes/no)? \nと出たら、yesと入力します。これでGitHubがknownhostsファイルに登録されます。そのあと、\nHi kouka-taro! You've successfully authenticated, but ...\nと出たらssh接続成功です。"
  },
  {
    "objectID": "programming2025/programming-3.html#ローカル課題リポジトリの作成ダウンロード",
    "href": "programming2025/programming-3.html#ローカル課題リポジトリの作成ダウンロード",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "基本設定が完了したら、先ほど作成したリモート課題リポジトリをローカルにコピーしましょう。先程の手順で、Githubディレクトリでgit bashを開いてください。課題リポジトリをリモートからローカルにコピーするにはbashコンソールに次のように入力します。\ngit clone git@github.com:kut-econ/assignment-pr21-0-kouka-taro.git\nkouka-taroのところはご自身のGitHubアカウント名にしてください。これによってリモートのリポジトリが、ローカルのGitHubディレクトリ下にコピーされますので、エクスプローラで確認してみましょう。GitHubディレクトリの下に、assignment-…という名前のディレクトリが作成されていれば成功です。\nこのように、リモートリポジトリをローカルにコピーする操作をクローンと呼びますので覚えておきましょう。クローンするコマンドの一般形は次のようになります。\ngit clone repository_url\nrepository_urlはリモートリポジトリのurlです。このurlは、自分のリモート課題リポジトリにインターネットブラウザでアクセスすることにより調べることができます。KUT Econ Programming Courseのサイトで自分のリモート課題リポジトリのリンクを見つけ、クリックしてください。以下のようにリポジトリの内容が表示されます。\n\n\n\nremote_repo\n\n\n右上の緑色の”Code”というボタンから、クローンのためのリポジトリのurlをコピーできます。(sshリンクを選んでください。https接続している人は、httpsリンクで構いません。)"
  },
  {
    "objectID": "programming2025/programming-3.html#ローカル課題リポジトリの編集",
    "href": "programming2025/programming-3.html#ローカル課題リポジトリの編集",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "ローカルにリポジトリをクローンできたら、編集してみましょう。一度git bashを閉じてください(exitと入力します)。Windowsエクスプローラでローカルにコピーした課題リポジトリのフォルダを開いてください。以下三つのファイルがあるはずです。\n\nREADME.md\nassignment-text-0.md\nassignment-code-0.py\n\nエクスプローラ上で右クリックして「Codeで開く」を選択し、VS Codeを起動しましょう。上記3つのファイルをVS Codeで開いて内容を確認してみましょう。\nさて、これから、これらのファイルに編集を加えて、リモートリポジトリに変更をアップロードするという作業を行いますが、Gitの挙動を理解するために、慎重におこなってください。\nここでリポジトリの構造を説明しておきます。クローンによって作成されたディレクトリは作業ディレクトリと呼ばれ、リポジトリの本体はその中にあります。実際には、リポジトリの本体は.gitという隠しフォルダとして存在しています。リポジトリは、作業ディレクトリ内のファイルの過去の状態を記録しており、現在の状態と過去の状態を比較したり、作業ディレクトリの内容を過去の状態に戻したりする機能を提供します。この意味で、作業ディレクトリは、リポジトリの管理下にあると表現されることがあります。\nリポジトリの管理下にある作業ディレクトリの内部は、次の三つの領域から構成されています。\n\n作業エリア\nステージングエリア\nコミット履歴\n\n\n\n\nthree_areas\n\n\nWindowsエクスプローラによって閲覧できる作業ディレクトリ内のファイルは、(隠しフォルダ.gitを除き)すべて作業エリア内に存在します。ステージングエリアとコミット履歴は、gitコマンドによってのみ内容を確かめることができます。\n上記のうち、コミット履歴がリポジトリの中核部分であり、過去に記録したファイルの状態を全て収めています。\n一方ステージングエリアは作業エリアとコミット履歴を結ぶ中間的な領域であり、しばしばインデックスと(いう若干分かりにくい名前で)呼ばれることもあるので注意してください。ステージングエリアは、ファイルの変更をコミット履歴に記録するまえに、一時的に待機させる役割を持ちます。"
  },
  {
    "objectID": "programming2025/programming-3.html#変更のステージング",
    "href": "programming2025/programming-3.html#変更のステージング",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "それでは、作業エリア内のファイルを修正して、ステージングエリアに入れてみましょう。現在皆さんは、ローカル課題リポジトリの作業ディレクトリの中でVS Codeを起動ている状態にあるかと思います。assignment-0-code.pyを開いて、若干の修正を加えます。\n\n\n\nassignment-0-code-py\n\n\nこれは変数xに1を代入してその値を画面に出力するだけのコードです。x=1の下にy=2という行を挿入してみましょう。\n\n\n\nassignment-0-code-py-modified\n\n\nすると、画面左のサイドバーにある三つ目のボタンが変化して、1というマークがつきます。これは、変更箇所が1箇所存在するということを表します。\n\n\n\ndiff-button\n\n\nこのボタンをクリックしましょう。すると、エクスプローラに変更のあったファイルの一覧が表示されますので、assignment-0-code.pyを選択します。すると、ウィンドウが二つに分かれて、変更前と変更後を比較する画面になります。このように、リポジトリの管理下にある作業ディレクトリで追跡管理されているファイルを変更すると、どこに変化があったのかいつもチェックすることができます。\n\n\n\ndiff\n\n\nそれでは、この変更をステージングエリアに登録しましょう。bashコンソールで次のように入力してみてください。\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   assignment-0-code.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n“Changes not staged for commit”と表示されていますが、これは、「まだステージングされていない変更」という意味です。modified:の行には、変更があったファイル名(assignment-0-code.py)が表示されます。\nステージングするファイルは個別に選択することもできますが、ここでは変更の有ったファイルを全てステージングすることにしましょう。そのためには、次のように入力します。\ngit add -A\nこれでステージング完了です。ためしにgit statusしてみましょう。\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n        modified:   assignment-0-code.py\n上記のように表示が”Changes to be comitted”に変わっています。これは、「ステージングされたけど、まだコミットされていない変更」という意味です。\nこの時点で、assignment-0-code.pyの変更は、作業ディレクトリからステージングエリアに入れられました。この状態では、まだ変更はリポジトリに記録されていません。記録する変更の候補としてノミネートされただけです。ステージングエリアに入れられた変更をリポジトリに記録するには、コミットという作業によって変更をコミット履歴に登録する必要があります。\nステージングエリアに入ったがまだコミットされていない変更は次のようにリセット(アンステージ)することができます。\n$ git reset\nUnstaged changes after reset:\nM       assignment-0-code.py\nためしにgit statusして、状態がもとに戻っていることを確認してください。確認をおえたら、もう一度git add -Aによりステージングしておきましょう。\nなお、新しく作成したファイルは、作業エリア内にのみ存在しますが、一度もステージングしていないと、リポジトリはこのファイルに関する記録を何も持たないことになります(それが存在するということを除いて)。従って、新規ファイルはステージングして初めて内容の変更を追跡管理されることを覚えておいてください。"
  },
  {
    "objectID": "programming2025/programming-3.html#変更のコミット",
    "href": "programming2025/programming-3.html#変更のコミット",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "ステージングエリアに入れた変更をリポジトリに記録するには、コミットする必要があります。コミットには、常に1行以上のメッセージを付ける必要があります。1行だけのメッセージをつけるときは、次のようにします。\n$ git commit -m \"My first commit\"\n[master c70dbc9] My first commit\n 1 file changed, 1 insertion(+)\nここで”My first commit”がメッセージです。メッセージは、後からコミット履歴を調べたときに、個々のコミットが何のためのコミットであったか分かりやすくするためのものです。\nでは状態がどのように変化したか、git statusで調べてみましょう。\n$ git status\nOn branch master\nnothing to commit, working tree clean\n“nothing to commit”、つまり、コミットすべきものはもう何もない、と表示されています。これにより、ステージングエリア、コミット履歴が全て最新の状態、すなわち作業スペースと同じ状態になったことが分かります。\nコミットを取り消してコミット前(ステージングした状態)に戻すには、次のようにします。\n$ git reset --soft HEAD^\nUnstaged changes after reset:\nM       assignment-0-code.py\nここで”–soft”は、「コミット履歴だけ戻すけど、ステージングエリアまでは元にもどさない」という意味です。HEAD^は大雑把に言うと「現在地点より一つ前」という意味です。ステージングエリアも元に戻したい場合はさらにgit resetすれば良いでしょう。\nそれではせっかくもとに戻したので、別の方法でコミットしてみます。メッセージなしでgit commitしてみてください。\ngit commit\nすると、(Gitの初期設定とVS Codeのパス設定を正しくしていれば)VS Codeが起動して、コミットメッセージの入力を求められます。この状態では、複数行のメッセージをつけることができます。\n\n\n\ncommit-message\n\n\nその際、最初の1行にはシンプルなメッセージを書き、1行あけてより詳しいメッセージを書くようにしてください。\n\n\n\ncommit-code\n\n\nメッセージを書き終わったら、保存してVS Codeを終了すると、bashに戻ります。git statusしてコミット履歴とステージングエリアがともに最新になっているか確かめておいてください。\nなお、「面倒くさいのでステージングとコミットをまとめてやってしまいたい」という場合は、次のようにします。\ngit commit -a\n同様に、1行メッセージで済ませるときは、\ngit commit -a -m \"My message\"\nです。"
  },
  {
    "objectID": "programming2025/programming-3.html#リモートをローカルに同期プッシュ",
    "href": "programming2025/programming-3.html#リモートをローカルに同期プッシュ",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "リポジトリの変更をコミットしたら、次はこれをリモートリポジトリにアップロードして課題提出完了となります。この作業をプッシュといいます。言い変えると、リモートの状態をローカルに同期させる作業ということになります。\nプッシュする前に、次のコマンドを実行しておくと便利です。\n$ git branch --set-upstream-to=origin/master\nBranch 'master' set up to track remote branch 'master' from 'origin'.\nこのコマンドを正確に説明するのは難しいですが、ごく大雑把にいうとoriginはリモートリポジトリを、masterはリモートの最新のコミットを表します。上記のコマンドは、(大雑把に言うと)「このリポジトリは、リモートリポジトリoriginのmasterと繋げてくださいね」といった意味合いになります。ちょっと不正確ですが、正しく説明しようとするとブランチの概念が必要になってきます(本講義ではブランチを詳しく説明することはしません)。\norigin/masterを上流ブランチといいます。上流ブランチが正しく設定されているかを確認するには、次のようにします。\n$ git status -sb\n## master...origin/master\n上記のように## master...origin/masterと出ていれば成功です。\nプッシュは次のコマンドでおこないます。\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 379 bytes | 379.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/kut-econ/assignment-pr21-0-kouka-taro.git\n   cb907d6..16ae7e9  master -&gt; master\nなお”–set-upstream-to”の設定を行わなかった場合は、代わりに\ngit push origin master\nもしくは\ngit push -u origin master\nと入力する必要があります。前者は上流ブランチの設定をしませんが、後者はpushと同時に上流ブランチをorigin/masterに設定します。\nプッシュの際にパスワードを尋ねられた場合は、GitHubのパスワードを入力してください。\n上記で、originはリモートリポジトリを表します。masterはリモートリポジトリの最新のコミットを表します。“git push origin master”は、リモートリポジトリ(origin)に保存されている最新のコミット(master)に、ローカルリポジトリの最新版をプッシュして上乗せ更新せよ、という意味になります。\nプッシュが完了すれば、課題提出成功となります。ちゃんとプッシュできたか確認するには、GitHubのサイトで確認するのが最も確実です。全ての課題リポジトリが保存されているKUT Econ Programming Courseのサイトにアクセスして、目当ての課題リポジトリ名を見つけましょう。課題リポジトリ名をクリックすると、リモートの中身を閲覧できますので、ちゃんとプッシュが成功しているか確かめておいてください。"
  },
  {
    "objectID": "programming2025/programming-3.html#ローカルをリモートに同期プル",
    "href": "programming2025/programming-3.html#ローカルをリモートに同期プル",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "2台以上のパソコン(たとえば家と大学など)で同じ課題を行う場合、両方のパソコンで同じリモートリポジトリをクローンし、2台の作業を同期させたい場合があります。そのためには、プッシュするだけではなく、ローカルの状態をリモートの状態に同期させる逆の作業が必要になります。これをプルといいます。\n\n\n\npull\n\n\n2台目に初めてローカルリポジトリを作る時は、単にクローンすれば良いだけです。そのあとは、リモートに変更があるたびに、プルして同期します。プルは非常に簡単で、次のように入力するだけです。\ngit fetch\ngit pull\nこれだけです。fetchはリモートの状態を確かめるコマンドです。git fetchのあとにgit statusすれば、ローカルが何コミット分遅れているかが表示されますので、確かにローカルの方がリモートより遅れていることを確認しましょう。\n確かにリモートのほうが新しければ、git pullによってローカルをリモートに同期させることができます。"
  },
  {
    "objectID": "programming2025/programming-3.html#その他の操作",
    "href": "programming2025/programming-3.html#その他の操作",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "次は、Gitのさらに発展的な操作について学んでいきましょう。次のパブリックリポジトリをGitHubディレクトリの下にクローンしてください。\npractice-pr21-0\nここから先は、VS CodeでリポジトリのREADMEを読んでください。"
  },
  {
    "objectID": "programming2025/programming-3.html#主なgitコマンドまとめ",
    "href": "programming2025/programming-3.html#主なgitコマンドまとめ",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "最後に主要なGitコマンドをリストアップしておきましょう。\n\n\n\n\n\n\n\nコマンド\n用途\n\n\n\n\ngit clone\nリモートリポジトリをローカルにコピー\n\n\ngit status\nリポジトリの状態をチェック\n\n\ngit add -A\n作業エリアの変更をすべてステージ\n\n\ngit add filename\nファイルfilenameの変更をステージ\n\n\ngit commit -m \"Message\"\nメッセージ”Message”をつけてコミット\n\n\ngit commit\nコミット(メッセージはエディタで入力)\n\n\ngit branch --set-upstream-to=origin/master\nローカルと同期させるリモートを設定\n\n\ngit push\nリモートをローカルに同期\n\n\ngit pull\nローカルをリモートに同期\n\n\ngit reset\nステージングエリアをコミットせずに破棄\n\n\ngit reset --hard HEAD\n作業エリアとステージングエリアをコミットせずに共に破棄\n\n\ngit reset --soft HEAD^\nコミット履歴だけ一つ前に戻す\n\n\ngit reset --mixed HEAD^\nコミット履歴を一つ前に戻してステージングエリアもそれに合わせる\n\n\ngit reset --hard HEAD^\nコミット履歴を一つ前に戻して作業エリアとステージングエリアもそれに合わせる\n\n\ngit log\nコミット履歴を閲覧する\n\n\n\nGitには便利なコマンドが無数に存在しますので、インターネット等で調べ、少しずつGitの構造を理解していきましょう。"
  },
  {
    "objectID": "programming2025/programming-3.html#まとめ",
    "href": "programming2025/programming-3.html#まとめ",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "本講義では、以下のことを学びました。\n\nバージョン管理の意義\nGitHubの登録\nリポジトリの操作\n\nクローン\nステージング\nコミット\nプッシュ\nプル\n各種リセット\n\n\n今回の講義では、課題を提出するために必要最低限のGitコマンドだけ学びました。本格的な開発にGitを使うためには、参考書を手に入れてより深く学ぶことをお勧めします(『独習Git』がお勧めです)。"
  },
  {
    "objectID": "programming2025/programming-3.html#参考書",
    "href": "programming2025/programming-3.html#参考書",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "『1日で基本が身に付く!Git超入門』 (リブロワークス著) (2020) 技術評論社. ISBN-13 : 978-4297114404.\n『独習Git』 (Rick Umali著、吉川邦夫 訳) (2016) 翔泳社. ISBN-13 : 978-4798144610."
  },
  {
    "objectID": "programming2025/programming-3.html#補遺",
    "href": "programming2025/programming-3.html#補遺",
    "title": "第3回 バージョン管理入門",
    "section": "",
    "text": "大学の有線LANに繋がっているパソコンの場合は、sshのポートを正しく設定する必要があります。ただし、コンピュータールームのパソコンは、講義の中で自動プログラムにより設定を行ないますので、本項目の作業は不必要です。\n.sshフォルダの中に、configという名前のテキストファイルを作って、中に次のように記述して保存してください(コピペして整形し、プロキシの情報を正しく編集してください)。\nHost github.com\n  User git\n  HostName ssh.github.com\n  Port 443\n  IdentityFile ~/.ssh/id_rsa\n  ProxyCommand connect -H http://proxy.addr:0000 %h %p\nここで、http://proxy.addr:0000は適切なプロキシサーバーのアドレスとポート番号です。"
  },
  {
    "objectID": "programming2025/programming-10.html",
    "href": "programming2025/programming-10.html",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "第10回　pandas入門\n\npandasとは\nデータフレームの作成\nデータフレームのデータ構造\n\n論理的なデータ構造\n物理的なデータ構造\n\nデータのチェック\n\nデータの閲覧\n各変数の型チェック\n各変数の分布のチェック\n要約統計量の計算\n\n可視化の方法概観\nmatplotlibのフォント設定\n散布図のプロット\n色の微調整\n回帰直線のプロット\n回帰直線と散布図のオーバレイ\nSeabornの活用\nグラフの保存\nインデクシングとスライス\n\nインデックス番号\nラベル\nスライス(iloc)\nスライス(loc)\nブールインデックス\nファンシーインデックス\n\n欠測値\n\nNaN (Not a Number)\n欠測の除去\n\nCSVの読み書き\nまとめ\n参考書\n宿題(ホームワーク)\n課題(アサインメント)\n補遺\n\nデータフレーム表示行数の設定\n\n\n\n\n\n前回の講義で学んだNumPyでは、配列構造を導入することにより、データ解析において必須とも言えるベクトル演算や要素への高速なアクセスを可能としていました。\nしかしながら、NumPyの配列は基本的には複数のデータ型を混在させずに使用します。厳密にはオブジェクト型というデータ型を用いると混在させることができますが、高速化の利点は失われてしまいます。現実のデータは、測定する項目によってデータの型は異なるのが普通です。従って、NumPyの配列だけでは、データ解析には十分な柔軟性が得られないことが想像されます。\nRでは、こうした問題をデータフレームという構造を用いて解決しています。データフレームは行列、あるいは表のような構造をしており、各列内ではデータ型は固定ですが、列ごとに異なるデータ型を用いることが可能です。これによって、高速な計算と柔軟性を同時に実現することが出来ます。\npandasは、Pythonでデータフレームを使うためのモジュールであり、Pythonの世界におけるデータ解析ではスタンダードなツールとなっています。pandasは、NumPyをベースに構築されており、操作方法も似ています。\n以前は機械学習モジュールのscikit-learnや可視化モジュールのmatplotlibなどの他のモジュールとの連携が十分でないイメージがありましたが、この問題は現在ではかなり解消し、他のデータ解析モジュールと高い互換性を実現しています。今や、Pythonでデータ解析をするならば、NumPyと同様、pandasを理解することは避けられないと言えます。\n本講義では、前回の講義で作成した線形モデルの疑似サンプルデータを用いて、データをpandasのデータフレームに加工し、操作する方法を解説します。特にCSVファイルの操作と可視化に焦点を当てたいと思います。\n\n\n\nまずはpandasデータフレームがどのようなものか説明するために、前回作った線形モデルの疑似データをデータフレームに格納してみましょう。まずは以下のコードを再実行し、疑似データを再作成してください。今回は、シード値を123に設定してからサンプリングしましょう。\n# %%\n# 線形モデルからのサンプリング\n\nimport numpy as np\nrng = np.random.default_rng(123)\nx = rng.normal(8,2,100)\ne = rng.normal(0,3,100)\ny = 1 + 2 * x + e\n念のため、x、e、yの内容を表示して、サイズ100のサンプルがちゃんと生成されているか確認しておいてください。\n次に、pandasモジュールを読み込みます。pandasは、pdの別名で読み込むのが慣例となっているので、特段の理由が無い限りこれに従いましょう。\n# %%\nimport pandas as pd\nそれでは、x、y、eを変数とするデータフレームを作成しましょう。データフレームを作成する方法は幾つかありますが、最も簡単なのは以下のように辞書を用いる方法です。\nこの方法では、変数名をキー、対応するNumPyの配列を値として持つ辞書を作成し、pandasの関数DataFrameの引数に与えます。戻り値はデータフレームオブジェクトですので、これを適当な変数(ここではdf)に代入しておきましょう。\n# %%\ndata = {'x':x,'y':y,'e':e}\ndf = pd.DataFrame(data)\nprint(type(df))\n# 出力\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nデータフレームdfを表示してみましょう。\n# %%\nprint(df)\n# 出力\n\n            x          y         e\n0    6.021757  11.496212 -1.547303\n1    7.264427  20.503193  4.974340\n2   10.575851  21.259913 -0.891788\n3    8.387949  13.625766 -4.150131\n4    9.840462  19.837310 -0.843614\n..        ...        ...       ...\n95   5.555309  12.561268  0.450651\n96   7.392817  15.309035 -0.476600\n97   5.652623   9.026150 -3.279095\n98   9.652547  21.696433  1.391339\n99   9.700645  15.425901 -4.975388\n\n[100 rows x 3 columns]\nこのように、途中の行は省略されていますが、100行×3列の表形式になっており、各列はx、y、eの値を格納していることが分かります。各行は、一つのオブザベーションであることに注意してください。\nなお、上記のように、デフォルトでpandasのデータフレームはオブザベーションが一定行数を超える場合は中間のオブザベーションを省略して表示するようになっています。この表示設定を変更する方法は補遺に記載しておきます。\n\n\n\n\n\npandasデータフレームは、概念的には、各変数の配列を束にしたものになっています。各変数のデータを配列で取得するには、次のようにします。\n# %%\nx_ser = df.x\nx_arr = df.x.values\nprint(type(x_ser))\nprint(type(x_arr))\n前者(x_ser)ではSeriesというpandas特有の配列型オブジェクトが得られますが、後者(x_arr)ではndarray型のNumPy配列が得られます。\n# 出力\n\n&lt;class 'pandas.core.series.Series'&gt;\n&lt;class 'numpy.ndarray'&gt;\nしばしば、「DataFrameはSeriesを束にしたものである」という表現がなされることがありますが、これはデータフレームから単一の変数データを取り出すと、往々にしてSeries型で返されるためです。多くの場合、以下の図のようなイメージを持っていれば十分でしょう。\n\n\n\ndataframe\n\n\nNumPyの多次元配列とpandasのデータフレームの違いは、ちょうどRの行列とデータフレームの違いと似ています。NumPy多次元配列がすべての要素に同じ型のデータを持たなければならないのに対して、データフレームは、列ごとに異なる型を持つことができます。\n一つの列の中では、通常は型が統一されますが、オブジェクト型の変数は任意のデータをもつことができます。\nこのようにpandasのデータの正体はndarrayオブジェクトですので、pandasのデータ型は基本的にNumPyのデータ型を踏襲していると考えて概ね正しいです。ただし幾つかの例外はあります。\nたとえば、NumPy配列には文字列型が存在しますが、pandasデータフレームでは文字列はオブジェクト型として保存されるという違いがあります。\nまた、pandasには、欠測値を表すことができるInt64やInt32といった整数型が存在しますが、これはNumPyには存在しません。(Intという大文字からはじまる型名であることに注意してください。実際には、Int64やInt32は内部でnp.int64、np.int32の配列を扱っています。)\n\n\n\n論理的にはデータフレームはSeriesオブジェクトの束ですが、複数のデータフレームがメモリを共有しているのか否か、あるいはデータフレームを用いた種々の計算の効率性といったことを知る必要がある場合は、実際にどのようにデータが格納されているかを気に掛ける必要があります。\nデータフレームの実際のデータは、データフレーム内のブロックマネージャというオブジェクトによって管理されています。ブロックマネージャの属性名は_dataです。\n# %%\nbm = df._data   # ブロックマネージャを取得\nprint(type(bm))\nprint(bm)\n# 出力\n\n&lt;class 'pandas.core.internals.managers.BlockManager'&gt;\nBlockManager\nItems: Index(['x', 'y', 'e'], dtype='object')\nAxis 1: RangeIndex(start=0, stop=100, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 100, dtype: float64\nBlockManagerを出力した結果で重要なのはItemsとFloatBlockの項目です。Itemsは、変数のリストを表しています。一方、FloatBlockの欄は次のように解釈します。\n\n\n\n\n\n\n\n記述\n意味\n\n\n\n\nslice(0,3,1)\n変数リストのスライス[0:3:1]、つまり0,1,2番目の変数は・・・\n\n\n3 x 100\n3行100列の2次元NumPy配列に格納されている\n\n\ndtype: float64\nそしてその数値型はNumPyのfloat64型である\n\n\n\nこの情報より、実際には、データフレームの数値は単一の2次元NumPy配列に格納されていることが分かります。\n各変数のデータが収められているNumPy配列の実体を取得するには、各変数のvalues.base属性にアクセスします。もう少し詳しくいうと、values属性はデータのビューですので、その参照元の配列をbaseで取得します。\n次のコードの出力により、x、y、eのデータが単一の2次元NumPy配列に格納されていることを確認できます。\n# %%\nbase_array = df.x.values.base\nprint(df.y.values.base is base_array)\nprint(df.e.values.base is base_array)\nprint(base_array.shape)\n# 出力\n\nTrue\nTrue\n(3, 100)\nこのように、pandasのデータフレームは、同じ型を持つ変数を一つのNumPy配列にまとめて格納することによって各種計算の高速化を図っています。\nここで試しに、dfに、整数の変数を加えた新しいデータフレームを作ってみます。\n# %%\nint_var = np.arange(100,dtype=np.int64)\n\ndata2 = {'x':x,'y':y,'e':e,'int_var':int_var}\ndf2 = pd.DataFrame(data2)\nprint(df2.head())\n           x          y         e  int_var\n0   6.021757  11.496212 -1.547303        0\n1   7.264427  20.503193  4.974340        1\n2  10.575851  21.259913 -0.891788        2\n3   8.387949  13.625766 -4.150131        3\n4   9.840462  19.837310 -0.843614        4\n同じようにブロックマネージャを取得してみましょう。\n# %%\nbm2 = df2._data\nprint(bm2)\nBlockManager\nItems: Index(['x', 'y', 'e', 'int_var'], dtype='object')\nAxis 1: RangeIndex(start=0, stop=100, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 100, dtype: float64\nIntBlock: slice(3, 4, 1), 1 x 100, dtype: int64\n今度は、IntBlockという欄が新たにできました。この欄を読み解くと、第3変数のint_varは１行100列のNumPy配列に格納されており、その数値型はint64であることが分かります。\n\n\n\nblockmanager\n\n\nこのように、数値型が異なる変数のデータは異なるNumPy配列に格納されています。実際、次のようにしてxとint_varのデータがメモリを異にすることが分かります。\n# %%\ndf2.x.values.base is df2.int_var.values.base\n# 出力\nFalse\n同じ数値型のデータが同じブロック(2次元NumPy配列)に格納されていることから、データ型が同じ変数であれば、列方向の計算も、かなりのパフォーマンスで実行できることが分かります。\n\n\n\n\nデータフレームを作成したら、本格的な分析にとりかかるまえに、まず始めにデータを精査すべきです。データを精査するプロセスには、様々な作業が含まれますが、例えば以下のような作業は有効でしょう。\n\n読み込んだデータの閲覧\n各変数の型のチェック\n欠測値の有無のチェック\n各変数の分布のチェック\n各変数の要約統計量の計算\n\nこのうち、欠測値の有無のチェックについては、多少難しい操作になるので、後に回し、ここでは1,2,4,5を説明します。\n\n\n例えば文字列データを読み込んだ際に文字化けが無かったか、などをチェックするのに役立ちます。データの閲覧は、単純にprintでデータを出力してみるのが最も簡単な方法です。\nそのほか、以下のようなメソッドも有効でしょう。\n\n\n\nメソッド\n機能\n用例\n\n\n\n\nhead\n先頭の指定した行数だけ表示\ndf.head(20)\n\n\ntail\n末尾の指定した行数だけ表示\ndf.tail(20)\n\n\n\nheadおよびtailの行数指定はオプションであり、指定しない場合は5行表示します。\n# %%\nprint(df.tail())\ndf.tail()だけでも良いのですが、そうするとHTML加工されて出力されるので、ここでは書面の都合上print関数を使いました。\n# 出力\n           x          y         e\n95  5.555309  12.561268  0.450651\n96  7.392817  15.309035 -0.476600\n97  5.652623   9.026150 -3.279095\n98  9.652547  21.696433  1.391339\n99  9.700645  15.425901 -4.975388\nまた、特定の列だけ取得する方法には、様々な方法があります。\n\n\n\n記法\n機能\n型\n\n\n\n\ndf['x']\nxの列だけ取得\nSeries\n\n\ndf[['x']]\nxの列だけ取得\nDataFrame\n\n\ndf[['x','y']]\nx、yだけのデータを取得\nDataFrame\n\n\ndf.x\nxの列だけを取得\nSeries\n\n\ndf.loc[:,'x']\nxの列だけを取得\nSeries\n\n\ndf.loc[:,['x']]\nxの列だけを取得\nDataFrame\n\n\ndf.iloc[:,0]\n第0列だけを取得\nSeries\n\n\ndf.iloc[:,[0,1]]\n第0、1列だけのデータを取得\nDataFrame\n\n\n\n記法によって、得られるデータがSeries型の場合とDataFrame型の場合があるので、多少注意が必要です。\nlocやilocの使い方については、後でインデクシングとスライスの説明を行う際に解説します。\n\n\n\nデータフレームに読み込んだ変数のデータ型をチェックするには、データフレームのdtypes属性を表示します。\n# %%\nprint(df.dtypes)\n# 出力\n\nx    float64\ny    float64\ne    float64\ndtype: object\nこれを見ると分かるように、意図したようにx、y、eが全て64ビット浮動小数点数として格納されていることが分かります。\nこのチェックによって、たとえば、xがオブジェクト型(object)などとして読み込まれていたりした場合は、xに数値以外のものがうっかりと混じってしまっていた可能性があります。あるいはデータをファイルから読み込んだ場合は、ファイルのオープンで何らかのトラブルがあった可能性があります。\n\n\n\n各変数の分布のチェックをするには、ヒストグラムをプロットするのが一番分かりやすい方法です。データフレームには、histという全ての変数のヒストグラムをプロットするメソッドがあります。\n# %%\ndf.hist()\n出力は以下のようになります。\n\n\n\nhist\n\n\nこれにより、分布の形状に際立った特徴がないか、例えば母集団がマルチモーダルになっている可能性はないか、といった考察ができます。\n\n\n\npandasデータフレームには、要約統計量を計算する便利なメソッドが揃っています。一番最初に試してみるべきメソッドは、describeでしょう。これはRデータフレームのsummaryメソッドに対応するものです。\n# %%\nprint(df.describe())\n# 出力\n\n                x           y           e\ncount  100.000000  100.000000  100.000000\nmean     8.163830   17.621354    0.293695\nstd      1.799021    4.655073    2.761058\nmin      3.585058    5.838924   -8.185457\n25%      6.978835   13.910635   -1.225525\n50%      8.033164   17.570366    0.264505\n75%      9.653371   20.953255    2.130415\nmax     12.579820   27.685974    6.796562\n出力された各要約統計量の意味は次の通りです。\n\n\n\n統計量\n意味\n\n\n\n\ncount\nオブザベーション数\n\n\nmean\n平均値\n\n\nstd\n標準偏差\n\n\nmin\n最小値\n\n\n25%\n25%分位点\n\n\n50%\n50%分位点\n\n\n75%\n75%分位点\n\n\nmax\n最大値\n\n\n\nなお、こちらのstdはNumPyと異なり、自由度のデフォルトはN-1ですのでご注意ください。\n自由度を変えたい場合は、独立にstdメソッドやvarメソッドを呼び出し、オプション引数ddofを設定する必要があります。\n#%%\n# 自由度をNにした分散と標準偏差\nprint('Var:')\nprint(df.var(ddof=0))\nprint()\nprint('Std:')\nprint(df.std(ddof=0))\n# 出力\nVar:\nx     3.204111\ny    21.453009\ne     7.547206\ndtype: float64\n\nStd:\nx    1.790003\ny    4.631739\ne    2.747218\ndtype: float64\nパーセンタイルをカスタマイズしたい場合は、describeメソッドのpercentiles引数にパーセンタイルをリストで渡します。たとえば2.5%、50%、97.5%を出力したいときは、次のようにします。\n# %%\nprint(df.describe(percentiles=[0.025,0.5,0.975]))\n                x           y           e\ncount  100.000000  100.000000  100.000000\nmean     8.163830   17.621354    0.293695\nstd      1.799021    4.655073    2.761058\nmin      3.585058    5.838924   -8.185457\n2.5%     4.984007    8.015538   -5.119716\n50%      8.033164   17.570366    0.264505\n97.5%   11.348816   26.412084    5.619012\nmax     12.579820   27.685974    6.796562\n相関行列を計算するには、corrメソッドが使えます。\n# %% ピアソンの積率相関係数\nprint(df.corr(\"pearson\"))\n引数には”pearson”(ピアソン積率相関係数)、“kendall”(ケンドール順位相関係数)、“spearman”(スピアマン順位相関係数)が選べます。\n# 出力\n          x         y         e\nx  1.000000  0.805777  0.055381\ny  0.805777  1.000000  0.635935\ne  0.055381  0.635935  1.000000\n他にも様々なメソッドやオプション引数がありますので、pandasのリファレンスマニュアルをチェックしてみてください。\n\n\n\n\nPythonでデータや分析の結果を可視化するには、matploblibモジュールを使うのが最もポピュラーです。筆者が把握する限り、matplotlibを用いるには、主に3つの方法があります。\n\nmatplotlibを直接操作する\npandasデータフレームからmatploblibを呼び出す\nSeabornからmatplotlibを呼び出す\n\nmatplotlibは非常に低水準なグラフ描画機能を提供するので、柔軟性は高いですが、綺麗なグラフをmatplotlibで手作りするのは中々骨が折れます。\nSeabornはmatplotlibのインターフェースを高水準にしたもので(こういうものをラッパーと呼びます)、柔軟性は低いですが、非常に簡単にきれいなグラフを作成できるという特徴があります。しかしながら、詳細なカスタマイズをしようと思うと、最終的にはmatplotlibをいじらないといけません。細部にこだわらない普段使いには十分であるような気がします。\npandasデータフレームからmatplotlibを呼び出すのは、matplotlibを直接操作するのと対して変わりありませんが、幾分インターフェースが簡略化されて使いやすくなっています。データフレームのメソッドなので、データにアクセスしやすくなっています。こちらについても、詳細な設定はmatplotlibに立ち返らないといけません。\n(なお、PythonでもRのggplotを使うことはできます。筆者はほとんど使ったことがありませんが、操作感がよいとは言えない印象があります。どなたかレビューお願いします。筆者の場合、そもそもggplotを使いたいなら、最初からRを使います。)\nこのように、Rの可視化部門が実質ggplot2に一元化されているのに対し、Pythonの可視化部門は若干散らかっている印象があります。改めて見ると、ggplot2が優れているのは、非常に高水準なインターフェースと、極めて低水準な操作を両立している点ではないでしょうか。要するに、多少雑で良いなら簡単に様々なグラフが作れるが、頑張ればいくらでも美しく加工できるということです。\nさて、Pythonに話を戻しましょう。筆者としては、グラフの大枠はpandasやSeabornで作成し、細かい微調整についてはmatplotlibを直接操作するというのが良いのではないかと思います。今回の講義はpandasの説明が中心ですので、データフレームのメソッドを介して可視化する方法を中心に説明します。\n\n\n\nmatplotlibのデフォルトのフォントでは日本語が文字化けしてしまうため、まずフォントの設定を行う必要があります。\n次のように、matplotlibをインポートしてフォントを日本語フォントに変えましょう。Windowsでは”MS gothic”や”MS mincho”、“Meiryo”がありますが、ここでは”Meiryo”にしておきましょう。\n# MS ゴシックに変更\nimport matplotlib\nmatplotlib.rcParams['font.family'] = 'Meiryo'\nまた、上記のやり方では、毎回の起動時にフォントを設定する必要があります。起動時のデフォルトのフォントを変更する方法もあります。\nフォント周りの設定は本質的でなくごちゃごちゃした事項になるので、チートシートを別に作りました。参考にしてください。\n\n\n\n散布図をプロットするには、データフレームのplot.scatterメソッドを使います。\n# %%\ndf.plot.scatter(x='x',y='y')\n出力は以下のようになります。\n\n\n\nscatter1\n\n\nオプション引数をつけることによって、様々な微調整が可能です。\n\n\n\nオプション引数\n意味\n\n\n\n\ns\nマーカーサイズ\n\n\nc\nマーカー色\n\n\nmarker\nマーカー形状\n\n\nxlim\n横軸範囲\n\n\nylim\n縦軸範囲\n\n\nfontsize\nフォントサイズ\n\n\n\nこれらのオプション引数は、例えば次のように使用します。\n# %%\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n軸ラベルを変更するのは、少し手間がかかります。まずmatplotlibのサブモジュールpyplotをインポートします(慣習として、pltという名前で読み込みます)。次に、pyplotモジュールのxlabel関数とylabel関数で軸ラベルとそのサイズを次のように変更できます。\n# %%\nimport matplotlib.pyplot as plt\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\nまた、グラフ上下左右のマージンを設定するには、\n# %%\nplt.subplots_adjust(left=0.2,bottom=0.2)\nのように指定します。\nここで注意しなくてはならないのは、VS Codeの対話的モードで図を描く場合、図を描く関数の呼び出しと、図を調整する関数plt.xlabel等の呼び出しは、次のように全て同じセルで行わなくてはならないということです(importは別のセルで構いません)。\n# %%\nimport matplotlib.pyplot as plt\n\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\nplt.subplots_adjust(left=0.2,bottom=0.2)\n出力は次のようになります。\n\n\n\nscatter2\n\n\n全てのマーカー形状と全ての色名は以下のmatplotlibのサイトにリストアップされています。\n\n全てのマーカー形状\n全ての色名\n\nまた、plot.scatterメソッドの詳細な使い方はpandasのリファレンスを見てください。\n\n\n\nマーカーの色はRGBもしくはRGBAでも指定可能です。RGBは、赤・緑・青の強さを0～1の数値で表したものです(0～255の1バイト整数で表すことも多いです)。三つの数値をタプルで表します。たとえば、\n(0,0,1)\nは青原色となります。\nまた、RGBAは、RGBに加えて、第4の数値が不透明度を0～1で表します。1が最も不透明で、0が透明です。\nmatplotlibでは、colors.to_rgbおよびcolors.to_rgba関数によって色名からRGB値およびRGBA値を取得できます。\n# \"coral\"のRGBA値を取得\nrgba_coral = matplotlib.colors.to_rgba(\"coral\")\nprint(rgba_coral)\n# 出力\n\n(1.0, 0.4980392156862745, 0.3137254901960784, 1.0)\nたとえば、このRGBA値のアルファ値を少し減じてやることによって、透明度のある”coral”を作ることができます。\n# %%\nrgba_coral_tr = rgba_coral[0:3] + (0.6,)\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\ncolor=rgba_coral_tr,            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\nplt.subplots_adjust(left=0.2,bottom=0.2)\n結果は次のようになります。\n\n\n\nscatter3\n\n\nただし、RGB値やRGBA値を渡す場合は、引数名はcではなくcolorにしてください。\n\n\n\nそれでは次に、単回帰の結果を散布図に重ねましょう。まずは回帰分析を再実行しておきます。\n# %%\n# 回帰分析\nfrom scipy import stats\nres = stats.linregress(df.x,df.y)\nprint(res)\nここで、データフレームdfの変数xの配列と変数yの配列にアクセスするために、df.x、df.yという表記を用いていることに注意してください。このように、データフレームでは、df.変数名という表記によって、各列を取り出すことができます。\n# 出力\nLinregressResult(slope=2.084996965456381, intercept=0.5997940915043358, rvalue=0.8057774353709972, pvalue=5.010945582964262e-24, stderr=0.15479582428347563, intercept_stderr=1.2937470389108192)\ninterceptが切片、slopeが回帰係数であることに注意してください。\n次に、この結果を用いて、回帰モデルの予測値を与えるデータフレームを用意しましょう。\nまず、x_modelを予測用のサンプルデータ点を表すNumPy配列にします。これは、グラフの定義域をカバーしていればどんな配列でもよいのですが、ここでは、3～13の範囲を100分割した数列にしておきましょう。このような操作には、NumPyのlinspace関数を使います。\n# %%\nx_model = np.linspace(3,13,100)\nprint(len(x_model))                 # 配列の長さ\nprint(np.round(x_model[:3],3))      # 最初の3要素\nprint(np.round(x_model[-3:],3))     # 最後の3要素\nlinspaceの引数は、それぞれ、開始数値、終端数値、分割数です。\n# 出力\n100\n[3.    3.101 3.202]\n[12.798 12.899 13.   ]\n次に、y_modelを、yの予測値を与える配列とします。これは、回帰分析の結果を用いて次のように計算できます。\n# %%\ny_model = res.intercept + res.slope * x_model\nこれを用いて、100オブザベーションについての予測値を格納したデータフレームdf_modelを次のように作成しておきます。\n# %%\ndf_model = pd.DataFrame({'x':x_model,'y':y_model})\nprint(df_model)\n# 出力\n\n           x          y\n0    3.00000   6.854785\n1    3.10101   7.065391\n2    3.20202   7.275996\n3    3.30303   7.486602\n4    3.40404   7.697208\n..       ...        ...\n95  12.59596  26.862332\n96  12.69697  27.072937\n97  12.79798  27.283543\n98  12.89899  27.494149\n99  13.00000  27.704755\n\n[100 rows x 2 columns]\nこの予測値のデータフレームで、x横軸、y縦軸の折れ線グラフを描けば、回帰直線になっているはずです。回帰直線には、データフレームのplot.lineメソッドを使います。linestyle引数で線の種類、linewidthで線の太さを設定できます。\n# %%\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',\ncolor='grey',\nlinewidth=3\n)\nscatterと同じく様々な微調整が可能ですが、ここでは後で散布図と重ねることを考慮して、微調整は行わないことにします。\n出力は以下のようになります。\n\n\n\nlinear_pred\n\n\nなお、全ての線の種類のリストは以下で調べることができます。\n\n線の種類一覧\n\n\n\n\nそれでは、最後に、上で作成した散布図と回帰直線をオーバレイ(重ね描き)してみましょう。まずは、オーバレイせずにそのまま二つのグラフを打ち出すだけのコードを書いてみます。\n以下のようになりますが、これまで作成したコードを合わせただけなので、特に説明はいらないでしょう。\n# %%\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',     # 線種\ncolor='grey',           # 線色\nlinewidth=3             # 線幅\n)\n\nplt.xlabel('Xの値',size=18) # X軸ラベル\nplt.ylabel('Yの値',size=18) # Y軸ラベル\nplt.subplots_adjust(left=0.2,bottom=0.2) # マージン\nふたつのグラフを重ねるには、以下のように一つ目のグラフの戻り値を、二つ目のグラフのax引数に渡します。\n# %%\nax = df.plot.scatter(x='x',y='y', # 戻り値をaxに\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',     # 線種\ncolor='grey',           # 線色\nlinewidth=3,            # 線幅\nax=ax,                  # 一つ目のグラフの戻り値\nlegend=False            # レジェンドを削除\n)\n\nplt.xlabel('Xの値',size=18) # X軸ラベル\nplt.ylabel('Yの値',size=18) # Y軸ラベル\nplt.subplots_adjust(left=0.2,bottom=0.2) # マージン\n出力は次のようになります。ここでは、ついでに二つ目のグラフのレジェンドを削除しておきました。\n\n\n\nregress\n\n\n\n\n\n上記では、まず回帰分析を行ってから、その結果を散布図に重ねるという作業を行いましたが、Seabornモジュールのregplotメソッドを用いると、回帰直線と信頼区間を自動で挿入してくれます。\nSeabornのモジュール名はseabornですが、snsの別名で読み込むのが慣習となっていますので、それに従いましょう。\n# %%\nimport seaborn as sns\n# %%\nsns.regplot(x=df.x,y=df.y,\n    color='black',\n    marker='x',\n    scatter_kws={'s':10})   # マーカーサイズ\n\nplt.tick_params(labelsize=14)   # 軸数値のサイズ\nplt.xlim((3,13))\nplt.ylim((4,30))\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\n\nplt.subplots_adjust(left=0.2,\n    bottom=0.2)\n\n\n\nregplot\n\n\n本講義では、Seabornの詳しい解説はしませんが、興味がある方はリファレンスマニュアルを参照してください。\n\n\n\n可視化の締めくくりとして、グラフのファイルへの保存について説明しておきます。グラフの保存は、matplotlib.pyplotのsavefig関数によって行います。やはり、グラフを描画したセル内部で保存をする必要があります。\n# %%\nax = df.plot.scatter(x='x',y='y', # 戻り値をaxに\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',     # 線種\ncolor='grey',           # 線色\nlinewidth=3,            # 線幅\nax=ax,                  # 一つ目のグラフの戻り値\nlegend=False            # レジェンドを削除\n)\n\nplt.xlabel('Xの値',size=18) # X軸ラベル\nplt.ylabel('Yの値',size=18) # Y軸ラベル\nplt.subplots_adjust(left=0.2,bottom=0.2) # マージン\n\nplt.savefig('linregress.png',\ndpi=300,\nfacecolor='white')\n最後の一行でグラフを’linregress.png’というPNGファイルに保存しています。ここでは、背景を白色にするためにfacecolor引数に’white’を指定し、解像度を300dpiに設定しました。\nエクスプローラで’linregress.png’を探して表示できるかどうか試してみてください。\n\n\n\nデータフレームの一部を取り出すには、様々な方法があります。\n\nインデックス番号による参照\nラベルによる参照\nスライスによる参照\nブールインデックス参照\nファンシーインデックス参照\n\nいずれの方法でも、locとilocという二つのインデクサを用いることになります。\n\n\nインデックス番号でデータフレームの要素にアクセスするには、ilocを使います。iloc[i,j]でi行j列の要素を意味します。\n# %%\nprint(df.head())\nprint(\"\\ndf.iloc[2,1]:\")\nprint(df.iloc[2,1])\n# 出力\n\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.iloc[2,1]:\n21.25991325823923\n\n\n\n変数ラベルを用いて要素にアクセスしたい場合は、ilocの代わりにlocを使う必要があります。\n# %%\nprint(df.head())\nprint(\"\\ndf.loc[3,'x']:\")\nprint(df.loc[3,'x'])\n# 出力\n\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.loc[3,'x']:\n8.387948838265226\n\n\n\nilocにスライス記法を使えば、データフレームの一部をスライスで取り出せます。\n# %%\nprint(df.head())\nprint(\"\\ndf.iloc[0:3,1]:\")\ndata_slice = df.iloc[0:3,1]\nprint(data_slice)\nprint(type(data_slice))\n# 出力\n\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.iloc[0:3,1]:\n0    11.496212\n1    20.503193\n2    21.259913\nName: y, dtype: float64\n&lt;class 'pandas.core.series.Series'&gt;\n上記のように、スライスで気を付けないといけないのは、列番号を単一数値にすると、データフレームではなくSeriesオブジェクトになって返されるということです。\nデータフレームを返して欲しい場合は、以下のように単一要素でもスライスもしくはリストにしてインデクサに渡す必要があります。\n# %%\nprint(df.head())\nprint(\"\\ndf.iloc[0:3,1:2]:\")\ndata_slice = df.iloc[0:3,1:2]\nprint(data_slice)\nprint(type(data_slice))\n# 出力\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.iloc[0:3,1:2]:\n           y\n0  11.496212\n1  20.503193\n2  21.259913\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n\n\n\nlocインデクサを用いれば、列名にもスライスが使用可能です。\n# %%\ndf_xy = df.loc[:,'x':'y']\nprint(df_xy)\n# 出力\n            x          y\n0    6.021757  11.496212\n1    7.264427  20.503193\n2   10.575851  21.259913\n3    8.387949  13.625766\n4    9.840462  19.837310\n..        ...        ...\n95   5.555309  12.561268\n96   7.392817  15.309035\n97   5.652623   9.026150\n98   9.652547  21.696433\n99   9.700645  15.425901\n\n[100 rows x 2 columns]\nここで、locインデクサのスライスは若干記法が特殊であることに注意してください。番号によるスライスとは違って、'x':'y'と書くと、yの列も含まれたデータフレームが得られます。\nこれは行インデックスでも同じです。locインデクサで行をスライスするときは、1:4とかくと、4行目も含まれたデータフレームが得られます。\n\n\n\nブールインデックス参照とは、行数あるいは列数に等しい長さをもったブール値の配列を用いてデータフレームの一部を取り出すことです。データ分析で非常に頻繁に用いる手法ですので、必ず覚えておきましょう。\nたとえば、xの値が8以上になっているオブザベーションだけを取り出したいとします。このような場合、以下のようなブールインデックス参照が有効です。\n# %%\ndf_xgt8 = df.loc[df.x&gt;=8,:]\nprint(df_xgt8.head())\nnp.all(df_xgt8.x &gt;= 8)       # 全て8以上か確認\n# 出力\n\n           x          y         e\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n5   9.154208  20.388477  1.080062\n7   9.083904  25.964371  6.796562\nTrue\nブールインデックス参照に慣れていないと、これは何をやっているのか分からないでしょう。\n上の記法を理解するため、まずインデクサに渡したdf.x&gt;=8が何を意味するのか考えてみます。\ndf.x &gt;= 8\nこの二項演算において、左辺はSeries型配列、右辺は8というスカラですが、ブロードキャストが起きて右辺は左辺と同じ長さ100のSeries型配列に変換されます。これはNumPy配列の場合と全く同じです。\nそのあと、項ごとに二項演算&gt;=が実行され、結果はTrueとFalseの長さ100の配列になります。\n実際に結果を見てみましょう。\n# %%\nprint(df.x&gt;=8)\nprint(type(df.x&gt;=8))\n# 出力\n\n0     False\n1     False\n2      True\n3      True\n4      True\n      ...  \n95    False\n96    False\n97    False\n98     True\n99     True\nName: x, Length: 100, dtype: bool\n&lt;class 'pandas.core.series.Series'&gt;\nこのSeries配列では、x&gt;=8が成り立つところではTrue、成り立たないところではFalseになっていることに注意してください。\npandasのデータフレームは、こうしたブール値配列をlocインデクサに渡すと、Trueが成り立っている行だけを返してくれるという機能を持っています。こうしたブール値配列を用いた部分データの取得をブールインデックス参照と呼びます。pandasに限らずデータフレームを扱う大抵のツールで提供されている機能です。\nブールインデックス参照を用いると、複雑な条件を満たすオブザベーションだけを容易に取り出すことができます。\nたとえば、x&gt;=8かつy&lt;20を満たす行だけを取り出してみましょう。この場合、次のようにします。\n# %%\ndf_x8y20 = df.loc[(df.x&gt;=8) & (df.y&lt;20),:]\nprint(df_x8y20.head())\nprint(df_x8y20.shape)\n# 出力\n\n            x          y         e\n3    8.387949  13.625766 -4.150131\n4    9.840462  19.837310 -0.843614\n14  10.000539  19.061887 -1.939190\n21   9.655843  19.544249 -0.767437\n24   9.509539  19.163218 -0.855860\n(21, 3)\nここで重要なポイントが二つあります。\n\n二つの条件を繋ぐときは、各条件を丸カッコで囲む\n二つのブール値配列のANDは、andではなく&をつかう\n\nこれらの2点を見落としがちですので気を付けましょう。andはスカラーの間の論理積には使えますが、配列の間の論理積には使えません。代わりに&を使います。\n同様に、論理和ORは|、否定には~を使います。\n\n\n\n最後にファンシーインデックス参照は、取り出したいインデックス番号のリストや配列をインデクサに渡す方法です。たとえば、0、2、4行目だけを取り出したいときは、次のようにします。\n# %%\ndf_fancy = df.iloc[[0,2,4],:]\nprint(df_fancy.head())\n# 出力\n           x          y         e\n0   6.021757  11.496212 -1.547303\n2  10.575851  21.259913 -0.891788\n4   9.840462  19.837310 -0.843614\nなお、これまでの様々なインデクシングの記法は、組み合わせて使うことができることに注意しましょう。たとえば変数xとeの1～4行目を取り出したいときは次のようにします。\n# %%\ndf_comb = df.loc[1:4,['x','e']]\nprint(df_comb)\n# 出力\n           x         e\n1   7.264427  4.974340\n2  10.575851 -0.891788\n3   8.387949 -4.150131\n4   9.840462 -0.843614\n\n\n\n\n\n\npandasでは、従来欠測値はnp.nanオブジェクト(NaNとも表記されます)で表されてきました。np.nanは”Not a Number”を意味しており、NumPy配列における値の欠測を表現するために使われます。NaNは浮動小数点型なので、一つの配列内でint型と混在させることはできません。\nたとえば下記のように、int64型の配列にNaNを代入すると、エラーが出ます。\n# %%\n# 整数配列にNaNを入れてみる\narr = np.arange(10,dtype=np.int64)\nprint(arr.dtype)\narr[0] = np.nan\n# 出力\nint64\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n\n...(中略)...\n\n      56 arr = np.arange(10,dtype=np.int64)\n      57 print(arr.dtype)\n----&gt; 58 arr[0] = np.nan\n\nValueError: cannot convert float NaN to integer\nたとえば、先ほど作成したデータフレームdf2をコピーしてdf3という新しいデータフレームを作成し、欠測値を挿入してみましょう。\n# %%\ndf3 = df2.copy()\nここでは、変数xの第3オブザベーション(0からカウントして)と変数yの第2オブザベーションにNaNを入れてみましょう。\n# %%\ndf3.loc[3,'x'] = np.nan\ndf3.loc[2,'y'] = np.nan\nprint(df3.head())\n# 出力\n\n           x          y         e  int_var\n0   6.021757  11.496212 -1.547303        0\n1   7.264427  20.503193  4.974340        1\n2  10.575851        NaN -0.891788        2\n3        NaN  13.625766 -4.150131        3\n4   9.840462  19.837310 -0.843614        4\n上記のとおりNaNは”NaN”と表示されます。\nこういった欠測値をどのように取り扱うかべきかは、場合によりますが、いずれにせよ欠測が存在していることを確認することは重要です。\n\n\n\n欠測が少ない場合は、欠測を含む行を全て除去する対処法が考えられます。これをリストワイズ除去と呼び、欠測に対処する方法の中では最も原始的なものです。\nデータフレームのdropnaメソッドを使うと、リストワイズ除去したデータフレームが返されます。\n# %%\ndf3_dropnan = df3.dropna()\nprint(df3_dropnan.head())\n# 出力\n\n          x          y         e  int_var\n0  6.021757  11.496212 -1.547303        0\n1  7.264427  20.503193  4.974340        1\n4  9.840462  19.837310 -0.843614        4\n5  9.154208  20.388477  1.080062        5\n6  6.727073  13.750969 -0.703176        6\nなお、逆に欠測に値を代入するときは、fillnaメソッドが使えます。たとえば、欠測に平均値を代入する場合は、次のようにします。\n# %%\ndf3_fillnan = df3.fillna(df3.mean())\nprint(df3.mean())\nprint(df3_fillnan.head())\n# 出力\n\nx           8.161566\ny          17.584601\ne           0.293695\nint_var    49.500000\ndtype: float64\n           x          y         e  int_var\n0   6.021757  11.496212 -1.547303        0\n1   7.264427  20.503193  4.974340        1\n2  10.575851  17.584601 -0.891788        2\n3   8.161566  13.625766 -4.150131        3\n4   9.840462  19.837310 -0.843614        4\nなお、pandasには整数の欠測を表現できるpandas.NAという型も存在していますが、こちらについては本講義では割愛します。\n\n\n\n\npandasは、CSVとデータフレームの間で直接読み書きができるようになっています。まずは、今回の講義で作成したデータフレームdfをCSVに保存してみましょう。\nCSVへの保存には、to_csvメソッドを使います。\n# %%\ndf.to_csv('pandas.csv',\n    encoding='utf-8',\n    index=False)  # 行インデックスなし\nここでは、’pandas.csv’という名前のファイルに、utf-8エンコーディングで保存しました。indexオプション引数をFalseにして、行インデックスはCSVに含めないようにしました。\nVS CodeにCSV関連の拡張機能(Edit CSV、Rainbow CSV等)をインストールしていればCSVが閲覧できるはずですので、ファイルエクスプローラで見つけて開いてみましょう。\n次は逆に、先ほど保存したCSVを別の名前のデータフレームに読み込んでみましょう。\n# %%\ndf4 = pd.read_csv('pandas.csv',\n    engine='python',\n    encoding='utf-8')\nengine引数はCSVの解析エンジンを設定するオプションですが、デフォルトで上手く読み込めない場合は、上のように\"python\"を指定すると上手くいくことが多いです。\n\n\n\n今回の講義では以下の点について学びました。\n\nデータフレームの作成\nデータフレームの構造\nデータのチェック\n可視化\n様々なインデクシング\n欠測値の取り扱い\nCSVファイルの読み書き\n\n今回の講義では、非常に高度で豊富なpandasの機能のごく一部しか紹介できませんでした。例えばpandasデータフレームには、データをグループ分けしたり、複数のデータフレームを様々な方法で結合する機能が備わっていますが、こういった高度な話題については一切触れませんでした。可視化についても、ほんの一部の機能しか紹介していません。\npandasのリファレンスマニュアルやインターネット上の情報を探して、自分が必要な機能が実装されていないか調べてみてください。大抵、自分が期待していいる以上のことができることに気付くと思います。\n\n\n\n\nBlockManagerに関する記事\n『Pythonによるデータ分析入門ーNumPy、pandasを使ったデータ処理』(Wes McKinney著、瀬戸山 雅人(翻訳)、小林 儀匡(翻訳)、滝口 開資(翻訳))(2018) オライリージャパン. ISBN-13 : 978-4873118451.\n\npandasデータフレームのデータ構造についての考察は、上記のBlockManagerに関する記事を大いに参考にしました。\n\n\n\n\nデータフレームdfのブロックマネージャdf._dataにはblocksという属性があり、データのブロックがタプル形式で保存されていることを確認してください。各ブロックのデータは、ブロックのvalues属性に格納されています。これがNumPyの配列であることを以下のようにして確認しなさい。また、これがdf.x.values.baseによりアクセスできる配列と同じオブジェクトであることを確かめてください。\n# %%\nfor block in df._data.blocks:\n    arr = block.values\n    print(type(arr))\nSeries型オブジェクトについて研究してください。NumPy配列と同様、Seriesのスライスは元のオブジェクトのビューであることを確認してください。\nデータフレームのデータを、変数xでソートするには、sort_valuesメソッドを次のように使います。実際に試してみてください。\n# %%\nx_sorted = df.sort_values(by='x')\n文字列データを含むデータフレームを作成してみてください。たとえば、次のようにすれば、xが8以上のオブザベーションを”High”、8未満を”Low”とする変数が作れます。’High’なオブザベーションだけを抽出して、各種要約統計量を計算してみてください。\ndf['height'] = 'Low'\ndf.loc[df.x&gt;=8,'height'] = 'High'\ngroupbyメソッドを使うと、groupbyオブジェクトを作成できます。このオブジェクトには、describe、mean、varなどの基本統計量をグループごとに計算するメソッドが備わっています。以下のように、試してみてください。\ngpb = df.groupby('height')\ngpb.describe()\n\n\n\n\n\n\npandasのデータフレームは、デフォルトで一部の行しか表示しないようになっています。表示行数を設定することはできますが、この設定がちょっと分かりにくいので、ここで詳しく説明しておきましょう。\npandasのオプションは、get_optionメソッドもしくは、options属性から確認できます。表示行数に関連するのはmin_rowsオプションとmax_rowsオプションです。\n# get_optionメソッドによる表示\nprint(pd.get_option('display.min_rows'))\nprint(pd.get_option('display.max_rows'))\n# options属性によるアクセス\nprint(pd.options.display.min_rows)\nprint(pd.options.display.max_rows)\n# 出力\n20\n60\nこの２つのオプションは分かりにくいですが、「データフレームの行数がdisplay.max_rowsを超えた場合は、display.min_rows行だけ表示する」という意味です。従って、上記の場合、60オブザベーション以下のデータフレームは全ての行を表示しますが、61オブザベーション以上のデータフレームについては途中を省略して最初と最後の20オブザベーションだけを表示することになります。\n今の場合ですとデータフレームは100オブザベーションを含んでいますので、display.max_rowsを100行以上に設定すると、全ての行が表示されるようになります。\nまた、省略された場合の表示行数を増やしたい場合は、display.min_rowsを増やせばよいことになります。試しにdisplay.min_rowsを30に設定しましょう。オプションの設定は、set_option関数もしくは、options属性を変更することで行います。\n# %%\n# set_option関数を用いる場合\npd.set_option(\"display.min_rows\",30)\n# %%\n# options属性によるアクセス\npd.options.display.max_rows = 60\n# %%\n# データフレームの再表示\nprint(df)\n# 出力\n            x          y         e\n0    8.013504  18.317503  1.290495\n1    9.896525  22.444125  1.651074\n2   11.326705  26.724520  3.071111\n3    8.938435  18.402628 -0.474241\n4    6.862927  16.547593  1.821740\n5   10.850879  22.979716  0.277957\n6    9.264085  20.722213  1.194043\n7    6.849750  13.762926 -0.936575\n8   11.286648  22.471414 -1.101883\n9   10.799512  22.553242 -0.045781\n10   4.228583   7.170566 -2.286601\n11  11.212478  23.096968 -0.327989\n12   8.700634  17.235308 -1.165959\n13   6.341005  20.754819  7.072809\n14   8.717844  20.486063  2.050374\n..        ...        ...       ...\n85   7.623332  17.575759  1.329095\n86   8.119302  16.581371 -0.657233\n87   3.639397   3.949449 -4.329345\n88   6.937774  19.882245  5.006697\n89   3.661514  11.380440  3.057411\n90   5.775179  11.460086 -1.090272\n91   9.078126  19.656764  0.500513\n92   7.534294  13.864200 -2.204387\n93   8.182152  17.203746 -0.160558\n94  10.004772  20.587155 -0.422388\n95   8.927801  14.040083 -4.815520\n96   5.269992  15.510429  3.970445\n97  10.328037  20.252442 -1.403633\n98   8.183177  18.688349  1.321994\n99   5.729897  13.355884  0.896091\n\n[100 rows x 3 columns]"
  },
  {
    "objectID": "programming2025/programming-10.html#pandasとは",
    "href": "programming2025/programming-10.html#pandasとは",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "前回の講義で学んだNumPyでは、配列構造を導入することにより、データ解析において必須とも言えるベクトル演算や要素への高速なアクセスを可能としていました。\nしかしながら、NumPyの配列は基本的には複数のデータ型を混在させずに使用します。厳密にはオブジェクト型というデータ型を用いると混在させることができますが、高速化の利点は失われてしまいます。現実のデータは、測定する項目によってデータの型は異なるのが普通です。従って、NumPyの配列だけでは、データ解析には十分な柔軟性が得られないことが想像されます。\nRでは、こうした問題をデータフレームという構造を用いて解決しています。データフレームは行列、あるいは表のような構造をしており、各列内ではデータ型は固定ですが、列ごとに異なるデータ型を用いることが可能です。これによって、高速な計算と柔軟性を同時に実現することが出来ます。\npandasは、Pythonでデータフレームを使うためのモジュールであり、Pythonの世界におけるデータ解析ではスタンダードなツールとなっています。pandasは、NumPyをベースに構築されており、操作方法も似ています。\n以前は機械学習モジュールのscikit-learnや可視化モジュールのmatplotlibなどの他のモジュールとの連携が十分でないイメージがありましたが、この問題は現在ではかなり解消し、他のデータ解析モジュールと高い互換性を実現しています。今や、Pythonでデータ解析をするならば、NumPyと同様、pandasを理解することは避けられないと言えます。\n本講義では、前回の講義で作成した線形モデルの疑似サンプルデータを用いて、データをpandasのデータフレームに加工し、操作する方法を解説します。特にCSVファイルの操作と可視化に焦点を当てたいと思います。"
  },
  {
    "objectID": "programming2025/programming-10.html#データフレームの作成",
    "href": "programming2025/programming-10.html#データフレームの作成",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "まずはpandasデータフレームがどのようなものか説明するために、前回作った線形モデルの疑似データをデータフレームに格納してみましょう。まずは以下のコードを再実行し、疑似データを再作成してください。今回は、シード値を123に設定してからサンプリングしましょう。\n# %%\n# 線形モデルからのサンプリング\n\nimport numpy as np\nrng = np.random.default_rng(123)\nx = rng.normal(8,2,100)\ne = rng.normal(0,3,100)\ny = 1 + 2 * x + e\n念のため、x、e、yの内容を表示して、サイズ100のサンプルがちゃんと生成されているか確認しておいてください。\n次に、pandasモジュールを読み込みます。pandasは、pdの別名で読み込むのが慣例となっているので、特段の理由が無い限りこれに従いましょう。\n# %%\nimport pandas as pd\nそれでは、x、y、eを変数とするデータフレームを作成しましょう。データフレームを作成する方法は幾つかありますが、最も簡単なのは以下のように辞書を用いる方法です。\nこの方法では、変数名をキー、対応するNumPyの配列を値として持つ辞書を作成し、pandasの関数DataFrameの引数に与えます。戻り値はデータフレームオブジェクトですので、これを適当な変数(ここではdf)に代入しておきましょう。\n# %%\ndata = {'x':x,'y':y,'e':e}\ndf = pd.DataFrame(data)\nprint(type(df))\n# 出力\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nデータフレームdfを表示してみましょう。\n# %%\nprint(df)\n# 出力\n\n            x          y         e\n0    6.021757  11.496212 -1.547303\n1    7.264427  20.503193  4.974340\n2   10.575851  21.259913 -0.891788\n3    8.387949  13.625766 -4.150131\n4    9.840462  19.837310 -0.843614\n..        ...        ...       ...\n95   5.555309  12.561268  0.450651\n96   7.392817  15.309035 -0.476600\n97   5.652623   9.026150 -3.279095\n98   9.652547  21.696433  1.391339\n99   9.700645  15.425901 -4.975388\n\n[100 rows x 3 columns]\nこのように、途中の行は省略されていますが、100行×3列の表形式になっており、各列はx、y、eの値を格納していることが分かります。各行は、一つのオブザベーションであることに注意してください。\nなお、上記のように、デフォルトでpandasのデータフレームはオブザベーションが一定行数を超える場合は中間のオブザベーションを省略して表示するようになっています。この表示設定を変更する方法は補遺に記載しておきます。"
  },
  {
    "objectID": "programming2025/programming-10.html#データフレームのデータ構造",
    "href": "programming2025/programming-10.html#データフレームのデータ構造",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "pandasデータフレームは、概念的には、各変数の配列を束にしたものになっています。各変数のデータを配列で取得するには、次のようにします。\n# %%\nx_ser = df.x\nx_arr = df.x.values\nprint(type(x_ser))\nprint(type(x_arr))\n前者(x_ser)ではSeriesというpandas特有の配列型オブジェクトが得られますが、後者(x_arr)ではndarray型のNumPy配列が得られます。\n# 出力\n\n&lt;class 'pandas.core.series.Series'&gt;\n&lt;class 'numpy.ndarray'&gt;\nしばしば、「DataFrameはSeriesを束にしたものである」という表現がなされることがありますが、これはデータフレームから単一の変数データを取り出すと、往々にしてSeries型で返されるためです。多くの場合、以下の図のようなイメージを持っていれば十分でしょう。\n\n\n\ndataframe\n\n\nNumPyの多次元配列とpandasのデータフレームの違いは、ちょうどRの行列とデータフレームの違いと似ています。NumPy多次元配列がすべての要素に同じ型のデータを持たなければならないのに対して、データフレームは、列ごとに異なる型を持つことができます。\n一つの列の中では、通常は型が統一されますが、オブジェクト型の変数は任意のデータをもつことができます。\nこのようにpandasのデータの正体はndarrayオブジェクトですので、pandasのデータ型は基本的にNumPyのデータ型を踏襲していると考えて概ね正しいです。ただし幾つかの例外はあります。\nたとえば、NumPy配列には文字列型が存在しますが、pandasデータフレームでは文字列はオブジェクト型として保存されるという違いがあります。\nまた、pandasには、欠測値を表すことができるInt64やInt32といった整数型が存在しますが、これはNumPyには存在しません。(Intという大文字からはじまる型名であることに注意してください。実際には、Int64やInt32は内部でnp.int64、np.int32の配列を扱っています。)\n\n\n\n論理的にはデータフレームはSeriesオブジェクトの束ですが、複数のデータフレームがメモリを共有しているのか否か、あるいはデータフレームを用いた種々の計算の効率性といったことを知る必要がある場合は、実際にどのようにデータが格納されているかを気に掛ける必要があります。\nデータフレームの実際のデータは、データフレーム内のブロックマネージャというオブジェクトによって管理されています。ブロックマネージャの属性名は_dataです。\n# %%\nbm = df._data   # ブロックマネージャを取得\nprint(type(bm))\nprint(bm)\n# 出力\n\n&lt;class 'pandas.core.internals.managers.BlockManager'&gt;\nBlockManager\nItems: Index(['x', 'y', 'e'], dtype='object')\nAxis 1: RangeIndex(start=0, stop=100, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 100, dtype: float64\nBlockManagerを出力した結果で重要なのはItemsとFloatBlockの項目です。Itemsは、変数のリストを表しています。一方、FloatBlockの欄は次のように解釈します。\n\n\n\n\n\n\n\n記述\n意味\n\n\n\n\nslice(0,3,1)\n変数リストのスライス[0:3:1]、つまり0,1,2番目の変数は・・・\n\n\n3 x 100\n3行100列の2次元NumPy配列に格納されている\n\n\ndtype: float64\nそしてその数値型はNumPyのfloat64型である\n\n\n\nこの情報より、実際には、データフレームの数値は単一の2次元NumPy配列に格納されていることが分かります。\n各変数のデータが収められているNumPy配列の実体を取得するには、各変数のvalues.base属性にアクセスします。もう少し詳しくいうと、values属性はデータのビューですので、その参照元の配列をbaseで取得します。\n次のコードの出力により、x、y、eのデータが単一の2次元NumPy配列に格納されていることを確認できます。\n# %%\nbase_array = df.x.values.base\nprint(df.y.values.base is base_array)\nprint(df.e.values.base is base_array)\nprint(base_array.shape)\n# 出力\n\nTrue\nTrue\n(3, 100)\nこのように、pandasのデータフレームは、同じ型を持つ変数を一つのNumPy配列にまとめて格納することによって各種計算の高速化を図っています。\nここで試しに、dfに、整数の変数を加えた新しいデータフレームを作ってみます。\n# %%\nint_var = np.arange(100,dtype=np.int64)\n\ndata2 = {'x':x,'y':y,'e':e,'int_var':int_var}\ndf2 = pd.DataFrame(data2)\nprint(df2.head())\n           x          y         e  int_var\n0   6.021757  11.496212 -1.547303        0\n1   7.264427  20.503193  4.974340        1\n2  10.575851  21.259913 -0.891788        2\n3   8.387949  13.625766 -4.150131        3\n4   9.840462  19.837310 -0.843614        4\n同じようにブロックマネージャを取得してみましょう。\n# %%\nbm2 = df2._data\nprint(bm2)\nBlockManager\nItems: Index(['x', 'y', 'e', 'int_var'], dtype='object')\nAxis 1: RangeIndex(start=0, stop=100, step=1)\nFloatBlock: slice(0, 3, 1), 3 x 100, dtype: float64\nIntBlock: slice(3, 4, 1), 1 x 100, dtype: int64\n今度は、IntBlockという欄が新たにできました。この欄を読み解くと、第3変数のint_varは１行100列のNumPy配列に格納されており、その数値型はint64であることが分かります。\n\n\n\nblockmanager\n\n\nこのように、数値型が異なる変数のデータは異なるNumPy配列に格納されています。実際、次のようにしてxとint_varのデータがメモリを異にすることが分かります。\n# %%\ndf2.x.values.base is df2.int_var.values.base\n# 出力\nFalse\n同じ数値型のデータが同じブロック(2次元NumPy配列)に格納されていることから、データ型が同じ変数であれば、列方向の計算も、かなりのパフォーマンスで実行できることが分かります。"
  },
  {
    "objectID": "programming2025/programming-10.html#データのチェック",
    "href": "programming2025/programming-10.html#データのチェック",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "データフレームを作成したら、本格的な分析にとりかかるまえに、まず始めにデータを精査すべきです。データを精査するプロセスには、様々な作業が含まれますが、例えば以下のような作業は有効でしょう。\n\n読み込んだデータの閲覧\n各変数の型のチェック\n欠測値の有無のチェック\n各変数の分布のチェック\n各変数の要約統計量の計算\n\nこのうち、欠測値の有無のチェックについては、多少難しい操作になるので、後に回し、ここでは1,2,4,5を説明します。\n\n\n例えば文字列データを読み込んだ際に文字化けが無かったか、などをチェックするのに役立ちます。データの閲覧は、単純にprintでデータを出力してみるのが最も簡単な方法です。\nそのほか、以下のようなメソッドも有効でしょう。\n\n\n\nメソッド\n機能\n用例\n\n\n\n\nhead\n先頭の指定した行数だけ表示\ndf.head(20)\n\n\ntail\n末尾の指定した行数だけ表示\ndf.tail(20)\n\n\n\nheadおよびtailの行数指定はオプションであり、指定しない場合は5行表示します。\n# %%\nprint(df.tail())\ndf.tail()だけでも良いのですが、そうするとHTML加工されて出力されるので、ここでは書面の都合上print関数を使いました。\n# 出力\n           x          y         e\n95  5.555309  12.561268  0.450651\n96  7.392817  15.309035 -0.476600\n97  5.652623   9.026150 -3.279095\n98  9.652547  21.696433  1.391339\n99  9.700645  15.425901 -4.975388\nまた、特定の列だけ取得する方法には、様々な方法があります。\n\n\n\n記法\n機能\n型\n\n\n\n\ndf['x']\nxの列だけ取得\nSeries\n\n\ndf[['x']]\nxの列だけ取得\nDataFrame\n\n\ndf[['x','y']]\nx、yだけのデータを取得\nDataFrame\n\n\ndf.x\nxの列だけを取得\nSeries\n\n\ndf.loc[:,'x']\nxの列だけを取得\nSeries\n\n\ndf.loc[:,['x']]\nxの列だけを取得\nDataFrame\n\n\ndf.iloc[:,0]\n第0列だけを取得\nSeries\n\n\ndf.iloc[:,[0,1]]\n第0、1列だけのデータを取得\nDataFrame\n\n\n\n記法によって、得られるデータがSeries型の場合とDataFrame型の場合があるので、多少注意が必要です。\nlocやilocの使い方については、後でインデクシングとスライスの説明を行う際に解説します。\n\n\n\nデータフレームに読み込んだ変数のデータ型をチェックするには、データフレームのdtypes属性を表示します。\n# %%\nprint(df.dtypes)\n# 出力\n\nx    float64\ny    float64\ne    float64\ndtype: object\nこれを見ると分かるように、意図したようにx、y、eが全て64ビット浮動小数点数として格納されていることが分かります。\nこのチェックによって、たとえば、xがオブジェクト型(object)などとして読み込まれていたりした場合は、xに数値以外のものがうっかりと混じってしまっていた可能性があります。あるいはデータをファイルから読み込んだ場合は、ファイルのオープンで何らかのトラブルがあった可能性があります。\n\n\n\n各変数の分布のチェックをするには、ヒストグラムをプロットするのが一番分かりやすい方法です。データフレームには、histという全ての変数のヒストグラムをプロットするメソッドがあります。\n# %%\ndf.hist()\n出力は以下のようになります。\n\n\n\nhist\n\n\nこれにより、分布の形状に際立った特徴がないか、例えば母集団がマルチモーダルになっている可能性はないか、といった考察ができます。\n\n\n\npandasデータフレームには、要約統計量を計算する便利なメソッドが揃っています。一番最初に試してみるべきメソッドは、describeでしょう。これはRデータフレームのsummaryメソッドに対応するものです。\n# %%\nprint(df.describe())\n# 出力\n\n                x           y           e\ncount  100.000000  100.000000  100.000000\nmean     8.163830   17.621354    0.293695\nstd      1.799021    4.655073    2.761058\nmin      3.585058    5.838924   -8.185457\n25%      6.978835   13.910635   -1.225525\n50%      8.033164   17.570366    0.264505\n75%      9.653371   20.953255    2.130415\nmax     12.579820   27.685974    6.796562\n出力された各要約統計量の意味は次の通りです。\n\n\n\n統計量\n意味\n\n\n\n\ncount\nオブザベーション数\n\n\nmean\n平均値\n\n\nstd\n標準偏差\n\n\nmin\n最小値\n\n\n25%\n25%分位点\n\n\n50%\n50%分位点\n\n\n75%\n75%分位点\n\n\nmax\n最大値\n\n\n\nなお、こちらのstdはNumPyと異なり、自由度のデフォルトはN-1ですのでご注意ください。\n自由度を変えたい場合は、独立にstdメソッドやvarメソッドを呼び出し、オプション引数ddofを設定する必要があります。\n#%%\n# 自由度をNにした分散と標準偏差\nprint('Var:')\nprint(df.var(ddof=0))\nprint()\nprint('Std:')\nprint(df.std(ddof=0))\n# 出力\nVar:\nx     3.204111\ny    21.453009\ne     7.547206\ndtype: float64\n\nStd:\nx    1.790003\ny    4.631739\ne    2.747218\ndtype: float64\nパーセンタイルをカスタマイズしたい場合は、describeメソッドのpercentiles引数にパーセンタイルをリストで渡します。たとえば2.5%、50%、97.5%を出力したいときは、次のようにします。\n# %%\nprint(df.describe(percentiles=[0.025,0.5,0.975]))\n                x           y           e\ncount  100.000000  100.000000  100.000000\nmean     8.163830   17.621354    0.293695\nstd      1.799021    4.655073    2.761058\nmin      3.585058    5.838924   -8.185457\n2.5%     4.984007    8.015538   -5.119716\n50%      8.033164   17.570366    0.264505\n97.5%   11.348816   26.412084    5.619012\nmax     12.579820   27.685974    6.796562\n相関行列を計算するには、corrメソッドが使えます。\n# %% ピアソンの積率相関係数\nprint(df.corr(\"pearson\"))\n引数には”pearson”(ピアソン積率相関係数)、“kendall”(ケンドール順位相関係数)、“spearman”(スピアマン順位相関係数)が選べます。\n# 出力\n          x         y         e\nx  1.000000  0.805777  0.055381\ny  0.805777  1.000000  0.635935\ne  0.055381  0.635935  1.000000\n他にも様々なメソッドやオプション引数がありますので、pandasのリファレンスマニュアルをチェックしてみてください。"
  },
  {
    "objectID": "programming2025/programming-10.html#可視化の方法概観",
    "href": "programming2025/programming-10.html#可視化の方法概観",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "Pythonでデータや分析の結果を可視化するには、matploblibモジュールを使うのが最もポピュラーです。筆者が把握する限り、matplotlibを用いるには、主に3つの方法があります。\n\nmatplotlibを直接操作する\npandasデータフレームからmatploblibを呼び出す\nSeabornからmatplotlibを呼び出す\n\nmatplotlibは非常に低水準なグラフ描画機能を提供するので、柔軟性は高いですが、綺麗なグラフをmatplotlibで手作りするのは中々骨が折れます。\nSeabornはmatplotlibのインターフェースを高水準にしたもので(こういうものをラッパーと呼びます)、柔軟性は低いですが、非常に簡単にきれいなグラフを作成できるという特徴があります。しかしながら、詳細なカスタマイズをしようと思うと、最終的にはmatplotlibをいじらないといけません。細部にこだわらない普段使いには十分であるような気がします。\npandasデータフレームからmatplotlibを呼び出すのは、matplotlibを直接操作するのと対して変わりありませんが、幾分インターフェースが簡略化されて使いやすくなっています。データフレームのメソッドなので、データにアクセスしやすくなっています。こちらについても、詳細な設定はmatplotlibに立ち返らないといけません。\n(なお、PythonでもRのggplotを使うことはできます。筆者はほとんど使ったことがありませんが、操作感がよいとは言えない印象があります。どなたかレビューお願いします。筆者の場合、そもそもggplotを使いたいなら、最初からRを使います。)\nこのように、Rの可視化部門が実質ggplot2に一元化されているのに対し、Pythonの可視化部門は若干散らかっている印象があります。改めて見ると、ggplot2が優れているのは、非常に高水準なインターフェースと、極めて低水準な操作を両立している点ではないでしょうか。要するに、多少雑で良いなら簡単に様々なグラフが作れるが、頑張ればいくらでも美しく加工できるということです。\nさて、Pythonに話を戻しましょう。筆者としては、グラフの大枠はpandasやSeabornで作成し、細かい微調整についてはmatplotlibを直接操作するというのが良いのではないかと思います。今回の講義はpandasの説明が中心ですので、データフレームのメソッドを介して可視化する方法を中心に説明します。"
  },
  {
    "objectID": "programming2025/programming-10.html#matplotlibのフォント設定",
    "href": "programming2025/programming-10.html#matplotlibのフォント設定",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "matplotlibのデフォルトのフォントでは日本語が文字化けしてしまうため、まずフォントの設定を行う必要があります。\n次のように、matplotlibをインポートしてフォントを日本語フォントに変えましょう。Windowsでは”MS gothic”や”MS mincho”、“Meiryo”がありますが、ここでは”Meiryo”にしておきましょう。\n# MS ゴシックに変更\nimport matplotlib\nmatplotlib.rcParams['font.family'] = 'Meiryo'\nまた、上記のやり方では、毎回の起動時にフォントを設定する必要があります。起動時のデフォルトのフォントを変更する方法もあります。\nフォント周りの設定は本質的でなくごちゃごちゃした事項になるので、チートシートを別に作りました。参考にしてください。"
  },
  {
    "objectID": "programming2025/programming-10.html#散布図のプロット",
    "href": "programming2025/programming-10.html#散布図のプロット",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "散布図をプロットするには、データフレームのplot.scatterメソッドを使います。\n# %%\ndf.plot.scatter(x='x',y='y')\n出力は以下のようになります。\n\n\n\nscatter1\n\n\nオプション引数をつけることによって、様々な微調整が可能です。\n\n\n\nオプション引数\n意味\n\n\n\n\ns\nマーカーサイズ\n\n\nc\nマーカー色\n\n\nmarker\nマーカー形状\n\n\nxlim\n横軸範囲\n\n\nylim\n縦軸範囲\n\n\nfontsize\nフォントサイズ\n\n\n\nこれらのオプション引数は、例えば次のように使用します。\n# %%\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n軸ラベルを変更するのは、少し手間がかかります。まずmatplotlibのサブモジュールpyplotをインポートします(慣習として、pltという名前で読み込みます)。次に、pyplotモジュールのxlabel関数とylabel関数で軸ラベルとそのサイズを次のように変更できます。\n# %%\nimport matplotlib.pyplot as plt\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\nまた、グラフ上下左右のマージンを設定するには、\n# %%\nplt.subplots_adjust(left=0.2,bottom=0.2)\nのように指定します。\nここで注意しなくてはならないのは、VS Codeの対話的モードで図を描く場合、図を描く関数の呼び出しと、図を調整する関数plt.xlabel等の呼び出しは、次のように全て同じセルで行わなくてはならないということです(importは別のセルで構いません)。\n# %%\nimport matplotlib.pyplot as plt\n\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\nplt.subplots_adjust(left=0.2,bottom=0.2)\n出力は次のようになります。\n\n\n\nscatter2\n\n\n全てのマーカー形状と全ての色名は以下のmatplotlibのサイトにリストアップされています。\n\n全てのマーカー形状\n全ての色名\n\nまた、plot.scatterメソッドの詳細な使い方はpandasのリファレンスを見てください。"
  },
  {
    "objectID": "programming2025/programming-10.html#色の微調整",
    "href": "programming2025/programming-10.html#色の微調整",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "マーカーの色はRGBもしくはRGBAでも指定可能です。RGBは、赤・緑・青の強さを0～1の数値で表したものです(0～255の1バイト整数で表すことも多いです)。三つの数値をタプルで表します。たとえば、\n(0,0,1)\nは青原色となります。\nまた、RGBAは、RGBに加えて、第4の数値が不透明度を0～1で表します。1が最も不透明で、0が透明です。\nmatplotlibでは、colors.to_rgbおよびcolors.to_rgba関数によって色名からRGB値およびRGBA値を取得できます。\n# \"coral\"のRGBA値を取得\nrgba_coral = matplotlib.colors.to_rgba(\"coral\")\nprint(rgba_coral)\n# 出力\n\n(1.0, 0.4980392156862745, 0.3137254901960784, 1.0)\nたとえば、このRGBA値のアルファ値を少し減じてやることによって、透明度のある”coral”を作ることができます。\n# %%\nrgba_coral_tr = rgba_coral[0:3] + (0.6,)\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\ncolor=rgba_coral_tr,            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\nplt.subplots_adjust(left=0.2,bottom=0.2)\n結果は次のようになります。\n\n\n\nscatter3\n\n\nただし、RGB値やRGBA値を渡す場合は、引数名はcではなくcolorにしてください。"
  },
  {
    "objectID": "programming2025/programming-10.html#回帰直線のプロット",
    "href": "programming2025/programming-10.html#回帰直線のプロット",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "それでは次に、単回帰の結果を散布図に重ねましょう。まずは回帰分析を再実行しておきます。\n# %%\n# 回帰分析\nfrom scipy import stats\nres = stats.linregress(df.x,df.y)\nprint(res)\nここで、データフレームdfの変数xの配列と変数yの配列にアクセスするために、df.x、df.yという表記を用いていることに注意してください。このように、データフレームでは、df.変数名という表記によって、各列を取り出すことができます。\n# 出力\nLinregressResult(slope=2.084996965456381, intercept=0.5997940915043358, rvalue=0.8057774353709972, pvalue=5.010945582964262e-24, stderr=0.15479582428347563, intercept_stderr=1.2937470389108192)\ninterceptが切片、slopeが回帰係数であることに注意してください。\n次に、この結果を用いて、回帰モデルの予測値を与えるデータフレームを用意しましょう。\nまず、x_modelを予測用のサンプルデータ点を表すNumPy配列にします。これは、グラフの定義域をカバーしていればどんな配列でもよいのですが、ここでは、3～13の範囲を100分割した数列にしておきましょう。このような操作には、NumPyのlinspace関数を使います。\n# %%\nx_model = np.linspace(3,13,100)\nprint(len(x_model))                 # 配列の長さ\nprint(np.round(x_model[:3],3))      # 最初の3要素\nprint(np.round(x_model[-3:],3))     # 最後の3要素\nlinspaceの引数は、それぞれ、開始数値、終端数値、分割数です。\n# 出力\n100\n[3.    3.101 3.202]\n[12.798 12.899 13.   ]\n次に、y_modelを、yの予測値を与える配列とします。これは、回帰分析の結果を用いて次のように計算できます。\n# %%\ny_model = res.intercept + res.slope * x_model\nこれを用いて、100オブザベーションについての予測値を格納したデータフレームdf_modelを次のように作成しておきます。\n# %%\ndf_model = pd.DataFrame({'x':x_model,'y':y_model})\nprint(df_model)\n# 出力\n\n           x          y\n0    3.00000   6.854785\n1    3.10101   7.065391\n2    3.20202   7.275996\n3    3.30303   7.486602\n4    3.40404   7.697208\n..       ...        ...\n95  12.59596  26.862332\n96  12.69697  27.072937\n97  12.79798  27.283543\n98  12.89899  27.494149\n99  13.00000  27.704755\n\n[100 rows x 2 columns]\nこの予測値のデータフレームで、x横軸、y縦軸の折れ線グラフを描けば、回帰直線になっているはずです。回帰直線には、データフレームのplot.lineメソッドを使います。linestyle引数で線の種類、linewidthで線の太さを設定できます。\n# %%\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',\ncolor='grey',\nlinewidth=3\n)\nscatterと同じく様々な微調整が可能ですが、ここでは後で散布図と重ねることを考慮して、微調整は行わないことにします。\n出力は以下のようになります。\n\n\n\nlinear_pred\n\n\nなお、全ての線の種類のリストは以下で調べることができます。\n\n線の種類一覧"
  },
  {
    "objectID": "programming2025/programming-10.html#回帰直線と散布図のオーバレイ",
    "href": "programming2025/programming-10.html#回帰直線と散布図のオーバレイ",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "それでは、最後に、上で作成した散布図と回帰直線をオーバレイ(重ね描き)してみましょう。まずは、オーバレイせずにそのまま二つのグラフを打ち出すだけのコードを書いてみます。\n以下のようになりますが、これまで作成したコードを合わせただけなので、特に説明はいらないでしょう。\n# %%\ndf.plot.scatter(x='x',y='y',\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',     # 線種\ncolor='grey',           # 線色\nlinewidth=3             # 線幅\n)\n\nplt.xlabel('Xの値',size=18) # X軸ラベル\nplt.ylabel('Yの値',size=18) # Y軸ラベル\nplt.subplots_adjust(left=0.2,bottom=0.2) # マージン\nふたつのグラフを重ねるには、以下のように一つ目のグラフの戻り値を、二つ目のグラフのax引数に渡します。\n# %%\nax = df.plot.scatter(x='x',y='y', # 戻り値をaxに\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',     # 線種\ncolor='grey',           # 線色\nlinewidth=3,            # 線幅\nax=ax,                  # 一つ目のグラフの戻り値\nlegend=False            # レジェンドを削除\n)\n\nplt.xlabel('Xの値',size=18) # X軸ラベル\nplt.ylabel('Yの値',size=18) # Y軸ラベル\nplt.subplots_adjust(left=0.2,bottom=0.2) # マージン\n出力は次のようになります。ここでは、ついでに二つ目のグラフのレジェンドを削除しておきました。\n\n\n\nregress"
  },
  {
    "objectID": "programming2025/programming-10.html#seabornの活用",
    "href": "programming2025/programming-10.html#seabornの活用",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "上記では、まず回帰分析を行ってから、その結果を散布図に重ねるという作業を行いましたが、Seabornモジュールのregplotメソッドを用いると、回帰直線と信頼区間を自動で挿入してくれます。\nSeabornのモジュール名はseabornですが、snsの別名で読み込むのが慣習となっていますので、それに従いましょう。\n# %%\nimport seaborn as sns\n# %%\nsns.regplot(x=df.x,y=df.y,\n    color='black',\n    marker='x',\n    scatter_kws={'s':10})   # マーカーサイズ\n\nplt.tick_params(labelsize=14)   # 軸数値のサイズ\nplt.xlim((3,13))\nplt.ylim((4,30))\nplt.xlabel('Xの値',size=18)\nplt.ylabel('Yの値',size=18)\n\nplt.subplots_adjust(left=0.2,\n    bottom=0.2)\n\n\n\nregplot\n\n\n本講義では、Seabornの詳しい解説はしませんが、興味がある方はリファレンスマニュアルを参照してください。"
  },
  {
    "objectID": "programming2025/programming-10.html#グラフの保存",
    "href": "programming2025/programming-10.html#グラフの保存",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "可視化の締めくくりとして、グラフのファイルへの保存について説明しておきます。グラフの保存は、matplotlib.pyplotのsavefig関数によって行います。やはり、グラフを描画したセル内部で保存をする必要があります。\n# %%\nax = df.plot.scatter(x='x',y='y', # 戻り値をaxに\ns=30,                   # マーカーサイズ\nc='skyblue',            # マーカーの色\nmarker='o',             # マーカーの形\nxlim=(3,13),            # x軸の範囲\nylim=(4,30),            # y軸の範囲\nfontsize=12             # 軸目盛のフォントサイズ\n)\n\ndf_model.plot.line(x='x',y='y',\nlinestyle='dashed',     # 線種\ncolor='grey',           # 線色\nlinewidth=3,            # 線幅\nax=ax,                  # 一つ目のグラフの戻り値\nlegend=False            # レジェンドを削除\n)\n\nplt.xlabel('Xの値',size=18) # X軸ラベル\nplt.ylabel('Yの値',size=18) # Y軸ラベル\nplt.subplots_adjust(left=0.2,bottom=0.2) # マージン\n\nplt.savefig('linregress.png',\ndpi=300,\nfacecolor='white')\n最後の一行でグラフを’linregress.png’というPNGファイルに保存しています。ここでは、背景を白色にするためにfacecolor引数に’white’を指定し、解像度を300dpiに設定しました。\nエクスプローラで’linregress.png’を探して表示できるかどうか試してみてください。"
  },
  {
    "objectID": "programming2025/programming-10.html#インデクシングとスライス",
    "href": "programming2025/programming-10.html#インデクシングとスライス",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "データフレームの一部を取り出すには、様々な方法があります。\n\nインデックス番号による参照\nラベルによる参照\nスライスによる参照\nブールインデックス参照\nファンシーインデックス参照\n\nいずれの方法でも、locとilocという二つのインデクサを用いることになります。\n\n\nインデックス番号でデータフレームの要素にアクセスするには、ilocを使います。iloc[i,j]でi行j列の要素を意味します。\n# %%\nprint(df.head())\nprint(\"\\ndf.iloc[2,1]:\")\nprint(df.iloc[2,1])\n# 出力\n\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.iloc[2,1]:\n21.25991325823923\n\n\n\n変数ラベルを用いて要素にアクセスしたい場合は、ilocの代わりにlocを使う必要があります。\n# %%\nprint(df.head())\nprint(\"\\ndf.loc[3,'x']:\")\nprint(df.loc[3,'x'])\n# 出力\n\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.loc[3,'x']:\n8.387948838265226\n\n\n\nilocにスライス記法を使えば、データフレームの一部をスライスで取り出せます。\n# %%\nprint(df.head())\nprint(\"\\ndf.iloc[0:3,1]:\")\ndata_slice = df.iloc[0:3,1]\nprint(data_slice)\nprint(type(data_slice))\n# 出力\n\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.iloc[0:3,1]:\n0    11.496212\n1    20.503193\n2    21.259913\nName: y, dtype: float64\n&lt;class 'pandas.core.series.Series'&gt;\n上記のように、スライスで気を付けないといけないのは、列番号を単一数値にすると、データフレームではなくSeriesオブジェクトになって返されるということです。\nデータフレームを返して欲しい場合は、以下のように単一要素でもスライスもしくはリストにしてインデクサに渡す必要があります。\n# %%\nprint(df.head())\nprint(\"\\ndf.iloc[0:3,1:2]:\")\ndata_slice = df.iloc[0:3,1:2]\nprint(data_slice)\nprint(type(data_slice))\n# 出力\n           x          y         e\n0   6.021757  11.496212 -1.547303\n1   7.264427  20.503193  4.974340\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n\ndf.iloc[0:3,1:2]:\n           y\n0  11.496212\n1  20.503193\n2  21.259913\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n\n\n\nlocインデクサを用いれば、列名にもスライスが使用可能です。\n# %%\ndf_xy = df.loc[:,'x':'y']\nprint(df_xy)\n# 出力\n            x          y\n0    6.021757  11.496212\n1    7.264427  20.503193\n2   10.575851  21.259913\n3    8.387949  13.625766\n4    9.840462  19.837310\n..        ...        ...\n95   5.555309  12.561268\n96   7.392817  15.309035\n97   5.652623   9.026150\n98   9.652547  21.696433\n99   9.700645  15.425901\n\n[100 rows x 2 columns]\nここで、locインデクサのスライスは若干記法が特殊であることに注意してください。番号によるスライスとは違って、'x':'y'と書くと、yの列も含まれたデータフレームが得られます。\nこれは行インデックスでも同じです。locインデクサで行をスライスするときは、1:4とかくと、4行目も含まれたデータフレームが得られます。\n\n\n\nブールインデックス参照とは、行数あるいは列数に等しい長さをもったブール値の配列を用いてデータフレームの一部を取り出すことです。データ分析で非常に頻繁に用いる手法ですので、必ず覚えておきましょう。\nたとえば、xの値が8以上になっているオブザベーションだけを取り出したいとします。このような場合、以下のようなブールインデックス参照が有効です。\n# %%\ndf_xgt8 = df.loc[df.x&gt;=8,:]\nprint(df_xgt8.head())\nnp.all(df_xgt8.x &gt;= 8)       # 全て8以上か確認\n# 出力\n\n           x          y         e\n2  10.575851  21.259913 -0.891788\n3   8.387949  13.625766 -4.150131\n4   9.840462  19.837310 -0.843614\n5   9.154208  20.388477  1.080062\n7   9.083904  25.964371  6.796562\nTrue\nブールインデックス参照に慣れていないと、これは何をやっているのか分からないでしょう。\n上の記法を理解するため、まずインデクサに渡したdf.x&gt;=8が何を意味するのか考えてみます。\ndf.x &gt;= 8\nこの二項演算において、左辺はSeries型配列、右辺は8というスカラですが、ブロードキャストが起きて右辺は左辺と同じ長さ100のSeries型配列に変換されます。これはNumPy配列の場合と全く同じです。\nそのあと、項ごとに二項演算&gt;=が実行され、結果はTrueとFalseの長さ100の配列になります。\n実際に結果を見てみましょう。\n# %%\nprint(df.x&gt;=8)\nprint(type(df.x&gt;=8))\n# 出力\n\n0     False\n1     False\n2      True\n3      True\n4      True\n      ...  \n95    False\n96    False\n97    False\n98     True\n99     True\nName: x, Length: 100, dtype: bool\n&lt;class 'pandas.core.series.Series'&gt;\nこのSeries配列では、x&gt;=8が成り立つところではTrue、成り立たないところではFalseになっていることに注意してください。\npandasのデータフレームは、こうしたブール値配列をlocインデクサに渡すと、Trueが成り立っている行だけを返してくれるという機能を持っています。こうしたブール値配列を用いた部分データの取得をブールインデックス参照と呼びます。pandasに限らずデータフレームを扱う大抵のツールで提供されている機能です。\nブールインデックス参照を用いると、複雑な条件を満たすオブザベーションだけを容易に取り出すことができます。\nたとえば、x&gt;=8かつy&lt;20を満たす行だけを取り出してみましょう。この場合、次のようにします。\n# %%\ndf_x8y20 = df.loc[(df.x&gt;=8) & (df.y&lt;20),:]\nprint(df_x8y20.head())\nprint(df_x8y20.shape)\n# 出力\n\n            x          y         e\n3    8.387949  13.625766 -4.150131\n4    9.840462  19.837310 -0.843614\n14  10.000539  19.061887 -1.939190\n21   9.655843  19.544249 -0.767437\n24   9.509539  19.163218 -0.855860\n(21, 3)\nここで重要なポイントが二つあります。\n\n二つの条件を繋ぐときは、各条件を丸カッコで囲む\n二つのブール値配列のANDは、andではなく&をつかう\n\nこれらの2点を見落としがちですので気を付けましょう。andはスカラーの間の論理積には使えますが、配列の間の論理積には使えません。代わりに&を使います。\n同様に、論理和ORは|、否定には~を使います。\n\n\n\n最後にファンシーインデックス参照は、取り出したいインデックス番号のリストや配列をインデクサに渡す方法です。たとえば、0、2、4行目だけを取り出したいときは、次のようにします。\n# %%\ndf_fancy = df.iloc[[0,2,4],:]\nprint(df_fancy.head())\n# 出力\n           x          y         e\n0   6.021757  11.496212 -1.547303\n2  10.575851  21.259913 -0.891788\n4   9.840462  19.837310 -0.843614\nなお、これまでの様々なインデクシングの記法は、組み合わせて使うことができることに注意しましょう。たとえば変数xとeの1～4行目を取り出したいときは次のようにします。\n# %%\ndf_comb = df.loc[1:4,['x','e']]\nprint(df_comb)\n# 出力\n           x         e\n1   7.264427  4.974340\n2  10.575851 -0.891788\n3   8.387949 -4.150131\n4   9.840462 -0.843614"
  },
  {
    "objectID": "programming2025/programming-10.html#欠測値",
    "href": "programming2025/programming-10.html#欠測値",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "pandasでは、従来欠測値はnp.nanオブジェクト(NaNとも表記されます)で表されてきました。np.nanは”Not a Number”を意味しており、NumPy配列における値の欠測を表現するために使われます。NaNは浮動小数点型なので、一つの配列内でint型と混在させることはできません。\nたとえば下記のように、int64型の配列にNaNを代入すると、エラーが出ます。\n# %%\n# 整数配列にNaNを入れてみる\narr = np.arange(10,dtype=np.int64)\nprint(arr.dtype)\narr[0] = np.nan\n# 出力\nint64\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n\n...(中略)...\n\n      56 arr = np.arange(10,dtype=np.int64)\n      57 print(arr.dtype)\n----&gt; 58 arr[0] = np.nan\n\nValueError: cannot convert float NaN to integer\nたとえば、先ほど作成したデータフレームdf2をコピーしてdf3という新しいデータフレームを作成し、欠測値を挿入してみましょう。\n# %%\ndf3 = df2.copy()\nここでは、変数xの第3オブザベーション(0からカウントして)と変数yの第2オブザベーションにNaNを入れてみましょう。\n# %%\ndf3.loc[3,'x'] = np.nan\ndf3.loc[2,'y'] = np.nan\nprint(df3.head())\n# 出力\n\n           x          y         e  int_var\n0   6.021757  11.496212 -1.547303        0\n1   7.264427  20.503193  4.974340        1\n2  10.575851        NaN -0.891788        2\n3        NaN  13.625766 -4.150131        3\n4   9.840462  19.837310 -0.843614        4\n上記のとおりNaNは”NaN”と表示されます。\nこういった欠測値をどのように取り扱うかべきかは、場合によりますが、いずれにせよ欠測が存在していることを確認することは重要です。\n\n\n\n欠測が少ない場合は、欠測を含む行を全て除去する対処法が考えられます。これをリストワイズ除去と呼び、欠測に対処する方法の中では最も原始的なものです。\nデータフレームのdropnaメソッドを使うと、リストワイズ除去したデータフレームが返されます。\n# %%\ndf3_dropnan = df3.dropna()\nprint(df3_dropnan.head())\n# 出力\n\n          x          y         e  int_var\n0  6.021757  11.496212 -1.547303        0\n1  7.264427  20.503193  4.974340        1\n4  9.840462  19.837310 -0.843614        4\n5  9.154208  20.388477  1.080062        5\n6  6.727073  13.750969 -0.703176        6\nなお、逆に欠測に値を代入するときは、fillnaメソッドが使えます。たとえば、欠測に平均値を代入する場合は、次のようにします。\n# %%\ndf3_fillnan = df3.fillna(df3.mean())\nprint(df3.mean())\nprint(df3_fillnan.head())\n# 出力\n\nx           8.161566\ny          17.584601\ne           0.293695\nint_var    49.500000\ndtype: float64\n           x          y         e  int_var\n0   6.021757  11.496212 -1.547303        0\n1   7.264427  20.503193  4.974340        1\n2  10.575851  17.584601 -0.891788        2\n3   8.161566  13.625766 -4.150131        3\n4   9.840462  19.837310 -0.843614        4\nなお、pandasには整数の欠測を表現できるpandas.NAという型も存在していますが、こちらについては本講義では割愛します。"
  },
  {
    "objectID": "programming2025/programming-10.html#csvの読み書き",
    "href": "programming2025/programming-10.html#csvの読み書き",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "pandasは、CSVとデータフレームの間で直接読み書きができるようになっています。まずは、今回の講義で作成したデータフレームdfをCSVに保存してみましょう。\nCSVへの保存には、to_csvメソッドを使います。\n# %%\ndf.to_csv('pandas.csv',\n    encoding='utf-8',\n    index=False)  # 行インデックスなし\nここでは、’pandas.csv’という名前のファイルに、utf-8エンコーディングで保存しました。indexオプション引数をFalseにして、行インデックスはCSVに含めないようにしました。\nVS CodeにCSV関連の拡張機能(Edit CSV、Rainbow CSV等)をインストールしていればCSVが閲覧できるはずですので、ファイルエクスプローラで見つけて開いてみましょう。\n次は逆に、先ほど保存したCSVを別の名前のデータフレームに読み込んでみましょう。\n# %%\ndf4 = pd.read_csv('pandas.csv',\n    engine='python',\n    encoding='utf-8')\nengine引数はCSVの解析エンジンを設定するオプションですが、デフォルトで上手く読み込めない場合は、上のように\"python\"を指定すると上手くいくことが多いです。"
  },
  {
    "objectID": "programming2025/programming-10.html#まとめ",
    "href": "programming2025/programming-10.html#まとめ",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "今回の講義では以下の点について学びました。\n\nデータフレームの作成\nデータフレームの構造\nデータのチェック\n可視化\n様々なインデクシング\n欠測値の取り扱い\nCSVファイルの読み書き\n\n今回の講義では、非常に高度で豊富なpandasの機能のごく一部しか紹介できませんでした。例えばpandasデータフレームには、データをグループ分けしたり、複数のデータフレームを様々な方法で結合する機能が備わっていますが、こういった高度な話題については一切触れませんでした。可視化についても、ほんの一部の機能しか紹介していません。\npandasのリファレンスマニュアルやインターネット上の情報を探して、自分が必要な機能が実装されていないか調べてみてください。大抵、自分が期待していいる以上のことができることに気付くと思います。"
  },
  {
    "objectID": "programming2025/programming-10.html#参考書",
    "href": "programming2025/programming-10.html#参考書",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "BlockManagerに関する記事\n『Pythonによるデータ分析入門ーNumPy、pandasを使ったデータ処理』(Wes McKinney著、瀬戸山 雅人(翻訳)、小林 儀匡(翻訳)、滝口 開資(翻訳))(2018) オライリージャパン. ISBN-13 : 978-4873118451.\n\npandasデータフレームのデータ構造についての考察は、上記のBlockManagerに関する記事を大いに参考にしました。"
  },
  {
    "objectID": "programming2025/programming-10.html#宿題ホームワーク",
    "href": "programming2025/programming-10.html#宿題ホームワーク",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "データフレームdfのブロックマネージャdf._dataにはblocksという属性があり、データのブロックがタプル形式で保存されていることを確認してください。各ブロックのデータは、ブロックのvalues属性に格納されています。これがNumPyの配列であることを以下のようにして確認しなさい。また、これがdf.x.values.baseによりアクセスできる配列と同じオブジェクトであることを確かめてください。\n# %%\nfor block in df._data.blocks:\n    arr = block.values\n    print(type(arr))\nSeries型オブジェクトについて研究してください。NumPy配列と同様、Seriesのスライスは元のオブジェクトのビューであることを確認してください。\nデータフレームのデータを、変数xでソートするには、sort_valuesメソッドを次のように使います。実際に試してみてください。\n# %%\nx_sorted = df.sort_values(by='x')\n文字列データを含むデータフレームを作成してみてください。たとえば、次のようにすれば、xが8以上のオブザベーションを”High”、8未満を”Low”とする変数が作れます。’High’なオブザベーションだけを抽出して、各種要約統計量を計算してみてください。\ndf['height'] = 'Low'\ndf.loc[df.x&gt;=8,'height'] = 'High'\ngroupbyメソッドを使うと、groupbyオブジェクトを作成できます。このオブジェクトには、describe、mean、varなどの基本統計量をグループごとに計算するメソッドが備わっています。以下のように、試してみてください。\ngpb = df.groupby('height')\ngpb.describe()"
  },
  {
    "objectID": "programming2025/programming-10.html#補遺",
    "href": "programming2025/programming-10.html#補遺",
    "title": "第10回　pandas入門",
    "section": "",
    "text": "pandasのデータフレームは、デフォルトで一部の行しか表示しないようになっています。表示行数を設定することはできますが、この設定がちょっと分かりにくいので、ここで詳しく説明しておきましょう。\npandasのオプションは、get_optionメソッドもしくは、options属性から確認できます。表示行数に関連するのはmin_rowsオプションとmax_rowsオプションです。\n# get_optionメソッドによる表示\nprint(pd.get_option('display.min_rows'))\nprint(pd.get_option('display.max_rows'))\n# options属性によるアクセス\nprint(pd.options.display.min_rows)\nprint(pd.options.display.max_rows)\n# 出力\n20\n60\nこの２つのオプションは分かりにくいですが、「データフレームの行数がdisplay.max_rowsを超えた場合は、display.min_rows行だけ表示する」という意味です。従って、上記の場合、60オブザベーション以下のデータフレームは全ての行を表示しますが、61オブザベーション以上のデータフレームについては途中を省略して最初と最後の20オブザベーションだけを表示することになります。\n今の場合ですとデータフレームは100オブザベーションを含んでいますので、display.max_rowsを100行以上に設定すると、全ての行が表示されるようになります。\nまた、省略された場合の表示行数を増やしたい場合は、display.min_rowsを増やせばよいことになります。試しにdisplay.min_rowsを30に設定しましょう。オプションの設定は、set_option関数もしくは、options属性を変更することで行います。\n# %%\n# set_option関数を用いる場合\npd.set_option(\"display.min_rows\",30)\n# %%\n# options属性によるアクセス\npd.options.display.max_rows = 60\n# %%\n# データフレームの再表示\nprint(df)\n# 出力\n            x          y         e\n0    8.013504  18.317503  1.290495\n1    9.896525  22.444125  1.651074\n2   11.326705  26.724520  3.071111\n3    8.938435  18.402628 -0.474241\n4    6.862927  16.547593  1.821740\n5   10.850879  22.979716  0.277957\n6    9.264085  20.722213  1.194043\n7    6.849750  13.762926 -0.936575\n8   11.286648  22.471414 -1.101883\n9   10.799512  22.553242 -0.045781\n10   4.228583   7.170566 -2.286601\n11  11.212478  23.096968 -0.327989\n12   8.700634  17.235308 -1.165959\n13   6.341005  20.754819  7.072809\n14   8.717844  20.486063  2.050374\n..        ...        ...       ...\n85   7.623332  17.575759  1.329095\n86   8.119302  16.581371 -0.657233\n87   3.639397   3.949449 -4.329345\n88   6.937774  19.882245  5.006697\n89   3.661514  11.380440  3.057411\n90   5.775179  11.460086 -1.090272\n91   9.078126  19.656764  0.500513\n92   7.534294  13.864200 -2.204387\n93   8.182152  17.203746 -0.160558\n94  10.004772  20.587155 -0.422388\n95   8.927801  14.040083 -4.815520\n96   5.269992  15.510429  3.970445\n97  10.328037  20.252442 -1.403633\n98   8.183177  18.688349  1.321994\n99   5.729897  13.355884  0.896091\n\n[100 rows x 3 columns]"
  },
  {
    "objectID": "programming2025/cheatsheet.html",
    "href": "programming2025/cheatsheet.html",
    "title": "チートシート",
    "section": "",
    "text": "チートシート\n\nmatplotlib\n\nフォント一覧の取得\n設定ファイルの場所\n設定ファイルの書き方\n\n\n\n\n\n\n\nフォントマネージャのget_fontconfig_conts関数を実行することで、自分の環境で使用可能なフォント名の一覧のリストfont_namesが得られます。色々なサイトで解説されているかと思いますが、例えばこちらからいただいたコードは次のようになります。\n# %%\nimport matplotlib.font_manager as fm\nflist = fm.get_fontconfig_fonts()\nfnames = [fm.FontProperties(fname=name).get_name() for name in flist]\nなお、筆者のUbuntu 18.04では、NotoColorEmoji.ttfフォントがget_nameでエラーを出して上のコードがうまく行かなかったので、上記のflistからこのフォントだけを排除しなくてはなりませんでした。\nfont_managerはまだ不勉強なので、誰か原因が分かる人がいたら教えてください。\n\n\n\nmatplotlibの設定ファイルの場所は、\n# %%\nmatplotlib.matplotlib_fname()\nで取得できます。base環境だと、管理者しか編集できないと思います。\n\n\n\nfont.familyが書かれた行を探して#を消してコメントインします。\nfont.faimly = 'Meiryo'\nといったように、日本語フォントに変えればよいです。\nLinuxではこちらの説明などを参考に日本語フォントをインストールしてから、IPAexGothicなどにフォントを設定していただければよろしいです。"
  },
  {
    "objectID": "programming2025/cheatsheet.html#matplotlib",
    "href": "programming2025/cheatsheet.html#matplotlib",
    "title": "チートシート",
    "section": "",
    "text": "フォントマネージャのget_fontconfig_conts関数を実行することで、自分の環境で使用可能なフォント名の一覧のリストfont_namesが得られます。色々なサイトで解説されているかと思いますが、例えばこちらからいただいたコードは次のようになります。\n# %%\nimport matplotlib.font_manager as fm\nflist = fm.get_fontconfig_fonts()\nfnames = [fm.FontProperties(fname=name).get_name() for name in flist]\nなお、筆者のUbuntu 18.04では、NotoColorEmoji.ttfフォントがget_nameでエラーを出して上のコードがうまく行かなかったので、上記のflistからこのフォントだけを排除しなくてはなりませんでした。\nfont_managerはまだ不勉強なので、誰か原因が分かる人がいたら教えてください。\n\n\n\nmatplotlibの設定ファイルの場所は、\n# %%\nmatplotlib.matplotlib_fname()\nで取得できます。base環境だと、管理者しか編集できないと思います。\n\n\n\nfont.familyが書かれた行を探して#を消してコメントインします。\nfont.faimly = 'Meiryo'\nといったように、日本語フォントに変えればよいです。\nLinuxではこちらの説明などを参考に日本語フォントをインストールしてから、IPAexGothicなどにフォントを設定していただければよろしいです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html",
    "href": "programming2025/slide-programming-1.html",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "この授業では、主にPythonを扱っていくことにします。\nそれから、Rも少し扱っていきますが、Rについては、皆さんは統計学2や計量経済学（どちらも2年生科目)の授業で学んで来ているでしょうから、その基礎は押さえていると仮定し、いちいち復習はしません。\nたとえば、Rのベクトルやデータフレームがどういったものだったか忘れてしまっている人がいたら、復習しておいてください。\nそれから、if条件分岐やforループについて、構文を忘れてしまっている人は、思い出しておくと良いでしょう。\n\n\n\n\n\nさて、Pythonについては多くの方が名前くらい聞いたことがあるでしょう。\n以前はPythonの国内人気はいまいちでしたが、最近の機械学習ブームの波にのって人気が高まり、いまでは国内外問わず最もポピュラーなプログラミング言語となりました。\n従って、YouTubeなどに、初心者向けのPythonのわかりやすい解説動画がたくさんあり、また独学に適した日本語の参考書も次々と発売されています。\n\n\n\n\n\n独学のための良質の素材があふれているのであれば、なぜ本講義でわざわざプログラミング、そしてPythonを学ばなければならないのでしょうか。\n以下に、巷の教材に任せきってしまうことの問題を挙げてみましょう。\n\n独学では、モチベーションが沸かない。\n研究での活用がわかりにくい。\n表面的な説明が多く、Pythonの深いところがなかなか見えてこない。\n高度な内容をどうやって勉強したらいいのかわからない。\n\nつまり、とりあえずPythonを動かすことは独学で簡単にできるようになるのですが、そこから先（深ぼりしたり、応用したり）が見えにくいというのが筆者の見解です。\n\n\n\n\n\nでは、なぜPythonを深ぼりする必要があるのでしょうか？\n最も大きな理由は、それによって、応用力が身につくということです。\n本講義を通して、受講者はビットやバイトの言葉を直感的に使いこなせるようになると思います。\nそういった感覚は、長く使えるものです。\n言語の表面的な知識だけを身につけても、すぐに忘れてしまうでしょうし、Pythonが廃れたら役に立たないでしょう。\n\n\n\n\n\nもう一つの小さな理由は、Pythonが、深ぼりしないと間違いを冒すタイプの言語だということです。\n言い換えると、プログラムというものがどのように情報を扱っているのかをある程度理解しないと、Pythonを正しく使うことは難しいと言うことです。\nこれは良いニュースだと思います。\nなぜなら、Pythonを勉強することが、計算機科学の勉強につながるからです。\n\n\n\n\n\nこの点で、PythonはRとかなり違います。\nRは、プログラミングにそれほど精通していなくても使いやすく設計されています。\nRに慣れた学生の皆さんは、Pythonを学ぶことで、プログラミングというものが何なのか、より深い実感をもつことができるようになるでしょう。\n\n\n\n\n\n皆さんが本講義を通してPythonを学ぶに当たっては、以下の教材を有効活用することをおすすめします。\n\n\nPython公式ドキュメント\n『独習Python』(教科書)\n本サイト\n\n\n内容の網羅性で言うと、1&gt;2&gt;3です。\n本サイトではPythonの標準機能の一部しか紹介できませんので、足りない部分を2の教科書で補うことにします。\n\n\n\n\n\nさらに、プログラミングをしていると、教科書を含む一般向け書籍にはなかなか書かれていないようなことも時々調べなくてはなりません。\nそのような場合には、最終的には1のPython公式ドキュメントを当たらねばなりません。\nさらに、公式ドキュメントにも載っていないことは高度な専門書や、ネット上の非公式なドキュメントを参考にしたり、Stack Over Flowのようなサイトで検索・投書するか、自分で試行錯誤しなくてはなりません。\nまた、本講義はPythonの標準機能を説明するだけのものではありませんので上の教材だけでは不十分です。\n標準機能以外に関する補助的教材や参考資料については、適宜紹介することにします。\n\n\n\n\n\nそれでは前置きが長くなりすぎたので、そろそろPythonを動かしてみましょう。\nPythonを動かすには、様々な方法がありますが、まずはREPL(Read-Eval-Print Loop)を用いた対話的実行を行ってみましょう。\nウィンドウズを起動して、画面の左下の検索ウィンドウにAnacondaと打ち込んで、Anaconda Promptを起動しましょう（Anaconda Powershell Promptでも構いません）。\nAnacondaを起動したら、pythonと入力し、pythonの対話的インタープリタREPLを起動しましょう。\nプロンプトと呼ばれる\"&gt;&gt;&gt;\"記号が現れて、入力待ちの状態になるはずです。\n\n\n\n\n\nREPLは、Pythonのコードを1行ごとに評価し、即時にその結果を表示してくれるシステムです。\n小さなコード断片の挙動を確かめる際などに便利です。\nPythonには、整数や計算式などはそれ自体がPythonのコードと見なされるという特徴があります。\nそのおかげで、PythonのREPLを計算機として用いることができます。\nたとえば、何でも良いので、簡単な足し算や引き算をREPLに入力してみましょう。（入力の最後にはEnterキーを押します。）\n\n\n\n\n&gt;&gt;&gt; 1 + 1\n2\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 3 * 2\n6\n&gt;&gt;&gt; 8 / 2\n4.0\n&gt;&gt;&gt; 11 // 3\n3\n&gt;&gt;&gt; 11 % 3\n2\n&gt;&gt;&gt; 5 ** 3\n125\n\nこのように、REPLは簡単な計算機として用いることができます。なお、Pythonにおける2項算術演算子は以下の通りです。\n\n\n\n\n\n\n\n演算子\n機能\n\n\n\n\n+\n可算\n\n\n-\n減算\n\n\n*\n乗算\n\n\n**\nべき乗\n\n\n/\n除算\n\n\n//\n整数除算（余りを切り捨て）\n\n\n%\n剰余\n\n\n\n\n上記の表は教科書のセクション3.1にもありますので確認しておいてください。\n\n\n\n\n\nなお3つ以上の数の演算を行うには、演算子の優先順位に気を付けなければならないのはRと同じです。たとえば\n&gt;&gt;&gt; 2 + 3 * 5\n17\nのように掛け算は足し算よりも先に評価されます。演算子の評価順序を明確にしたいときは、丸カッコを使います。\n&gt;&gt;&gt; (2 + 3) * 5\n25\n演算子の優先順位については教科書のセクション3.6(pp. 107)に解説がありますので、読んでおいてください。\n\n\n\n\n\nただし、計算式においては、演算子の評価順序には過剰に頼り過ぎず、丸カッコを積極的に使うことをお勧めします。\nでないと、あとからコードを見返したときに、非常に理解しにくくなってしまうからです。\n\n\n\n\n\n次の計算をPythonで実行したらどのような結果が得られるかを予測しなさい。\n\n# Q1\n&gt;&gt;&gt;(5 % 3) ** (7 // 2)\n# Q2\n&gt;&gt;&gt;(5.5 - 2.5 + 3.0) * 2.0\n\n上記Q1, Q2の予測をREPLで確かめられたら、同じように様々な計算を自分で考えてREPLで実行し、予測と一致するか確かめなさい。\n\n\n\n\n\nそれでは、次にもう少し高度なことをしてみます。以下のように入力して、変数xに整数1を代入し、xの値を表示してみましょう。\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; x\n1\n\nこのように、‘=’記号を使うと左辺の変数に右辺の値を代入できます。(Rでは、同様の操作に’&lt;-’という矢印演算子を用いましたね。)\n\n\n\n\n\nそれでは、さらに変数を用いて色々な演算をしてみましょう。\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 2\n&gt;&gt;&gt; x + y + 3\n6\n&gt;&gt;&gt; z = y + 1\n&gt;&gt;&gt; x - z\n-2\n&gt;&gt;&gt; x = z ** y\n&gt;&gt;&gt; x\n9\n&gt;&gt;&gt; x = x - 1\n&gt;&gt;&gt; x\n8\n\n\n\n\nこのように、変数は演算の中で用いることができます。\nこれについてはRでもほとんど同じなので、細かい説明は不要でしょう。\n最後に”Hello, World!“を出力しておきましょう。\nこれについても、Rと全く同じですので、説明はほとんど要らないでしょう。(実際、Rのコードと見分けがつきません。)\n\n&gt;&gt;&gt; print(\"Hello, World!\")\nHello, World!\n\n\n\n\nRと同じように、ダブルクォーテーションでくくられた部分は、Pythonにより文字列と解釈されます。printは、引数に与えられた文字列や数を画面に出力するだけの関数です。\nREPLを終了してAnaconda promptに戻るときは、次のように入力します。\n\n&gt;&gt;&gt;exit()\n\n\n\n\nそれでは次に、Pythonのコードをファイルに保存してコマンドラインから実行する方法を試してみましょう。\nAnaconda promptで次のように入力してhello.pyというテキストファイルを作成します。\n\n(base) C:\\Users\\hogehoge&gt;notepad hello.py\n\n“hello.pyは存在しません。新しく作成しますか？”と聞かれたら「はい」を選択するとメモ帳が起動します。\nメモ帳で、ファイルの先頭行に次のような1行を記述してください。\n\nprint(\"Hello, World!\")\n\n\n\n\n次にファイルを保存して閉じ、Anaconda promptで次のように入力すると、ファイルに記述したPythonコードを実行することができます。\n\n(base) C:\\Users\\hogehoge&gt;python hello.py\nHello, World!\n\n\nなお、Pythonコードを記述するファイル（スクリプトと呼ぶ）の名前には拡張子.pyを付けるのが普通です。\n\n\n\n\n\nそれではもう一度同じファイルを開いて、もう少し中身を豪華にしてみましょう。\n\nprint(\"Hello, World!\")\nx = 1\ny = 2\nz = x + y\nprint(x)\nprint(y)\nprint(z)\n\n\n\n\nこれを実行すると、以下のようになります。\n\n(base) C:\\Users\\Kobayashi&gt;python hello.py\nHello, World!\n1\n2\n3\n\n\nこのように、Pythonでは、文を改行で区切って並べることにより、上から順番に文が実行されていきます。\n文については教科書のセクション1.5.2に詳しい説明があるので良く読んでおいてください。\n\n\n\n\n5の5乗を計算して画面に出力するpower5_5.pyというファイルを作成し、実行しなさい。\n\n\n\n\n遅くなりましたが、ここで本講義の目標を述べておきます。本講義の目標を箇条書きにすると以下のとおりです。\n\n\nPythonの設計思想を理解する\nメモリ(主記憶装置)のイメージができるようになる\nPythonで簡単なデータ解析ができるようになる\nPythonで簡単な社会科学実験のプログラムを作れるようになる\n\n\n\n\n\n上記では、「設計思想を理解する」という言葉に非常に多くの意味を込めました。\n設計思想は、言葉で説明されて分かるものではなく、Pythonを学ぶうちに、段々と見えてくる設計上のパターンやクセのようなものです。\nそういったパターンやクセは、設計者の理念をそのまま反映していることもありますし、そういった理念を追求した結果、仕方なく生じてしまった歪み、機能的制約、初学者が面食らってしまうような数々の奇妙な挙動や明らかな欠陥も含みます。\n\n\n\n\n\n設計思想が分かると、たとえば、Pythonの\n&gt;&gt;&gt; x = y\nとC言語の\nx = y;\nに対して、明確に違ったイメージを持つことができるようになります。\n設計思想が分かるというのは、世界観が出来上がるということでもあります。\nこれは多分、プログラミング言語も、自然言語と同じなのではないかと思います。\n\n\n\n\n\nある人を理解するということは、その人のスケジュールを全て覚えることではありません。\nそれと同じで、言語の設計思想を理解することは、関数や構文をたくさん覚えることではありません(そういうことは、ネットで検索すればよいのです)。\n設計思想を理解するというのは、新しい関数や構文に出会ったときに、『なるほどPythonらしいな』と思え、戸惑わないようになることです。\nそして、ある程度パターンが予測でき、変な行動をとっても怒らず、『まあ仕方ないね』と許せるようになることです。\n時々失敗するけれど、なぜ失敗なのか、すぐに分かるということです。\n\n\n\n\n\nさて、一見遠回りに見えますが、上記の1〜4は、どれも全て「応用」を念頭においていることを強調しておきたいと思います。\n設計思想が分からなかったり、メモリのイメージを持っていないと、ずっと「手探り」でプログラミングをすることになり、すぐに伸び悩むことになると思います。\nこれを機会にぜひ、ゆっくりパソコンに向かって様々な実験を繰り返し、あるいはStack overflowの数々の間違った情報に辟易し、ときにはデスクに向かって色々と計算してほしいと思います。\nそういったプロセスを踏んで、どんなプログラミング言語でも独力で学べるような基礎力を身に着けてほしいと思います。\n\n\n\n\n\nそれでは、まずプログラミングの準備として、プログラムといったものがどのように動いているのかといったことの簡単な説明から始めなくてはなりません。\n以下、座学になりますが、難しい数学などは出てきませんので、何卒お付き合いください。\n\n\n\n\n\n2進数や16進数については、多くの方が高校や大学で学んだことがあることでしょう。\nしかしながら、以降の説明で非常に重要ですので、ここでこれらの概念を簡単に復習しましょう。\nご存じの通り、私たちが普段使っている10で桁上がりする数字は、10進数と呼ばれます。\n\n\n\n\n\n一方、2で桁上がりする数を2進数、16で桁上がりする数を16進数と呼び、情報科学では10進数と並んで良く用いられる数の表し方です。\n2進数では、2で桁上がりするため、10進数における2～9の数字は現れません。\nまた、16進数では、10進数における09だけでは1桁を表すのに足りないため、afのアルファベットを用います。\n\n\n\n\n\n\n\n10進数\n2進数\n16進数\n\n\n\n\n0\n0\n0\n\n\n1\n1\n1\n\n\n2\n10\n2\n\n\n3\n11\n3\n\n\n4\n100\n4\n\n\n5\n101\n5\n\n\n6\n110\n6\n\n\n7\n111\n7\n\n\n8\n1000\n8\n\n\n9\n1001\n9\n\n\n10\n1010\na\n\n\n11\n1011\nb\n\n\n12\n1100\nc\n\n\n13\n1101\nd\n\n\n14\n1110\ne\n\n\n15\n1111\nf\n\n\n16\n10000\n10\n\n\n\n\n\n\n\nある数が2進数で表記されていることを明確にするため、2進数の先頭に0bという接頭辞を付けることがあります(bはbinaryより)。\n同様に16進数には接頭辞0xをつけます(xはhexadecimalより)。\nたとえば、0x1eは0b11110すなわち10進数での30を表します。\n10進数、2進数、16進数の間の変換に慣れておきましょう。とくに2進数と16進数の間の変換は重要です。\n\n\n\n\n\n10進数、2進数、16進数の間の変換は、Pythonを用いても行うことができます。\n次のPythonコードは、それぞれ、10進数の123を2進数、16進数に変換するものです。\n\n&gt;&gt;&gt; bin(123)\n'0b1111011'\n&gt;&gt;&gt; hex(123)\n'0x7b'\n\nこのように関数binとhexを使えば10進数をそれぞれ2進数、16進数に変換することができます。\n\n\n\n\n\nまた、逆の変換をするときは、次のように数字を入力するだけです。\n\n&gt;&gt;&gt; 0b1111011\n123\n&gt;&gt;&gt; 0x7b\n123\n\n\n\n\nパソコンは、様々な部品から構成されていますが、プログラミングの初心者がまず知っておかなければならないのが、CPUとメインメモリの働きです。\nメインメモリはランダムアクセスメモリ(Random Access Memory)とも呼ばれるので、RAMと表記されることもあります。\nCPUとメモリ(メインメモリ)は、記憶装置です。\nパソコンにはいくつもの記憶装置が内臓されていますが、どの記憶装置も、文字や整数や小数だけでなく、プログラムなど、すべての情報を0と1の配列に変換して記憶しています。\n\n\n\n\n\nCPUとメモリはどちらもトランジスタで構成された集積回路(IC, Integrated Circuit)ですが、次のような性質の違いがあります。\n\n\n\n\n\nCPU\nメモリ\n\n\n\n\n記憶容量\n非常に小さい\n大きい\n\n\n演算能力\n有り\n無し\n\n\n\n\n\n\n\nここで言う演算とは、足し算や引き算を含む様々な計算のことです。\nCPUは演算機能をもっていますが、ほんの少しの情報しか記憶できないので、CPUだけではちょっとしたプログラムも動かせません。\nそこで、まず容量の大きいメモリにプログラム全体を読み込ませます。プログラムは、CPUに対する命令の集まりです（と思って大体間違いありません）。\nCPUは、メモリに読み込んだ命令を１つずつ読み取って実行していきます。\n\n\n\n\n\nメモリは、たとえば001011010110001101011…のように、全ての情報を0と1の並びに変換して記憶しています。\nこの0と1の並びは、8桁ずつの区画に区切られています。\nそれぞれの区画には、アドレスと呼ばれる数字が振られていて、数字によってメモリ上の位置が指定できるようになっています。\nそれぞれの区画には、8桁の0と1が格納されているので、1つの区画は00000000から11111111までの256通りの状態を記憶することができます。\nこの記憶容量のことをバイト(Byte)といいます。一方、1桁の0と1で記憶できる容量のことをビット(bit)と呼びます。\nよって、1バイト = 8ビットの関係が成り立ちます。\n\n\n\n\n\nメモリへの情報の読み書きは、必ずバイトを単位として行われます。\nビットを単位として読み書きすることはできません。\nこのように、バイトはパソコンにおける最も重要な情報量の単位です。\n\n\n\n\n\n\n\nmemory\n\n\n\n\n\n\nメモリについて考えるときは、上図のように、バイト単位のデータが積み重なったものと考えると良いです。\nなお、バイトよりも大きい情報量の単位には、キロバイトやメガバイト、ギガバイトなどがあります。\n\n\n\n\n\n\n\n情報量の単位\nバイト換算\n\n\n\n\nキロバイト(KB)\n10の3乗=1,000バイト\n\n\nメガバイト(MB)\n10の6乗=1,000,000バイト\n\n\nギガバイト(GB)\n10の9乗=1,000,000,000バイト\n\n\nキビバイト(KiB)\n2の10乗=1,024バイト\n\n\nメビバイト(MiB)\n2の20乗=1,048,576バイト\n\n\nギビバイト(GiB)\n2の30乗=1,073,741,824バイト\n\n\n\n\n\n\n\nなお、キロバイト、メガバイト、ギガバイトという言葉が使われている場合でも、実際にはキビバイト(KiB)、メビバイト(MiB)、ギビバイト(GiB)を指す場合があるので、多少の注意が必要です。\n本講義でも、キビバイトやメビバイトは余り親しみのない言葉ですので、KiBやMiBと書いてキロバイト、メガバイトと発音しても良いことにします。\nなおキビバイトとキロバイトの容量差は2%しかありませんので、通常この違いに神経質になる必要はありません。\nギガバイトとギビバイトになると、7%の違いがありますので、ちょっと無視できないかもしれません。\n\n\n\n\n\n一方、CPUはレジスタと呼ばれる記憶装置を複数内臓しています。\nレジスタは、プログラム内の命令やデータ、メモリのアドレスなどを格納することができます。\nCPUはメモリに読み込まれたプログラムの中の命令をレジスタに読み込こんで実行したり、メモリのなかのデータをレジスタに読み込んで演算をほどこしたり、演算の結果をメモリに書き込んだりすることでコンピュータを動かしています。\n\n\n\n\n\nレジスタにはプログラマがプログラムから直接操作できるもの(十数個ある)と操作できないものがあります。\nプログラマが意識しなくてはならないのは前者の操作できるレジスタだけです。\n具体的にどのようなレジスタがいくつあるのかについては、CPUによって違ってきます。\n\n\n\n\n\nレジスタは、メモリと全く同じように0と1の情報を格納できます。\nレジスタには、64ビットコンピュータでは64ビット=8バイトの情報を格納することができます。\n32ビットコンピュータでは4バイトです。\nしたがって、プログラムが一つのレジスタを使って一度に処理できるデータの量は64ビットコンピュータなら最大8バイト、32ビットコンピュータなら最大4バイトです。\n\n\n\n\n\nただし64ビットレジスタは下位の32ビットを使って32ビットレジスタとしても動作できるようになっています。\n従って、64ビットコンピュータでも、32ビット仕様のOSやアプリケーションが動作します。\n32ビットレジスタのサイズが4バイトであることに合わせて、32ビットOSはメモリのアドレスを4バイトで表現します。\n\n\n\n\n\n\n\n\n2進数表記\n16進数表記\n10進数表記\n\n\n\n\n最小の数字\n0b0\n0x0\n0\n\n\n最大の数字\n0b1111…1111\n0xffffffff\n4,294,967,295=2の32乗-1\n\n\n\n\n0xffffffff=4,294,967,295=0b1111…1111であることはPythonで簡単に確かめることができます。\n\n&gt;&gt;&gt; 0xffffffff\n4294967295\n&gt;&gt;&gt; bin(0xffffffff)\n'0b11111111111111111111111111111111'\n\n\n\n\n4バイトの数値が表現できるメモリアドレスの範囲は、上記の表にあるように0～2の32乗-1=4×2の30乗-1です。\nメモリは1区画あたり1バイトの容量をもつので、32ビットOSでは、4×2の30乗バイト、すなわち4GiBまでしか扱うことができません。\nしたがって、それ以上のメモリを物理的に搭載しても、4GiBを超える部分はOSによって認識してもらえません。\n一方、64ビット対応したOSでは、メモリアドレスの表現に8バイト数値を使用します。\nしたがって0～2の64乗-1までのアドレスを使うことができます。\nこれは極めて巨大な数ですので、64ビットOSでは、実質任意に大きなメモリを使用できます。\n\n\n\n\n\nプログラムがメモリに読み込まれたあと、プログラムを構成する命令は、一つずつCPUに読みだされて実行されていきます。\n\n\n\n\nregister\n\n\n\n\n\n\nレジスタは0と1しか格納できないので、命令と命令からなるプログラムもまた、0と1の列でなくてはなりません。(当然、列の長さは8の倍数です。)\nこうした、CPUが理解できる、0と1で構成された命令をマシン語と呼びます。\n試しに、プログラムが実際にどのようなマシン語になっているかをディスプレイに打ち出してみることができます。\nこれをダンプ(dump)と言います。\nたとえば、画面に”Hello, World!“と打ち出すプログラムの最初の36バイトをダンプしてみると、以下のようになります。\n\n\n\n\n01111111 01000101 01001100 01000110 00000001 00000001\n00000001 00000000 00000000 00000000 00000000 00000000\n00000000 00000000 00000000 00000000 00000010 00000000\n00101000 00000000 00000001 00000000 00000000 00000000\n00010100 00000011 00000001 00000000 00110100 00000000\n00000000 00000000 10100100 00011010 00000000 00000000\n\n\n\n\nこのように、マシン語は人間にとっては非常に分かりづらいので、マシン語を直接操作しなくてもプログラムが作れるように、C言語などのプログラミング言語が作られました。\n余談ですが、64ビット版のWindows 10にはダンプをするためのツールが標準搭載されていないので、ダンプしたい人はそれ専用のツールを別途手に入れる必要があります。\n\n\n\n\n\n一方Linuxにはダンプのためのコマンドが標準で搭載されています。\nターミナルで次のように入力すれば実行可能ファイルをダンプできます。\n\nxxd -b a.out\n\nここでa.outが実行可能ファイルの名前です。-bは2進数でダンプするオプションです。このオプションを付けないと、結果は16進数で表示されます。\n\n\n\n\n\nプログラミング言語を分類する方法は色々ありますが、まず覚えた方が良いのが、コンパイル型言語とインタープリタ型言語の違いです。\n\n\n\n\n\n\n\n\n\n\nコンパイル型\nインタープリタ型\n\n\n\n\n実行速度\n高速\n低速\n\n\nコンパイル要不要\n必要\n不必要\n\n\n例\nC言語、C++、FORTRAN、RUSTなど\nPython、R、Ruby、Perl、JavaScriptなど\n\n\n\n\n\nたとえばC言語のようなコンパイル型言語で”Hello, World!“を出力するプログラムについて考えましょう。その場合、まず次のようなプログラミング言語で書かれたテキストファイル（ソースファイルあるいはソースコードという）を準備します。\n#include &lt;stdio.h&gt;\nint main(){\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\nこのファイル名をhello.cとしましょう。その後、コンパイルという操作により、このファイルを機械語に変換します。この操作を実行するソフトウェアのことをコンパイラと呼びます。たとえばLinuxには通常GNU C/C++ Compilerというコンパイラがインストールされていて、次のコマンドでコンパイルを行うことができます。\ngcc hello.c\nコンパイルを行うと、a.outという名前のマシン語で書かれたファイルが作成されます。これを実行可能ファイルと呼びます。厳密には、hello.cをマシン語にコンパイルしただけでは実行ファイルにはならず、オブジェクトファイルと呼ばれるマシン語で書かれたファイルが出来上がります。コンパイラはさらにリンクという作業を行い、出来上がったオブジェクトファイルに必要な付属品を色々とくっつけて実行可能ファイルを作ります。コンパイル型の言語で書かれたソースファイルは直接実行することはできず、かならずコンパイルして実行可能ファイルを作る必要があります。\n\n\n\ncompile\n\n\n実行可能ファイルは、CPUが直接解釈可能なマシン語で書かれているため、非常に高速に動作します。一方で、大きなプログラムはコンパイルに大変時間がかかるという欠点があります。また実行可能ファイルを構成するマシン語は、CPUのレジスタを直接操作する命令の集まりですので、CPUの異なるコンピュータでは動作しません。従って、プログラムを他のコンピュータに移植するときは、移植先のコンピュータでソースコードを再コンパイルする必要があります。\n\n\n\n一方、Pythonのようなインタープリタ型言語では、実行にコンパイルを必要としません。インタープリタ型言語では、ソースファイルは実行可能ファイルの源（ソース）ではないので、ソースファイルのことをスクリプトと呼ぶことがあります。また、インタープリタ型言語のことをスクリプト言語ということもあります。スクリプト言語では、スクリプトに記述されたコードはインタープリタと呼ばれるプログラム(アプリケーション)によって一つずつ読み取られ、実行されていきます。\n実際にはスクリプトファイルのテキスト文をそのまま読み取っていくのはインタープリタにとって不便なので、まずスクリプトはバイトコードと呼ばれるマシン語に似たものに変換されます。そのあと、バイトコードの中の命令が1行ずつ読み取られながらインタープリタによって実行されていくわけです。インタープリタはスクリプトからバイトコードを生成する作業と、バイトコードの命令を読み取って実行する作業を両方担当しています。Pythonインタープリタのうち、バイトコード実行を行う部分だけを指して、Pythonヴァーチャルマシン(PVM)と呼びます。\n\n\n\npvm\n\n\nPythonがバイトコードを生成するプロセスのことをコンパイルもしくはバイトコンパイルと呼ぶことがあるので注意が必要です。コンパイル言語でのコンパイルと違い、Pythonのバイトコンパイルはマシン語を生成しません。\n試しに”Hello world!“と印字するPythonのプログラムをバイトコンパイルしてみましょう。まず、このプログラムのPythonスクリプトは次のようになります。\nprint(\"Hello world!\")\nこのコードをバイトコンパイルして出来たバイトコードの最初の36バイトをダンプすると、以下のようになります。\n01000010 00001101 00001101 00001010 00000000 00000000 \n00000000 00000000 10101110 10001001 10011110 01100000\n00011000 00000000 00000000 00000000 11100011 00000000 \n00000000 00000000 00000000 00000000 00000000 00000000\n00000000 00000000 00000000 00000000 00000000 00000010\n00000000 00000000 00000000 01000000 00000000 00000000\nよく似ていますが、これはバイトコードであり、マシン語ではありません。Pythonヴァーチャルマシンは、このバイトコードを実行していきます。\nバイトコードの特徴は、マシン語で記述されたコンパイル言語の実行可能ファイルと違って、CPUの仕様に依存していないことです。したがって、バイトコードはそのまま他のコンピュータで実行することができます。一方で、直接レジスタに命令を送り込むコンパイル言語に比べると、ヴァーチャルマシンを介さなくてはならないスクリプト言語はかなり低速になり、場合によっては100～1000倍くらいの実行時の速度差が出てしまいます。\nしかしながら、コンパイルの必要がないので、インタープリタ言語による開発時間はコンパイル言語よりもはるかに早いのが普通です。(C言語で書かれた非常に大きなプログラムですと、コンパイルだけで数時間かかってしまうこともあります。たとえば以前node.jsというjavascriptのインタープリタをコンパイルしたときは半日くらいかかりました。)\nこのコンパイル型言語とインタープリタ型言語の違いを利用して、Python等のインタープリタ型言語でスピーディにプロトタイプを作成し、その後、少しずつコンパイル型言語に置き換えていくという開発上の作戦が取られることも良くあります。\nもう一つ、皆さんに覚えておいて欲しいのは、インタープリタそれ自体がプログラムであり、これは通常コンパイル型言語で作成(実装)されているということです。たとえばPythonのインタープリタで最も一般的なのはC言語で実装されたCPythonというインタープリタで、ほとんどの方が使っているPythonはこれです。CPythonのソースコードは公開されているので誰でも読むことができ、C言語を知っていれば内容を理解できます。他にもJavaで実装されたJythonというインタープリタもあります。\n\n\n\nなおプログラミング言語の中には、アセンブリ言語という特別なタイプの言語があります。アセンブリ言語は、01の並びであるマシン語を分かりやすい記号の列に「直訳」したものです。直訳したものですので、マシン語とアセンブリ言語はどちらの方向にでも変換可能です。アセンブリ言語からマシン語を生成する作業をアセンブル、その逆を逆アセンブルと言います。アセンブルを行うためのソフトウェアをアセンブラと呼びます。アセンブリ言語の特徴の一つは、マシン語の直訳であるため、レジスタの操作をプログラマが明示的に行う必要があるということです。\nたとえば、次のC言語のプログラムは、aという変数に1を代入し(正確には1という値で初期化し)、そのあとaに2を足すというだけのプログラムです。\nint MyAdd(){\n  int a = 1;\n  a = a + 2;\n  return a;\n}\nこれをコンパイルして出来たオブジェクトファイルを逆アセンブルすると、次のようなアセンブリ言語のコードが得られます。\npush   rbp\nmov    rbp,rsp\nmov    DWORD PTR [rbp-0x4],0x1\nadd    DWORD PTR [rbp-0x4],0x2\nmov    eax,DWORD PTR [rbp-0x4]\npop    rbp\nret\n\n\n\nassembly\n\n\nアセンブリ言語にはいくつか方言がありますが、ここではNASM(Netwide Assembler)という表記を用いています。ここでは詳しく説明できませんが、上のコードにおいて、rbpやrsp、eaxは全てレジスタの名前を表します。このように、アセンブリ言語では、レジスタを直接操作することが必要になってきます。(ちなみに”DWORD PTR [RBP-0X4]“などはメモリの領域を表します。)\nアセンブルと違ってコンパイルは不可逆変換なので、実行可能ファイルからコンパイル前のソースコードを復元することはできません。従って実行可能ファイルを分析するときは、通常、逆アセンブルを行ってアセンブリ言語に翻訳し、これを読解していきます。例えば、コンピュータウィルスの性質を解析する際にこういったスキルが必要になります。\nLinuxを使っている人は次のようにしてコンパイルと逆アセンブルを行うことができます。上のソースファイル名をmyadd.cとします。\ngcc -c myadd.c\nobjdump -d -M x86-64,intel myadd.o\nここでmyadd.oはコンパイルによって生成されたオブジェクトファイルです。\n\n\n\n\nアセンブリ言語のように、レジスタやメモリといったハードウェアを直接操作する言語を低水準言語と呼びます。低水準言語は、抽象度が低い言語と表現されることもあります。一方、Pythonのように、レジスタやメモリと言ったものをプログラマが直接意識することなくプログラミングできるような言語は、高水準言語と呼ばれ、抽象度が高いと言われます。一般に、インタープリタ型言語のほうがコンパイル型言語よりも抽象度が高い傾向があります。また、時代が進むにしたがって、より高水準で抽象度の高い言語が登場してきたと言えます。\n高水準言語や低水準言語というのは、相対的なものであるととらえた方が良いでしょう。たとえば、従来C言語はアセンブリ言語と比較して高水準言語であると言われてきましたが、言語の高水準化が進むにつれ、たとえばPython等に比べると低水準言語であると言われるようにもなってきました。というのも、C言語ではレジスタを意識することはほとんどありませんが、メモリはかなり意識しないとコードが書けないからです。一方、Pythonでは、C言語よりも抽象度が高く、比較的メモリを意識しなくてもプログラミングができるようになっています。それでも、以降の講義で論じるように、メモリをある程度意識することはPythonを正しく使う上で重要であると言えます。\n\n\n\n当たり前ですが、プログラミングの上達において最も大切なことは、「プログラミングを楽しむ」ことだと思います。そのために大切なことは、「ストレスなくコーディングする」ということに尽きると思います。そして、そのためには、以下の2点が重要であると筆者は考えます。\n\n正しいタイピングをする\nエディターのキーバインドをマスターする\n\nもう一つコツを挙げるとすれば、誰もが言うことですが、コードを試すときは、写経するということです。写経とは、コードをコピー＆ペーストしたり、すでに他人が入力したコードを実行するのではなく、自分でタイピングして書き写すことです。\n\n\n正しいタイピングとは、タッチタイピング（いわゆるブラインドタッチ）のことです。タッチタイピングを解説したサイトはインターネットにたくさんありますので、ここでは改めて解説しません。以下の項目に注意して練習を重ねてください。\n\n最初は決して速く打とうとしてはいけない\n同じキーはいつも同じ指で叩く\nキーを叩くときは、基本そのキーに最も近い指で叩く\nキーボードを見ないでタイプするトレーニングをする\n人差し指～小指すべて使う\n\n数字や記号はつらいので、まずはアルファベットだけキーボードを見ないで打てるようになるように練習しましょう。そのうち見ないで打てるキーの数が増えてきます。タイピングソフトなどは必要ありません。ゆっくりで良いので、タッチタイピングの基本を守りつつプログラミングや文書作成をしていれば、自然に上達していきます。\n上達につれてタイプの速度は上がってきますが、目安として大体1分間に200タイプくらいでスピード的には十分ではないでしょうか。重要なのはストレスを無くすことであって、速度を上げることではありません。ゆっくりでもキーボードを見ずに正確に打てるようになれば、視線の移動がほとんど必要なくなるので、コーディング中に感じるストレスは圧倒的に小さくなります。\n\n\n\nコーディングのストレスを軽減するには、正しいタイピングを心がけるだけでなく、キーバインドを覚えることが重要です。本講義で言うキーバインドとは、編集中に文書の中を移動したり、編集に関連する様々な機能を呼び出したりするためのキーボードショートカットのことです。\nプログラミングの世界には大きく分けて、2種類のメジャーなキーバインドがあります。1つはEmacsキーバインド、もう一つはviキーバインドです。これらは、それぞれ、Emacs、viというエディターで用いられているキーバインドですが、多くのエディターでこれらの2つのキーバインドを使用することができるようになっています。\nEmacsキーバインドは直観的で覚えやすいのが特徴で、viキーバインドは「速い」のが特徴です。筆者はプログラミングにEmacs、設定ファイルなどの編集にviを使うという風に使い分けていますので、本講義でもプログラミングのためにはEmacsキーバインドを用いることを推奨したいと思います。Emacsキーバインドについては次回VS Codeを操作するときに詳しく説明します。\n\n\n\nコードを写経することにより、自分で書いてみると、そっくりそのまま書き写したはずがうまく動作しないということが往々にして生じます。その度に、「どこが間違っていたのか」考えさせられることになり、細部に目が行くことになります。また、単純にタイピングの練習にもなります。\n写経は、最初のうちは苦行かもしれません。前時代的なトレーニングと思われるかもしれません。なかなか先に進めないのでじれったい気持ちになるかもしれませんが、これは必要なプロセスです。どれだけプログラミングが上手になっても、皆さん写経をしておられます。逆に写経がストレスなくできるようになったら、一人前だと考えてください。\nしたがって、本講義では、入力済みのコードを配布しないことにします。どうしてもコピー＆ペーストが必要なときは、このサイトから行えばよいでしょう。\n\n\n\n\n今回は、以下の事項について学びました。\n\nPythonを学ぶ意義\nPythonを動かす2種類の基本的な方法\n本講義の目標\nプログラムがどのように動いているか\nプログラミング言語にはどのようなものがあるか\nプログラミング上達のコツ\n\n今回の講義でPythonのプログラムがどのように動いているか、大体分かったと思います。一方で、一つ一つのPythonの文がどのように動作しているのかまでは説明しませんでした。そういった詳細については今後の講義で解き明かして行くことにしましょう。\n基本的なプログラミングの練習は、基本的に独学でも可能なものです。自宅や研究室のパソコンにもPythonをインストールし、教科書を参照しながらPythonの操作をしっかりと練習しておいてください。\n\n\n\n\n『プログラムはなぜ動くのか(第2版)』(矢沢久雄 著/日経ソフトウェア監修) (2007) 日経BP社. ISBN 978-4-8222-8315-5.\n\n\n\n\n本講義では提出しなくてよい宿題のことを「宿題」または「ホームワーク」と呼ぶことにします。今回はホームワークとして、以下を出題します。\n\n『独習Python』の第1章『イントロダクション』を読みなさい。\nそこに書かれている手順に従って、AnacondaとVS Codeを自分のパソコンもしくは研究室のパソコンにインストールしなさい。\nAnacondaをインストールしたパソコンでREPLを起動し、様々な計算式を打ち込んでみなさい。\nREPLに様々なPythonコードを打ち込み、期待された結果が得られるか試してみなさい。\n『2の補数表現』や『浮動小数点数』、『エンディアン』といった言葉に聞き覚えがない人は、本ページ末尾の補遺を読んでおいてください。\n\nなお、LinuxユーザーはAnacondaをインストールしないことをお勧めします。X Windowシステムが壊れて再起不能になることがあります。\nAnacondaはある程度スペックを要求します。CPUはIntel Core i5以上、メモリは最低でも8GBは必要かと思います(16GB推奨)。\n\n\n\n本講義では、提出しなければならない宿題のことを「課題」もしくは「アサインメント」と呼ぶことにします。今回の課題はありません。課題は全てGitHubのアサインメント機能を使って提出していただきますので、課題が出題されるのはGitHubについて学ぶ第3回目以降です。\n\n\n\nここでは、メモリの上で整数や小数がどのように表現されているかを説明します。\n\n\n符号なし整数とは、正整数のみを表すことができるデータ型のことです。符号なし整数がメモリ上に記録される方法は特に難しいことはありません。単に正整数の2進数表現がそのまま格納されているだけです。例えば、2バイト=16ビットの領域に14という整数が格納されるときは、\n00000000 00001110\nのように格納されます。\n\n\n\n符号つき整数では、負の数と正の数を表すことができます。符号付き整数では、最も桁の大きいビットを符号を表すために用います。この符号ビットが0ならば0か正の整数を、1ならば負の整数を表します。残りの桁は、正整数ならば、符号なし整数と同じで、元の正数の2進数表現になっています。\n一方、負の数の場合は、元の数の絶対値の2の補数になっています。数nの2の補数とは、nのビット(0と1)を反転して、1をプラスしたものです。\nたとえば、14は上記のように表されますので、そのビットを反転したものは、\n11111111 11110001\nとなりますので、これに1を足したものは、\n11111111 11110010\nになります。これが-14の2の補数表現であり、メモリ上で-14という負数はこのように格納されています。\n実際、14と-14を足すと0になることが次のようになります。\n  00000000 00001110\n+ 11111111 11110010\n-------------------\n1 00000000 00000000\n一番左のあふれた一桁は無視されるので、和は0になることが分かります。\n符号つき整数の絶対値の上限は、符号なし整数の約半分になります。\n\n\n\nバイト数\n符号つき整数\n符号なし整数\n\n\n\n\n1\n-128 ～　127\n0 ～ 255\n\n\n2\n-32,768 ～ 32,767\n0 ～ 65,535\n\n\n4\n-2,147,483,648 ～ 2,147,483,647\n0 ～ 4,294,967,295\n\n\n8\n-2**63 ～ 2**63-1\n0 ～ 2**64-1\n\n\n\n即席ですが、任意の整数を2の補数表現に変換するPython関数を作りましたので参考にしてください(バグを見つけたら教えてください。)関数についてはまだ学んでいないので、現時点でこの関数を使える必要はありません。\n# %%\n# 整数を2の補数表現に変換する関数\ndef int_to_bits(num,length,endian='big'):\n    if type(num) is int:\n        num_bytes = num.to_bytes(length,endian,signed=True)\n        num_bin = bin(int(num_bytes.hex(),16))\n        if len(num_bin)-2 &lt; length * 8:\n            bit_str = (\"0\"*(length*8-len(num_bin)+2)) + num_bin[2:]\n        else:\n            bit_str = num_bin[2:]\n        byte_list = [bit_str[8*i:8*i+8] for i in range(length)]\n        print(\" \".join(byte_list))\n    else:\n        print(\"The first argument must be an integer.\")\nこの関数は次のように使います。\nint_to_bits(整数,バイト数,エンディアン)\nエンディアンは指定しなくても構いません。指定しない場合はビッグエンディアンになります(エンディアンについては下で説明しています)。\nたとえば、4バイト符号つき整数の-255を2の補数表現にするには、次のようにします。\nint_to_bits(-255,4)\n# 出力\n11111111 11111111 11111111 00000001\nリトルエンディアンにするときは、第3引数を’little’に指定してください。\nint_to_bits(-255,4,'little')\n# 出力\n00000001 11111111 11111111 11111111\n\n\n\n小数は、浮動小数点数というデータ型でメモリに格納されます。浮動小数点数には単精度浮動小数点数と倍精度浮動小数点数があります。単精度では一つの数値に32ビット(4バイト)、倍精度では64ビット(8バイト)を使います。\n浮動小数点数がどのように小数をメモリ上で表現するのか、単精度の場合を例にとって説明します。\nまず、全ての実数は次のように表現できることに注意しましょう。\n[符号] (m)×(10のn乗)\nただし、mは0.xxx...という形式の10進数小数です。たとえば、-123.45は、次のように表すことができます。\n- (0.12345)×(10の3乗)\nmを仮数、nを指数と呼びます。\n全く同様に、全ての実数は次のように表現できます。\n[符号] (m) * (2のn乗)\nただし、mは1.xxx...という形式の2進数小数です。たとえば、2進数小数101.1011は、次のように表すことができます。\n+ (1.011011)×(2の2乗)\nそこで単精度浮動小数点では、下図のように32ビットを上の桁から順に1ビット、8ビット、23ビットに区切り、それぞれ符号、指数、仮数を表すのに使います。\n\n\n\nfloat\n\n\nただし、指数は常に1.xxx...という形をしているので、\"1.\"を省略し、xxx...の部分だけを23ビットに記憶します。たとえば、仮数が1.011011であれば、浮動小数点数の仮数部分23ビットは\n0110110 00000000 0000000\nのようになります。また、指数部分は、正負どちらの値でもありえますが、ここでは負の数を表すのに補数は使いません。代わりにイクセス表現を使います。イクセス表現では、指数部分8ビットを0～255の符号なし整数と見なしたとき、そこから、ちょうど中間の値127を引いたものを実際の指数とする表現方法です。\nたとえば、指数部分に記憶されているビット列が次のようになっていたとします。\n10000001\nこれは10進数符号なし整数に読み替えると129です。ここから127を引くと2ですので、実際の指数は2ということになります。\nまとめると、符号部分のビット、指数部分のビット列、仮数部分のビット列がそれぞれ\n# 符号ビット\n1\n# 指数部分8ビット\n10000001\n# 仮数部分23ビット\n01101100 00000000 0000000\nのようになっているとき、この単精度浮動小数点数は、\n[-] (1.011011)×(2の2乗) = -101.1011\nを表すことになります。これを10進数で表すと、-5.6875になります。言い換えると、-5.6875という小数は、浮動小数点数によって\n1-10000001-01101100 00000000 0000000\nという32ビットでメモリ上に記憶されていることになります。\nさて、上記の仮数部分を16進数で表し、指数部分をイクセス表現でなく実際の指数(10進数)に書き換えると、次のようになります。\n1-(+2)-6c 00 00\nただし右端の0だけは3ビットしかありませんので注意してください。\n倍精度の浮動小数点数ですと、仮数部分は52ビット=6バイト+4ビットありますので、-5.6875はメモリ上で、\n1-(+2)-6c 00 00 00 00 00 0\nと記憶されます。“6c”に続いて0が11個あることに注意してください。Pythonでは、この表現を次のようにして出力することができます。\n&gt;&gt;&gt; (-5.6875).hex()\n'-0x1.6c00000000000p+2'\nここで、pのあとの+2が指数、0x1.のあとの6c00000000000が指数部分に記録されているビット列を表します。\n\n\n\nエンディアンは、複数バイトを使う数値や文字が、どのバイトから先にメモリに格納されるかを表します。下の桁のバイトから順に格納されていく方式をリトルエンディアン、上の桁のバイトから順に格納されていく方式をビッグエンディアンと呼びます。エンディアンはCPUに依存しますが、現在パソコンで使われているCPUの多くはリトルエンディアン方式です。\nリトルエンディアンでは、下の桁のバイトのほうが上の桁よりもメモリ上で若いアドレスに格納されますので、例えば16ビット整数型としてメモリに保存された整数14をダンプすると、次のように、バイトが入れ替わって画面に表示されます。\n# 14はリトルエンディアンではこう見える\n00001110 00000000\n一方、ビッグエンディアンでは、上の桁のバイトのほうが下の桁よりも若いアドレスのメモリに格納されますので、14が格納されたメモリ領域をダンプすると、次のように画面に表示されます。\n# 14はビッグエンディアンではこう見える\n00000000 00001110\nこのように、下の桁から若いアドレスに順番に格納していくリトルエンディアン方式は、発想において自然ですが、ダンプしたときにひっくり返って表示されるので、読みにくいという難点があります。一方ビッグエンディアンでは表示された順そのままで読むことができます。\nエンディアンは普段はほとんど意識する必要がありませんが、文字や数値のバイト列表現を扱うときに、どうしても避けられない話題となってきますので、頭の片隅においておく必要があります。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#授業で使う言語-1",
    "href": "programming2025/slide-programming-1.html#授業で使う言語-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "この授業では、主にPythonを扱っていくことにします。\nそれから、Rも少し扱っていきますが、Rについては、皆さんは統計学2や計量経済学（どちらも2年生科目)の授業で学んで来ているでしょうから、その基礎は押さえていると仮定し、いちいち復習はしません。\nたとえば、Rのベクトルやデータフレームがどういったものだったか忘れてしまっている人がいたら、復習しておいてください。\nそれから、if条件分岐やforループについて、構文を忘れてしまっている人は、思い出しておくと良いでしょう。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#授業で使う言語-2",
    "href": "programming2025/slide-programming-1.html#授業で使う言語-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "さて、Pythonについては多くの方が名前くらい聞いたことがあるでしょう。\n以前はPythonの国内人気はいまいちでしたが、最近の機械学習ブームの波にのって人気が高まり、いまでは国内外問わず最もポピュラーなプログラミング言語となりました。\n従って、YouTubeなどに、初心者向けのPythonのわかりやすい解説動画がたくさんあり、また独学に適した日本語の参考書も次々と発売されています。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#大学でpythonを学ぶ理由",
    "href": "programming2025/slide-programming-1.html#大学でpythonを学ぶ理由",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "独学のための良質の素材があふれているのであれば、なぜ本講義でわざわざプログラミング、そしてPythonを学ばなければならないのでしょうか。\n以下に、巷の教材に任せきってしまうことの問題を挙げてみましょう。\n\n独学では、モチベーションが沸かない。\n研究での活用がわかりにくい。\n表面的な説明が多く、Pythonの深いところがなかなか見えてこない。\n高度な内容をどうやって勉強したらいいのかわからない。\n\nつまり、とりあえずPythonを動かすことは独学で簡単にできるようになるのですが、そこから先（深ぼりしたり、応用したり）が見えにくいというのが筆者の見解です。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#深掘りする理由-1",
    "href": "programming2025/slide-programming-1.html#深掘りする理由-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "では、なぜPythonを深ぼりする必要があるのでしょうか？\n最も大きな理由は、それによって、応用力が身につくということです。\n本講義を通して、受講者はビットやバイトの言葉を直感的に使いこなせるようになると思います。\nそういった感覚は、長く使えるものです。\n言語の表面的な知識だけを身につけても、すぐに忘れてしまうでしょうし、Pythonが廃れたら役に立たないでしょう。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#深掘りする理由-2",
    "href": "programming2025/slide-programming-1.html#深掘りする理由-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "もう一つの小さな理由は、Pythonが、深ぼりしないと間違いを冒すタイプの言語だということです。\n言い換えると、プログラムというものがどのように情報を扱っているのかをある程度理解しないと、Pythonを正しく使うことは難しいと言うことです。\nこれは良いニュースだと思います。\nなぜなら、Pythonを勉強することが、計算機科学の勉強につながるからです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#深掘りする理由-3",
    "href": "programming2025/slide-programming-1.html#深掘りする理由-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "この点で、PythonはRとかなり違います。\nRは、プログラミングにそれほど精通していなくても使いやすく設計されています。\nRに慣れた学生の皆さんは、Pythonを学ぶことで、プログラミングというものが何なのか、より深い実感をもつことができるようになるでしょう。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#学習教材-1",
    "href": "programming2025/slide-programming-1.html#学習教材-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "皆さんが本講義を通してPythonを学ぶに当たっては、以下の教材を有効活用することをおすすめします。\n\n\nPython公式ドキュメント\n『独習Python』(教科書)\n本サイト\n\n\n内容の網羅性で言うと、1&gt;2&gt;3です。\n本サイトではPythonの標準機能の一部しか紹介できませんので、足りない部分を2の教科書で補うことにします。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#学習教材-2",
    "href": "programming2025/slide-programming-1.html#学習教材-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "さらに、プログラミングをしていると、教科書を含む一般向け書籍にはなかなか書かれていないようなことも時々調べなくてはなりません。\nそのような場合には、最終的には1のPython公式ドキュメントを当たらねばなりません。\nさらに、公式ドキュメントにも載っていないことは高度な専門書や、ネット上の非公式なドキュメントを参考にしたり、Stack Over Flowのようなサイトで検索・投書するか、自分で試行錯誤しなくてはなりません。\nまた、本講義はPythonの標準機能を説明するだけのものではありませんので上の教材だけでは不十分です。\n標準機能以外に関する補助的教材や参考資料については、適宜紹介することにします。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-1",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それでは前置きが長くなりすぎたので、そろそろPythonを動かしてみましょう。\nPythonを動かすには、様々な方法がありますが、まずはREPL(Read-Eval-Print Loop)を用いた対話的実行を行ってみましょう。\nウィンドウズを起動して、画面の左下の検索ウィンドウにAnacondaと打ち込んで、Anaconda Promptを起動しましょう（Anaconda Powershell Promptでも構いません）。\nAnacondaを起動したら、pythonと入力し、pythonの対話的インタープリタREPLを起動しましょう。\nプロンプトと呼ばれる\"&gt;&gt;&gt;\"記号が現れて、入力待ちの状態になるはずです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-2",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "REPLは、Pythonのコードを1行ごとに評価し、即時にその結果を表示してくれるシステムです。\n小さなコード断片の挙動を確かめる際などに便利です。\nPythonには、整数や計算式などはそれ自体がPythonのコードと見なされるという特徴があります。\nそのおかげで、PythonのREPLを計算機として用いることができます。\nたとえば、何でも良いので、簡単な足し算や引き算をREPLに入力してみましょう。（入力の最後にはEnterキーを押します。）"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-3",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "&gt;&gt;&gt; 1 + 1\n2\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 3 * 2\n6\n&gt;&gt;&gt; 8 / 2\n4.0\n&gt;&gt;&gt; 11 // 3\n3\n&gt;&gt;&gt; 11 % 3\n2\n&gt;&gt;&gt; 5 ** 3\n125\n\nこのように、REPLは簡単な計算機として用いることができます。なお、Pythonにおける2項算術演算子は以下の通りです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-4",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "演算子\n機能\n\n\n\n\n+\n可算\n\n\n-\n減算\n\n\n*\n乗算\n\n\n**\nべき乗\n\n\n/\n除算\n\n\n//\n整数除算（余りを切り捨て）\n\n\n%\n剰余\n\n\n\n\n上記の表は教科書のセクション3.1にもありますので確認しておいてください。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-5",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-5",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "なお3つ以上の数の演算を行うには、演算子の優先順位に気を付けなければならないのはRと同じです。たとえば\n&gt;&gt;&gt; 2 + 3 * 5\n17\nのように掛け算は足し算よりも先に評価されます。演算子の評価順序を明確にしたいときは、丸カッコを使います。\n&gt;&gt;&gt; (2 + 3) * 5\n25\n演算子の優先順位については教科書のセクション3.6(pp. 107)に解説がありますので、読んでおいてください。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-6",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-6",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ただし、計算式においては、演算子の評価順序には過剰に頼り過ぎず、丸カッコを積極的に使うことをお勧めします。\nでないと、あとからコードを見返したときに、非常に理解しにくくなってしまうからです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#練習1",
    "href": "programming2025/slide-programming-1.html#練習1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "次の計算をPythonで実行したらどのような結果が得られるかを予測しなさい。\n\n# Q1\n&gt;&gt;&gt;(5 % 3) ** (7 // 2)\n# Q2\n&gt;&gt;&gt;(5.5 - 2.5 + 3.0) * 2.0\n\n上記Q1, Q2の予測をREPLで確かめられたら、同じように様々な計算を自分で考えてREPLで実行し、予測と一致するか確かめなさい。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-7",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-7",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それでは、次にもう少し高度なことをしてみます。以下のように入力して、変数xに整数1を代入し、xの値を表示してみましょう。\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; x\n1\n\nこのように、‘=’記号を使うと左辺の変数に右辺の値を代入できます。(Rでは、同様の操作に’&lt;-’という矢印演算子を用いましたね。)"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-8",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-8",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それでは、さらに変数を用いて色々な演算をしてみましょう。\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 2\n&gt;&gt;&gt; x + y + 3\n6\n&gt;&gt;&gt; z = y + 1\n&gt;&gt;&gt; x - z\n-2\n&gt;&gt;&gt; x = z ** y\n&gt;&gt;&gt; x\n9\n&gt;&gt;&gt; x = x - 1\n&gt;&gt;&gt; x\n8"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-9",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-9",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "このように、変数は演算の中で用いることができます。\nこれについてはRでもほとんど同じなので、細かい説明は不要でしょう。\n最後に”Hello, World!“を出力しておきましょう。\nこれについても、Rと全く同じですので、説明はほとんど要らないでしょう。(実際、Rのコードと見分けがつきません。)\n\n&gt;&gt;&gt; print(\"Hello, World!\")\nHello, World!"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#replによる対話的実行-10",
    "href": "programming2025/slide-programming-1.html#replによる対話的実行-10",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "Rと同じように、ダブルクォーテーションでくくられた部分は、Pythonにより文字列と解釈されます。printは、引数に与えられた文字列や数を画面に出力するだけの関数です。\nREPLを終了してAnaconda promptに戻るときは、次のように入力します。\n\n&gt;&gt;&gt;exit()"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コマンドラインによる実行-1",
    "href": "programming2025/slide-programming-1.html#コマンドラインによる実行-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それでは次に、Pythonのコードをファイルに保存してコマンドラインから実行する方法を試してみましょう。\nAnaconda promptで次のように入力してhello.pyというテキストファイルを作成します。\n\n(base) C:\\Users\\hogehoge&gt;notepad hello.py\n\n“hello.pyは存在しません。新しく作成しますか？”と聞かれたら「はい」を選択するとメモ帳が起動します。\nメモ帳で、ファイルの先頭行に次のような1行を記述してください。\n\nprint(\"Hello, World!\")"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コマンドラインによる実行-2",
    "href": "programming2025/slide-programming-1.html#コマンドラインによる実行-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "次にファイルを保存して閉じ、Anaconda promptで次のように入力すると、ファイルに記述したPythonコードを実行することができます。\n\n(base) C:\\Users\\hogehoge&gt;python hello.py\nHello, World!\n\n\nなお、Pythonコードを記述するファイル（スクリプトと呼ぶ）の名前には拡張子.pyを付けるのが普通です。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コマンドラインによる実行-3",
    "href": "programming2025/slide-programming-1.html#コマンドラインによる実行-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それではもう一度同じファイルを開いて、もう少し中身を豪華にしてみましょう。\n\nprint(\"Hello, World!\")\nx = 1\ny = 2\nz = x + y\nprint(x)\nprint(y)\nprint(z)"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コマンドラインによる実行-4",
    "href": "programming2025/slide-programming-1.html#コマンドラインによる実行-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "これを実行すると、以下のようになります。\n\n(base) C:\\Users\\Kobayashi&gt;python hello.py\nHello, World!\n1\n2\n3\n\n\nこのように、Pythonでは、文を改行で区切って並べることにより、上から順番に文が実行されていきます。\n文については教科書のセクション1.5.2に詳しい説明があるので良く読んでおいてください。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#練習2",
    "href": "programming2025/slide-programming-1.html#練習2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "5の5乗を計算して画面に出力するpower5_5.pyというファイルを作成し、実行しなさい。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#本講義の目標-1",
    "href": "programming2025/slide-programming-1.html#本講義の目標-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "遅くなりましたが、ここで本講義の目標を述べておきます。本講義の目標を箇条書きにすると以下のとおりです。\n\n\nPythonの設計思想を理解する\nメモリ(主記憶装置)のイメージができるようになる\nPythonで簡単なデータ解析ができるようになる\nPythonで簡単な社会科学実験のプログラムを作れるようになる"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#本講義の目標-2",
    "href": "programming2025/slide-programming-1.html#本講義の目標-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "上記では、「設計思想を理解する」という言葉に非常に多くの意味を込めました。\n設計思想は、言葉で説明されて分かるものではなく、Pythonを学ぶうちに、段々と見えてくる設計上のパターンやクセのようなものです。\nそういったパターンやクセは、設計者の理念をそのまま反映していることもありますし、そういった理念を追求した結果、仕方なく生じてしまった歪み、機能的制約、初学者が面食らってしまうような数々の奇妙な挙動や明らかな欠陥も含みます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#本講義の目標-3",
    "href": "programming2025/slide-programming-1.html#本講義の目標-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "設計思想が分かると、たとえば、Pythonの\n&gt;&gt;&gt; x = y\nとC言語の\nx = y;\nに対して、明確に違ったイメージを持つことができるようになります。\n設計思想が分かるというのは、世界観が出来上がるということでもあります。\nこれは多分、プログラミング言語も、自然言語と同じなのではないかと思います。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#本講義の目標-4",
    "href": "programming2025/slide-programming-1.html#本講義の目標-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ある人を理解するということは、その人のスケジュールを全て覚えることではありません。\nそれと同じで、言語の設計思想を理解することは、関数や構文をたくさん覚えることではありません(そういうことは、ネットで検索すればよいのです)。\n設計思想を理解するというのは、新しい関数や構文に出会ったときに、『なるほどPythonらしいな』と思え、戸惑わないようになることです。\nそして、ある程度パターンが予測でき、変な行動をとっても怒らず、『まあ仕方ないね』と許せるようになることです。\n時々失敗するけれど、なぜ失敗なのか、すぐに分かるということです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#本講義の目標-5",
    "href": "programming2025/slide-programming-1.html#本講義の目標-5",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "さて、一見遠回りに見えますが、上記の1〜4は、どれも全て「応用」を念頭においていることを強調しておきたいと思います。\n設計思想が分からなかったり、メモリのイメージを持っていないと、ずっと「手探り」でプログラミングをすることになり、すぐに伸び悩むことになると思います。\nこれを機会にぜひ、ゆっくりパソコンに向かって様々な実験を繰り返し、あるいはStack overflowの数々の間違った情報に辟易し、ときにはデスクに向かって色々と計算してほしいと思います。\nそういったプロセスを踏んで、どんなプログラミング言語でも独力で学べるような基礎力を身に着けてほしいと思います。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#本講義の目標-6",
    "href": "programming2025/slide-programming-1.html#本講義の目標-6",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "それでは、まずプログラミングの準備として、プログラムといったものがどのように動いているのかといったことの簡単な説明から始めなくてはなりません。\n以下、座学になりますが、難しい数学などは出てきませんので、何卒お付き合いください。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#進数と16進数-1",
    "href": "programming2025/slide-programming-1.html#進数と16進数-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "2進数や16進数については、多くの方が高校や大学で学んだことがあることでしょう。\nしかしながら、以降の説明で非常に重要ですので、ここでこれらの概念を簡単に復習しましょう。\nご存じの通り、私たちが普段使っている10で桁上がりする数字は、10進数と呼ばれます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#進数と16進数-2",
    "href": "programming2025/slide-programming-1.html#進数と16進数-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "一方、2で桁上がりする数を2進数、16で桁上がりする数を16進数と呼び、情報科学では10進数と並んで良く用いられる数の表し方です。\n2進数では、2で桁上がりするため、10進数における2～9の数字は現れません。\nまた、16進数では、10進数における09だけでは1桁を表すのに足りないため、afのアルファベットを用います。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#進数と16進数-3",
    "href": "programming2025/slide-programming-1.html#進数と16進数-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "10進数\n2進数\n16進数\n\n\n\n\n0\n0\n0\n\n\n1\n1\n1\n\n\n2\n10\n2\n\n\n3\n11\n3\n\n\n4\n100\n4\n\n\n5\n101\n5\n\n\n6\n110\n6\n\n\n7\n111\n7\n\n\n8\n1000\n8\n\n\n9\n1001\n9\n\n\n10\n1010\na\n\n\n11\n1011\nb\n\n\n12\n1100\nc\n\n\n13\n1101\nd\n\n\n14\n1110\ne\n\n\n15\n1111\nf\n\n\n16\n10000\n10"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#進数と16進数-4",
    "href": "programming2025/slide-programming-1.html#進数と16進数-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ある数が2進数で表記されていることを明確にするため、2進数の先頭に0bという接頭辞を付けることがあります(bはbinaryより)。\n同様に16進数には接頭辞0xをつけます(xはhexadecimalより)。\nたとえば、0x1eは0b11110すなわち10進数での30を表します。\n10進数、2進数、16進数の間の変換に慣れておきましょう。とくに2進数と16進数の間の変換は重要です。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#進数と16進数-5",
    "href": "programming2025/slide-programming-1.html#進数と16進数-5",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "10進数、2進数、16進数の間の変換は、Pythonを用いても行うことができます。\n次のPythonコードは、それぞれ、10進数の123を2進数、16進数に変換するものです。\n\n&gt;&gt;&gt; bin(123)\n'0b1111011'\n&gt;&gt;&gt; hex(123)\n'0x7b'\n\nこのように関数binとhexを使えば10進数をそれぞれ2進数、16進数に変換することができます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#進数と16進数-6",
    "href": "programming2025/slide-programming-1.html#進数と16進数-6",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "また、逆の変換をするときは、次のように数字を入力するだけです。\n\n&gt;&gt;&gt; 0b1111011\n123\n&gt;&gt;&gt; 0x7b\n123"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コンピューターの仕組み-1",
    "href": "programming2025/slide-programming-1.html#コンピューターの仕組み-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "パソコンは、様々な部品から構成されていますが、プログラミングの初心者がまず知っておかなければならないのが、CPUとメインメモリの働きです。\nメインメモリはランダムアクセスメモリ(Random Access Memory)とも呼ばれるので、RAMと表記されることもあります。\nCPUとメモリ(メインメモリ)は、記憶装置です。\nパソコンにはいくつもの記憶装置が内臓されていますが、どの記憶装置も、文字や整数や小数だけでなく、プログラムなど、すべての情報を0と1の配列に変換して記憶しています。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コンピューターの仕組み-2",
    "href": "programming2025/slide-programming-1.html#コンピューターの仕組み-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "CPUとメモリはどちらもトランジスタで構成された集積回路(IC, Integrated Circuit)ですが、次のような性質の違いがあります。\n\n\n\n\n\nCPU\nメモリ\n\n\n\n\n記憶容量\n非常に小さい\n大きい\n\n\n演算能力\n有り\n無し"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#コンピューターの仕組み-3",
    "href": "programming2025/slide-programming-1.html#コンピューターの仕組み-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ここで言う演算とは、足し算や引き算を含む様々な計算のことです。\nCPUは演算機能をもっていますが、ほんの少しの情報しか記憶できないので、CPUだけではちょっとしたプログラムも動かせません。\nそこで、まず容量の大きいメモリにプログラム全体を読み込ませます。プログラムは、CPUに対する命令の集まりです（と思って大体間違いありません）。\nCPUは、メモリに読み込んだ命令を１つずつ読み取って実行していきます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#メモリの仕組み-1",
    "href": "programming2025/slide-programming-1.html#メモリの仕組み-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "メモリは、たとえば001011010110001101011…のように、全ての情報を0と1の並びに変換して記憶しています。\nこの0と1の並びは、8桁ずつの区画に区切られています。\nそれぞれの区画には、アドレスと呼ばれる数字が振られていて、数字によってメモリ上の位置が指定できるようになっています。\nそれぞれの区画には、8桁の0と1が格納されているので、1つの区画は00000000から11111111までの256通りの状態を記憶することができます。\nこの記憶容量のことをバイト(Byte)といいます。一方、1桁の0と1で記憶できる容量のことをビット(bit)と呼びます。\nよって、1バイト = 8ビットの関係が成り立ちます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#メモリの仕組み-2",
    "href": "programming2025/slide-programming-1.html#メモリの仕組み-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "メモリへの情報の読み書きは、必ずバイトを単位として行われます。\nビットを単位として読み書きすることはできません。\nこのように、バイトはパソコンにおける最も重要な情報量の単位です。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#メモリの仕組み-3",
    "href": "programming2025/slide-programming-1.html#メモリの仕組み-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "memory"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#メモリの仕組み-4",
    "href": "programming2025/slide-programming-1.html#メモリの仕組み-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "メモリについて考えるときは、上図のように、バイト単位のデータが積み重なったものと考えると良いです。\nなお、バイトよりも大きい情報量の単位には、キロバイトやメガバイト、ギガバイトなどがあります。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#メモリの仕組み-5",
    "href": "programming2025/slide-programming-1.html#メモリの仕組み-5",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "情報量の単位\nバイト換算\n\n\n\n\nキロバイト(KB)\n10の3乗=1,000バイト\n\n\nメガバイト(MB)\n10の6乗=1,000,000バイト\n\n\nギガバイト(GB)\n10の9乗=1,000,000,000バイト\n\n\nキビバイト(KiB)\n2の10乗=1,024バイト\n\n\nメビバイト(MiB)\n2の20乗=1,048,576バイト\n\n\nギビバイト(GiB)\n2の30乗=1,073,741,824バイト"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#メモリの仕組み-6",
    "href": "programming2025/slide-programming-1.html#メモリの仕組み-6",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "なお、キロバイト、メガバイト、ギガバイトという言葉が使われている場合でも、実際にはキビバイト(KiB)、メビバイト(MiB)、ギビバイト(GiB)を指す場合があるので、多少の注意が必要です。\n本講義でも、キビバイトやメビバイトは余り親しみのない言葉ですので、KiBやMiBと書いてキロバイト、メガバイトと発音しても良いことにします。\nなおキビバイトとキロバイトの容量差は2%しかありませんので、通常この違いに神経質になる必要はありません。\nギガバイトとギビバイトになると、7%の違いがありますので、ちょっと無視できないかもしれません。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#cpuの働き-1",
    "href": "programming2025/slide-programming-1.html#cpuの働き-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "一方、CPUはレジスタと呼ばれる記憶装置を複数内臓しています。\nレジスタは、プログラム内の命令やデータ、メモリのアドレスなどを格納することができます。\nCPUはメモリに読み込まれたプログラムの中の命令をレジスタに読み込こんで実行したり、メモリのなかのデータをレジスタに読み込んで演算をほどこしたり、演算の結果をメモリに書き込んだりすることでコンピュータを動かしています。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#cpuの働き-2",
    "href": "programming2025/slide-programming-1.html#cpuの働き-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "レジスタにはプログラマがプログラムから直接操作できるもの(十数個ある)と操作できないものがあります。\nプログラマが意識しなくてはならないのは前者の操作できるレジスタだけです。\n具体的にどのようなレジスタがいくつあるのかについては、CPUによって違ってきます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#cpuの働き-3",
    "href": "programming2025/slide-programming-1.html#cpuの働き-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "レジスタは、メモリと全く同じように0と1の情報を格納できます。\nレジスタには、64ビットコンピュータでは64ビット=8バイトの情報を格納することができます。\n32ビットコンピュータでは4バイトです。\nしたがって、プログラムが一つのレジスタを使って一度に処理できるデータの量は64ビットコンピュータなら最大8バイト、32ビットコンピュータなら最大4バイトです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#cpuの働き-4",
    "href": "programming2025/slide-programming-1.html#cpuの働き-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ただし64ビットレジスタは下位の32ビットを使って32ビットレジスタとしても動作できるようになっています。\n従って、64ビットコンピュータでも、32ビット仕様のOSやアプリケーションが動作します。\n32ビットレジスタのサイズが4バイトであることに合わせて、32ビットOSはメモリのアドレスを4バイトで表現します。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#cpuの働き-5",
    "href": "programming2025/slide-programming-1.html#cpuの働き-5",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "2進数表記\n16進数表記\n10進数表記\n\n\n\n\n最小の数字\n0b0\n0x0\n0\n\n\n最大の数字\n0b1111…1111\n0xffffffff\n4,294,967,295=2の32乗-1\n\n\n\n\n0xffffffff=4,294,967,295=0b1111…1111であることはPythonで簡単に確かめることができます。\n\n&gt;&gt;&gt; 0xffffffff\n4294967295\n&gt;&gt;&gt; bin(0xffffffff)\n'0b11111111111111111111111111111111'"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#cpuの働き-6",
    "href": "programming2025/slide-programming-1.html#cpuの働き-6",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "4バイトの数値が表現できるメモリアドレスの範囲は、上記の表にあるように0～2の32乗-1=4×2の30乗-1です。\nメモリは1区画あたり1バイトの容量をもつので、32ビットOSでは、4×2の30乗バイト、すなわち4GiBまでしか扱うことができません。\nしたがって、それ以上のメモリを物理的に搭載しても、4GiBを超える部分はOSによって認識してもらえません。\n一方、64ビット対応したOSでは、メモリアドレスの表現に8バイト数値を使用します。\nしたがって0～2の64乗-1までのアドレスを使うことができます。\nこれは極めて巨大な数ですので、64ビットOSでは、実質任意に大きなメモリを使用できます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#マシン語-1",
    "href": "programming2025/slide-programming-1.html#マシン語-1",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "プログラムがメモリに読み込まれたあと、プログラムを構成する命令は、一つずつCPUに読みだされて実行されていきます。\n\n\n\n\nregister"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#マシン語-2",
    "href": "programming2025/slide-programming-1.html#マシン語-2",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "レジスタは0と1しか格納できないので、命令と命令からなるプログラムもまた、0と1の列でなくてはなりません。(当然、列の長さは8の倍数です。)\nこうした、CPUが理解できる、0と1で構成された命令をマシン語と呼びます。\n試しに、プログラムが実際にどのようなマシン語になっているかをディスプレイに打ち出してみることができます。\nこれをダンプ(dump)と言います。\nたとえば、画面に”Hello, World!“と打ち出すプログラムの最初の36バイトをダンプしてみると、以下のようになります。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#マシン語-3",
    "href": "programming2025/slide-programming-1.html#マシン語-3",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "01111111 01000101 01001100 01000110 00000001 00000001\n00000001 00000000 00000000 00000000 00000000 00000000\n00000000 00000000 00000000 00000000 00000010 00000000\n00101000 00000000 00000001 00000000 00000000 00000000\n00010100 00000011 00000001 00000000 00110100 00000000\n00000000 00000000 10100100 00011010 00000000 00000000"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#マシン語-4",
    "href": "programming2025/slide-programming-1.html#マシン語-4",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "このように、マシン語は人間にとっては非常に分かりづらいので、マシン語を直接操作しなくてもプログラムが作れるように、C言語などのプログラミング言語が作られました。\n余談ですが、64ビット版のWindows 10にはダンプをするためのツールが標準搭載されていないので、ダンプしたい人はそれ専用のツールを別途手に入れる必要があります。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#マシン語-5",
    "href": "programming2025/slide-programming-1.html#マシン語-5",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "一方Linuxにはダンプのためのコマンドが標準で搭載されています。\nターミナルで次のように入力すれば実行可能ファイルをダンプできます。\n\nxxd -b a.out\n\nここでa.outが実行可能ファイルの名前です。-bは2進数でダンプするオプションです。このオプションを付けないと、結果は16進数で表示されます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#プログラミング言語の種類",
    "href": "programming2025/slide-programming-1.html#プログラミング言語の種類",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "プログラミング言語を分類する方法は色々ありますが、まず覚えた方が良いのが、コンパイル型言語とインタープリタ型言語の違いです。\n\n\n\n\n\n\n\n\n\n\nコンパイル型\nインタープリタ型\n\n\n\n\n実行速度\n高速\n低速\n\n\nコンパイル要不要\n必要\n不必要\n\n\n例\nC言語、C++、FORTRAN、RUSTなど\nPython、R、Ruby、Perl、JavaScriptなど\n\n\n\n\n\nたとえばC言語のようなコンパイル型言語で”Hello, World!“を出力するプログラムについて考えましょう。その場合、まず次のようなプログラミング言語で書かれたテキストファイル（ソースファイルあるいはソースコードという）を準備します。\n#include &lt;stdio.h&gt;\nint main(){\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\nこのファイル名をhello.cとしましょう。その後、コンパイルという操作により、このファイルを機械語に変換します。この操作を実行するソフトウェアのことをコンパイラと呼びます。たとえばLinuxには通常GNU C/C++ Compilerというコンパイラがインストールされていて、次のコマンドでコンパイルを行うことができます。\ngcc hello.c\nコンパイルを行うと、a.outという名前のマシン語で書かれたファイルが作成されます。これを実行可能ファイルと呼びます。厳密には、hello.cをマシン語にコンパイルしただけでは実行ファイルにはならず、オブジェクトファイルと呼ばれるマシン語で書かれたファイルが出来上がります。コンパイラはさらにリンクという作業を行い、出来上がったオブジェクトファイルに必要な付属品を色々とくっつけて実行可能ファイルを作ります。コンパイル型の言語で書かれたソースファイルは直接実行することはできず、かならずコンパイルして実行可能ファイルを作る必要があります。\n\n\n\ncompile\n\n\n実行可能ファイルは、CPUが直接解釈可能なマシン語で書かれているため、非常に高速に動作します。一方で、大きなプログラムはコンパイルに大変時間がかかるという欠点があります。また実行可能ファイルを構成するマシン語は、CPUのレジスタを直接操作する命令の集まりですので、CPUの異なるコンピュータでは動作しません。従って、プログラムを他のコンピュータに移植するときは、移植先のコンピュータでソースコードを再コンパイルする必要があります。\n\n\n\n一方、Pythonのようなインタープリタ型言語では、実行にコンパイルを必要としません。インタープリタ型言語では、ソースファイルは実行可能ファイルの源（ソース）ではないので、ソースファイルのことをスクリプトと呼ぶことがあります。また、インタープリタ型言語のことをスクリプト言語ということもあります。スクリプト言語では、スクリプトに記述されたコードはインタープリタと呼ばれるプログラム(アプリケーション)によって一つずつ読み取られ、実行されていきます。\n実際にはスクリプトファイルのテキスト文をそのまま読み取っていくのはインタープリタにとって不便なので、まずスクリプトはバイトコードと呼ばれるマシン語に似たものに変換されます。そのあと、バイトコードの中の命令が1行ずつ読み取られながらインタープリタによって実行されていくわけです。インタープリタはスクリプトからバイトコードを生成する作業と、バイトコードの命令を読み取って実行する作業を両方担当しています。Pythonインタープリタのうち、バイトコード実行を行う部分だけを指して、Pythonヴァーチャルマシン(PVM)と呼びます。\n\n\n\npvm\n\n\nPythonがバイトコードを生成するプロセスのことをコンパイルもしくはバイトコンパイルと呼ぶことがあるので注意が必要です。コンパイル言語でのコンパイルと違い、Pythonのバイトコンパイルはマシン語を生成しません。\n試しに”Hello world!“と印字するPythonのプログラムをバイトコンパイルしてみましょう。まず、このプログラムのPythonスクリプトは次のようになります。\nprint(\"Hello world!\")\nこのコードをバイトコンパイルして出来たバイトコードの最初の36バイトをダンプすると、以下のようになります。\n01000010 00001101 00001101 00001010 00000000 00000000 \n00000000 00000000 10101110 10001001 10011110 01100000\n00011000 00000000 00000000 00000000 11100011 00000000 \n00000000 00000000 00000000 00000000 00000000 00000000\n00000000 00000000 00000000 00000000 00000000 00000010\n00000000 00000000 00000000 01000000 00000000 00000000\nよく似ていますが、これはバイトコードであり、マシン語ではありません。Pythonヴァーチャルマシンは、このバイトコードを実行していきます。\nバイトコードの特徴は、マシン語で記述されたコンパイル言語の実行可能ファイルと違って、CPUの仕様に依存していないことです。したがって、バイトコードはそのまま他のコンピュータで実行することができます。一方で、直接レジスタに命令を送り込むコンパイル言語に比べると、ヴァーチャルマシンを介さなくてはならないスクリプト言語はかなり低速になり、場合によっては100～1000倍くらいの実行時の速度差が出てしまいます。\nしかしながら、コンパイルの必要がないので、インタープリタ言語による開発時間はコンパイル言語よりもはるかに早いのが普通です。(C言語で書かれた非常に大きなプログラムですと、コンパイルだけで数時間かかってしまうこともあります。たとえば以前node.jsというjavascriptのインタープリタをコンパイルしたときは半日くらいかかりました。)\nこのコンパイル型言語とインタープリタ型言語の違いを利用して、Python等のインタープリタ型言語でスピーディにプロトタイプを作成し、その後、少しずつコンパイル型言語に置き換えていくという開発上の作戦が取られることも良くあります。\nもう一つ、皆さんに覚えておいて欲しいのは、インタープリタそれ自体がプログラムであり、これは通常コンパイル型言語で作成(実装)されているということです。たとえばPythonのインタープリタで最も一般的なのはC言語で実装されたCPythonというインタープリタで、ほとんどの方が使っているPythonはこれです。CPythonのソースコードは公開されているので誰でも読むことができ、C言語を知っていれば内容を理解できます。他にもJavaで実装されたJythonというインタープリタもあります。\n\n\n\nなおプログラミング言語の中には、アセンブリ言語という特別なタイプの言語があります。アセンブリ言語は、01の並びであるマシン語を分かりやすい記号の列に「直訳」したものです。直訳したものですので、マシン語とアセンブリ言語はどちらの方向にでも変換可能です。アセンブリ言語からマシン語を生成する作業をアセンブル、その逆を逆アセンブルと言います。アセンブルを行うためのソフトウェアをアセンブラと呼びます。アセンブリ言語の特徴の一つは、マシン語の直訳であるため、レジスタの操作をプログラマが明示的に行う必要があるということです。\nたとえば、次のC言語のプログラムは、aという変数に1を代入し(正確には1という値で初期化し)、そのあとaに2を足すというだけのプログラムです。\nint MyAdd(){\n  int a = 1;\n  a = a + 2;\n  return a;\n}\nこれをコンパイルして出来たオブジェクトファイルを逆アセンブルすると、次のようなアセンブリ言語のコードが得られます。\npush   rbp\nmov    rbp,rsp\nmov    DWORD PTR [rbp-0x4],0x1\nadd    DWORD PTR [rbp-0x4],0x2\nmov    eax,DWORD PTR [rbp-0x4]\npop    rbp\nret\n\n\n\nassembly\n\n\nアセンブリ言語にはいくつか方言がありますが、ここではNASM(Netwide Assembler)という表記を用いています。ここでは詳しく説明できませんが、上のコードにおいて、rbpやrsp、eaxは全てレジスタの名前を表します。このように、アセンブリ言語では、レジスタを直接操作することが必要になってきます。(ちなみに”DWORD PTR [RBP-0X4]“などはメモリの領域を表します。)\nアセンブルと違ってコンパイルは不可逆変換なので、実行可能ファイルからコンパイル前のソースコードを復元することはできません。従って実行可能ファイルを分析するときは、通常、逆アセンブルを行ってアセンブリ言語に翻訳し、これを読解していきます。例えば、コンピュータウィルスの性質を解析する際にこういったスキルが必要になります。\nLinuxを使っている人は次のようにしてコンパイルと逆アセンブルを行うことができます。上のソースファイル名をmyadd.cとします。\ngcc -c myadd.c\nobjdump -d -M x86-64,intel myadd.o\nここでmyadd.oはコンパイルによって生成されたオブジェクトファイルです。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#抽象度",
    "href": "programming2025/slide-programming-1.html#抽象度",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "アセンブリ言語のように、レジスタやメモリといったハードウェアを直接操作する言語を低水準言語と呼びます。低水準言語は、抽象度が低い言語と表現されることもあります。一方、Pythonのように、レジスタやメモリと言ったものをプログラマが直接意識することなくプログラミングできるような言語は、高水準言語と呼ばれ、抽象度が高いと言われます。一般に、インタープリタ型言語のほうがコンパイル型言語よりも抽象度が高い傾向があります。また、時代が進むにしたがって、より高水準で抽象度の高い言語が登場してきたと言えます。\n高水準言語や低水準言語というのは、相対的なものであるととらえた方が良いでしょう。たとえば、従来C言語はアセンブリ言語と比較して高水準言語であると言われてきましたが、言語の高水準化が進むにつれ、たとえばPython等に比べると低水準言語であると言われるようにもなってきました。というのも、C言語ではレジスタを意識することはほとんどありませんが、メモリはかなり意識しないとコードが書けないからです。一方、Pythonでは、C言語よりも抽象度が高く、比較的メモリを意識しなくてもプログラミングができるようになっています。それでも、以降の講義で論じるように、メモリをある程度意識することはPythonを正しく使う上で重要であると言えます。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#プログラミング上達のコツ",
    "href": "programming2025/slide-programming-1.html#プログラミング上達のコツ",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "当たり前ですが、プログラミングの上達において最も大切なことは、「プログラミングを楽しむ」ことだと思います。そのために大切なことは、「ストレスなくコーディングする」ということに尽きると思います。そして、そのためには、以下の2点が重要であると筆者は考えます。\n\n正しいタイピングをする\nエディターのキーバインドをマスターする\n\nもう一つコツを挙げるとすれば、誰もが言うことですが、コードを試すときは、写経するということです。写経とは、コードをコピー＆ペーストしたり、すでに他人が入力したコードを実行するのではなく、自分でタイピングして書き写すことです。\n\n\n正しいタイピングとは、タッチタイピング（いわゆるブラインドタッチ）のことです。タッチタイピングを解説したサイトはインターネットにたくさんありますので、ここでは改めて解説しません。以下の項目に注意して練習を重ねてください。\n\n最初は決して速く打とうとしてはいけない\n同じキーはいつも同じ指で叩く\nキーを叩くときは、基本そのキーに最も近い指で叩く\nキーボードを見ないでタイプするトレーニングをする\n人差し指～小指すべて使う\n\n数字や記号はつらいので、まずはアルファベットだけキーボードを見ないで打てるようになるように練習しましょう。そのうち見ないで打てるキーの数が増えてきます。タイピングソフトなどは必要ありません。ゆっくりで良いので、タッチタイピングの基本を守りつつプログラミングや文書作成をしていれば、自然に上達していきます。\n上達につれてタイプの速度は上がってきますが、目安として大体1分間に200タイプくらいでスピード的には十分ではないでしょうか。重要なのはストレスを無くすことであって、速度を上げることではありません。ゆっくりでもキーボードを見ずに正確に打てるようになれば、視線の移動がほとんど必要なくなるので、コーディング中に感じるストレスは圧倒的に小さくなります。\n\n\n\nコーディングのストレスを軽減するには、正しいタイピングを心がけるだけでなく、キーバインドを覚えることが重要です。本講義で言うキーバインドとは、編集中に文書の中を移動したり、編集に関連する様々な機能を呼び出したりするためのキーボードショートカットのことです。\nプログラミングの世界には大きく分けて、2種類のメジャーなキーバインドがあります。1つはEmacsキーバインド、もう一つはviキーバインドです。これらは、それぞれ、Emacs、viというエディターで用いられているキーバインドですが、多くのエディターでこれらの2つのキーバインドを使用することができるようになっています。\nEmacsキーバインドは直観的で覚えやすいのが特徴で、viキーバインドは「速い」のが特徴です。筆者はプログラミングにEmacs、設定ファイルなどの編集にviを使うという風に使い分けていますので、本講義でもプログラミングのためにはEmacsキーバインドを用いることを推奨したいと思います。Emacsキーバインドについては次回VS Codeを操作するときに詳しく説明します。\n\n\n\nコードを写経することにより、自分で書いてみると、そっくりそのまま書き写したはずがうまく動作しないということが往々にして生じます。その度に、「どこが間違っていたのか」考えさせられることになり、細部に目が行くことになります。また、単純にタイピングの練習にもなります。\n写経は、最初のうちは苦行かもしれません。前時代的なトレーニングと思われるかもしれません。なかなか先に進めないのでじれったい気持ちになるかもしれませんが、これは必要なプロセスです。どれだけプログラミングが上手になっても、皆さん写経をしておられます。逆に写経がストレスなくできるようになったら、一人前だと考えてください。\nしたがって、本講義では、入力済みのコードを配布しないことにします。どうしてもコピー＆ペーストが必要なときは、このサイトから行えばよいでしょう。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#まとめ",
    "href": "programming2025/slide-programming-1.html#まとめ",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "今回は、以下の事項について学びました。\n\nPythonを学ぶ意義\nPythonを動かす2種類の基本的な方法\n本講義の目標\nプログラムがどのように動いているか\nプログラミング言語にはどのようなものがあるか\nプログラミング上達のコツ\n\n今回の講義でPythonのプログラムがどのように動いているか、大体分かったと思います。一方で、一つ一つのPythonの文がどのように動作しているのかまでは説明しませんでした。そういった詳細については今後の講義で解き明かして行くことにしましょう。\n基本的なプログラミングの練習は、基本的に独学でも可能なものです。自宅や研究室のパソコンにもPythonをインストールし、教科書を参照しながらPythonの操作をしっかりと練習しておいてください。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#参考書",
    "href": "programming2025/slide-programming-1.html#参考書",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "『プログラムはなぜ動くのか(第2版)』(矢沢久雄 著/日経ソフトウェア監修) (2007) 日経BP社. ISBN 978-4-8222-8315-5."
  },
  {
    "objectID": "programming2025/slide-programming-1.html#宿題ホームワーク",
    "href": "programming2025/slide-programming-1.html#宿題ホームワーク",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "本講義では提出しなくてよい宿題のことを「宿題」または「ホームワーク」と呼ぶことにします。今回はホームワークとして、以下を出題します。\n\n『独習Python』の第1章『イントロダクション』を読みなさい。\nそこに書かれている手順に従って、AnacondaとVS Codeを自分のパソコンもしくは研究室のパソコンにインストールしなさい。\nAnacondaをインストールしたパソコンでREPLを起動し、様々な計算式を打ち込んでみなさい。\nREPLに様々なPythonコードを打ち込み、期待された結果が得られるか試してみなさい。\n『2の補数表現』や『浮動小数点数』、『エンディアン』といった言葉に聞き覚えがない人は、本ページ末尾の補遺を読んでおいてください。\n\nなお、LinuxユーザーはAnacondaをインストールしないことをお勧めします。X Windowシステムが壊れて再起不能になることがあります。\nAnacondaはある程度スペックを要求します。CPUはIntel Core i5以上、メモリは最低でも8GBは必要かと思います(16GB推奨)。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#課題アサインメント",
    "href": "programming2025/slide-programming-1.html#課題アサインメント",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "本講義では、提出しなければならない宿題のことを「課題」もしくは「アサインメント」と呼ぶことにします。今回の課題はありません。課題は全てGitHubのアサインメント機能を使って提出していただきますので、課題が出題されるのはGitHubについて学ぶ第3回目以降です。"
  },
  {
    "objectID": "programming2025/slide-programming-1.html#補遺メモリ上での数の表現",
    "href": "programming2025/slide-programming-1.html#補遺メモリ上での数の表現",
    "title": "第1回 プログラミング概論",
    "section": "",
    "text": "ここでは、メモリの上で整数や小数がどのように表現されているかを説明します。\n\n\n符号なし整数とは、正整数のみを表すことができるデータ型のことです。符号なし整数がメモリ上に記録される方法は特に難しいことはありません。単に正整数の2進数表現がそのまま格納されているだけです。例えば、2バイト=16ビットの領域に14という整数が格納されるときは、\n00000000 00001110\nのように格納されます。\n\n\n\n符号つき整数では、負の数と正の数を表すことができます。符号付き整数では、最も桁の大きいビットを符号を表すために用います。この符号ビットが0ならば0か正の整数を、1ならば負の整数を表します。残りの桁は、正整数ならば、符号なし整数と同じで、元の正数の2進数表現になっています。\n一方、負の数の場合は、元の数の絶対値の2の補数になっています。数nの2の補数とは、nのビット(0と1)を反転して、1をプラスしたものです。\nたとえば、14は上記のように表されますので、そのビットを反転したものは、\n11111111 11110001\nとなりますので、これに1を足したものは、\n11111111 11110010\nになります。これが-14の2の補数表現であり、メモリ上で-14という負数はこのように格納されています。\n実際、14と-14を足すと0になることが次のようになります。\n  00000000 00001110\n+ 11111111 11110010\n-------------------\n1 00000000 00000000\n一番左のあふれた一桁は無視されるので、和は0になることが分かります。\n符号つき整数の絶対値の上限は、符号なし整数の約半分になります。\n\n\n\nバイト数\n符号つき整数\n符号なし整数\n\n\n\n\n1\n-128 ～　127\n0 ～ 255\n\n\n2\n-32,768 ～ 32,767\n0 ～ 65,535\n\n\n4\n-2,147,483,648 ～ 2,147,483,647\n0 ～ 4,294,967,295\n\n\n8\n-2**63 ～ 2**63-1\n0 ～ 2**64-1\n\n\n\n即席ですが、任意の整数を2の補数表現に変換するPython関数を作りましたので参考にしてください(バグを見つけたら教えてください。)関数についてはまだ学んでいないので、現時点でこの関数を使える必要はありません。\n# %%\n# 整数を2の補数表現に変換する関数\ndef int_to_bits(num,length,endian='big'):\n    if type(num) is int:\n        num_bytes = num.to_bytes(length,endian,signed=True)\n        num_bin = bin(int(num_bytes.hex(),16))\n        if len(num_bin)-2 &lt; length * 8:\n            bit_str = (\"0\"*(length*8-len(num_bin)+2)) + num_bin[2:]\n        else:\n            bit_str = num_bin[2:]\n        byte_list = [bit_str[8*i:8*i+8] for i in range(length)]\n        print(\" \".join(byte_list))\n    else:\n        print(\"The first argument must be an integer.\")\nこの関数は次のように使います。\nint_to_bits(整数,バイト数,エンディアン)\nエンディアンは指定しなくても構いません。指定しない場合はビッグエンディアンになります(エンディアンについては下で説明しています)。\nたとえば、4バイト符号つき整数の-255を2の補数表現にするには、次のようにします。\nint_to_bits(-255,4)\n# 出力\n11111111 11111111 11111111 00000001\nリトルエンディアンにするときは、第3引数を’little’に指定してください。\nint_to_bits(-255,4,'little')\n# 出力\n00000001 11111111 11111111 11111111\n\n\n\n小数は、浮動小数点数というデータ型でメモリに格納されます。浮動小数点数には単精度浮動小数点数と倍精度浮動小数点数があります。単精度では一つの数値に32ビット(4バイト)、倍精度では64ビット(8バイト)を使います。\n浮動小数点数がどのように小数をメモリ上で表現するのか、単精度の場合を例にとって説明します。\nまず、全ての実数は次のように表現できることに注意しましょう。\n[符号] (m)×(10のn乗)\nただし、mは0.xxx...という形式の10進数小数です。たとえば、-123.45は、次のように表すことができます。\n- (0.12345)×(10の3乗)\nmを仮数、nを指数と呼びます。\n全く同様に、全ての実数は次のように表現できます。\n[符号] (m) * (2のn乗)\nただし、mは1.xxx...という形式の2進数小数です。たとえば、2進数小数101.1011は、次のように表すことができます。\n+ (1.011011)×(2の2乗)\nそこで単精度浮動小数点では、下図のように32ビットを上の桁から順に1ビット、8ビット、23ビットに区切り、それぞれ符号、指数、仮数を表すのに使います。\n\n\n\nfloat\n\n\nただし、指数は常に1.xxx...という形をしているので、\"1.\"を省略し、xxx...の部分だけを23ビットに記憶します。たとえば、仮数が1.011011であれば、浮動小数点数の仮数部分23ビットは\n0110110 00000000 0000000\nのようになります。また、指数部分は、正負どちらの値でもありえますが、ここでは負の数を表すのに補数は使いません。代わりにイクセス表現を使います。イクセス表現では、指数部分8ビットを0～255の符号なし整数と見なしたとき、そこから、ちょうど中間の値127を引いたものを実際の指数とする表現方法です。\nたとえば、指数部分に記憶されているビット列が次のようになっていたとします。\n10000001\nこれは10進数符号なし整数に読み替えると129です。ここから127を引くと2ですので、実際の指数は2ということになります。\nまとめると、符号部分のビット、指数部分のビット列、仮数部分のビット列がそれぞれ\n# 符号ビット\n1\n# 指数部分8ビット\n10000001\n# 仮数部分23ビット\n01101100 00000000 0000000\nのようになっているとき、この単精度浮動小数点数は、\n[-] (1.011011)×(2の2乗) = -101.1011\nを表すことになります。これを10進数で表すと、-5.6875になります。言い換えると、-5.6875という小数は、浮動小数点数によって\n1-10000001-01101100 00000000 0000000\nという32ビットでメモリ上に記憶されていることになります。\nさて、上記の仮数部分を16進数で表し、指数部分をイクセス表現でなく実際の指数(10進数)に書き換えると、次のようになります。\n1-(+2)-6c 00 00\nただし右端の0だけは3ビットしかありませんので注意してください。\n倍精度の浮動小数点数ですと、仮数部分は52ビット=6バイト+4ビットありますので、-5.6875はメモリ上で、\n1-(+2)-6c 00 00 00 00 00 0\nと記憶されます。“6c”に続いて0が11個あることに注意してください。Pythonでは、この表現を次のようにして出力することができます。\n&gt;&gt;&gt; (-5.6875).hex()\n'-0x1.6c00000000000p+2'\nここで、pのあとの+2が指数、0x1.のあとの6c00000000000が指数部分に記録されているビット列を表します。\n\n\n\nエンディアンは、複数バイトを使う数値や文字が、どのバイトから先にメモリに格納されるかを表します。下の桁のバイトから順に格納されていく方式をリトルエンディアン、上の桁のバイトから順に格納されていく方式をビッグエンディアンと呼びます。エンディアンはCPUに依存しますが、現在パソコンで使われているCPUの多くはリトルエンディアン方式です。\nリトルエンディアンでは、下の桁のバイトのほうが上の桁よりもメモリ上で若いアドレスに格納されますので、例えば16ビット整数型としてメモリに保存された整数14をダンプすると、次のように、バイトが入れ替わって画面に表示されます。\n# 14はリトルエンディアンではこう見える\n00001110 00000000\n一方、ビッグエンディアンでは、上の桁のバイトのほうが下の桁よりも若いアドレスのメモリに格納されますので、14が格納されたメモリ領域をダンプすると、次のように画面に表示されます。\n# 14はビッグエンディアンではこう見える\n00000000 00001110\nこのように、下の桁から若いアドレスに順番に格納していくリトルエンディアン方式は、発想において自然ですが、ダンプしたときにひっくり返って表示されるので、読みにくいという難点があります。一方ビッグエンディアンでは表示された順そのままで読むことができます。\nエンディアンは普段はほとんど意識する必要がありませんが、文字や数値のバイト列表現を扱うときに、どうしても避けられない話題となってきますので、頭の片隅においておく必要があります。"
  },
  {
    "objectID": "programming2025/programming-4.html",
    "href": "programming2025/programming-4.html",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "第4回 変数とメモリ\n\n代入(付値)とは何か\nハコ型代入\nラベル型代入\n参照カウンタ\nCopy on modifyメカニズム\n\n練習1\n\nPythonの挙動\nデバッグモードの活用\nステップイン\n変更と代入の違い\n\n練習2\n練習3\n\nミュータブルとイミュータブル\nイミュータブルオブジェクトの再利用\n動的型付け\n変数にまつわる用語\nまとめ\n参考書\n\n\n\n\n本講義の受講者にとって、Rの次のような操作は至極ありふれたものだと思います。\n# コード1\nx &lt;- c(1,2,3)\ny &lt;- x\nx[2] &lt;- 5\nprint(x)\nprint(y)\n上記のコマンドを実行したときに、どのような結果が出力されるかを答えられない人はいないでしょう。実際にRの対話的インタープリタを起動するか、VS Code上で実行してみれば良いでしょう。\n&gt; print(x)\n[1] 1 5 3\n&gt; print(y)\n[1] 1 2 3\n&gt; \nしかし、コード1で実際に何が起きているのかを正しく説明できる人はあまり多くないと思います。多くの人が次のように考えているのではないでしょうか？\n\n変数xにベクトル(1,2,3)が代入される\n変数yに変数xの値、つまり(1,2,3)がコピーされる\n変数xの第2要素が5に書き換えられる\n変数xの値が出力される\n変数yの値が出力される\n\nしかし、実際に起きていることは、上記と少し違います。今回の目標はこれを理解することとします。今回の講義で、変数に値を代入するときRやPythonでは何が起きているのかが、ある程度分かるようになります。第1回で学んだメモリやアドレスの概念が必須になります。\n\n\n\n上記の説明がどのように間違っているかを説明する前に、初学者向けの書籍に良く見られる「箱の比喩」を用いた代入の説明について解説しておきます。\n箱を用いた説明とは、次のようなものです。\n\n下図のように、変数xに1を代入するということは、xという箱に1という値を入れることであり、yにxを代入するということは、xに入っている値1をコピーしてyという箱に入れることである。\n\n\n\n\nbox-type substitution\n\n\nこのような説明は、C言語のようなプログラミング言語では正しい比喩ですが、RやPythonでは正しくありません。特にPythonでは正しい理解を妨げる説明です。\nC言語では、次のようにして、予めxやyが整数であることを変数の作成時に宣言します\nint x,y; // x,yが整数であることを宣言\nソースファイルにこの宣言を見つけたCのコンパイラは、マシン語に変換する際に、xやyといった変数名をメモリのアドレス(実際にはメモリ領域)あるいはレジスタ名といったもので置き換えてしまいます。\nしたがって、\ny = x;  // xの値をyに代入\nという代入操作は、あるアドレスのメモリ領域に格納されている値を別のメモリ領域にコピーすることを意味します。したがって、メモリ領域を箱と考えれば、箱の比喩は正しく実際に起こっていることを表しています。\n\n\n\nプログラミングの世界では、124や”c”のような具体的な数値や文字だけではなく、それを操作するための付属的な情報を合わせもつものをオブジェクトと呼びます。\nオブジェクトは、表面的には数値や文字ですが、実際には数値や文字を格納する領域以外にもメモリ領域を占有しています。C言語の整数や文字列は、値を格納する分だけのメモリ領域しか占有しないので、オブジェクトではありません。一方、PythonやRの数値や文字列はすべてオブジェクトです。\nRやPythonでの代入の説明でより現実に近いのは以下のような比喩です。\n\n下図のように、変数xに1を代入するということは、1というオブジェクトにxというラベルを貼り付けることであり、変数yにxを代入するという操作は、ラベルxがついているオブジェクトにもう一つyという別のラベルを貼り付けることである。\n\n\n\n\nlabel-type substitution\n\n\nこの正しい見方では、1という一つのオブジェクトにx、yという二つのラベルが貼り付けられています。このようなラベルのことを参照(reference)と呼ぶことがあります。また、変数xやyはオブジェクト1を参照しているということもあります。\nそれでは、Rでの代入操作(y &lt;- x)がこのような「ラベル張り」であるということを確かめてみましょう。そのために、Hadley Wickhamが作ったpryrパッケージをインストールしましょう。\ninstall.packages('pryr')\npryrを読み込むと関数addressを使うことができるようになります。addressは、引数として与えた変数(参照)が指し示しているオブジェクトのアドレスを返す関数です。実際に使ってみましょう。\nlibrary(pryr)\nx &lt;- c(1,2,3)\naddress(x)\ny &lt;- x\naddress(y)\n上のように対話的インタープリタで入力すると、次のような出力が得られます。\n&gt; address(x)\n[1] \"0x183f3110\"\n&gt; y &lt;- x\n&gt; address(y)\n[1] \"0x183f3110\"\n&gt; \n出力が二つ得られていますが、一つ目の値0x183f3110は、xというラベルが貼り付けられているベクトル(1,2,3)というオブジェクトが格納されているメモリのアドレスを16進数で表したものです（具体的なアドレスの値は、実行時ごとに異なります）。また、二つ目の出力は、yというラベルが貼り付けられているオブジェクトのメモリ上のアドレスですが、これも0x183f3110となっており、xと同じオブジェクトにyが貼り付けられているということが分かります。\nこのように、C言語とは違ってx、yという別個のメモリアドレスが存在するわけではないことが分かります。\n\n\n\nところが、RはCopy on modifyという機構を備えていて、ラベル張りであることを余り意識させない作りになっています。Copy on modify機構について説明するために、まずは参照カウンタ(リファレンスカウンタ）について説明しましょう。以下、Rのヴァージョン3系列(3.5,3.6等)を仮定して話を進めますが、出力はヴァージョン4でも同じになるはずです。(ヴァージョン3と4の違いは課題で取り扱います。)\nベクトルのようなRのオブジェクトは、自分に何枚のラベルがついているかに関する情報を内部に格納しています。換言すると、Rオブジェクトは、自分がいくつの変数(xやy)に参照されているかを知っています。オブジェクトを参照している変数の数の事を参照カウントと呼びます。Rオブジェクトは、内部に自分自身の参照カウントを記憶する参照カウンタを持っています。\n参照カウンタの値は、関数pryr::refsによって調べることができます。\n&gt; rm(list=ls()) #一応全変数を削除\n&gt; x &lt;- c(1,2,3)\n&gt; refs(x)\n[1] 1\n&gt; y &lt;- x\n&gt; refs(x)\n[1] 2\n&gt; refs(y)\n[1] 2\n&gt; \n\n\n\nさて、次のようにxに代入したベクトル(1,2,3)の内容を書き換えようとするとき、参照カウントが1の場合と2以上の場合では、Rは異なる挙動を示します。\nまずxの参照カウントが1の場合です。\nrm(list=ls()) #全変数を削除\nx &lt;- c(1,2,3)\naddress(x)\nx[2] &lt;- 5\naddress(x)\n上記を実行すると、次のような出力が得られます。\n&gt; x &lt;- c(1,2,3)\n&gt; address(x)\n[1] \"0x17f14dd8\"\n&gt; x[2] &lt;- 5\n&gt; address(x)\n[1] \"0x17f14dd8\" #xのアドレスは変わらない\n&gt; \n上記のように、xの内容を書き換える前後で、xは同じオブジェクトを参照しています。\nところが、xの参照カウントが2以上のとき、つまりxと同じオブジェクトを参照する変数yが存在するとき、異なる挙動が起きます。次を実行してみましょう。\nrm(list=ls()) #全変数を削除\nx &lt;- c(1,2,3)\ny &lt;- x\naddress(x)\naddress(y)\nx[2] &lt;- 5\naddress(x)\naddress(y)\n上記を実行すると、次のような出力が得られます。\n&gt; rm(list=ls()) #全変数を削除\n&gt; x &lt;- c(1,2,3)\n&gt; y &lt;- x\n&gt; address(x)\n[1] \"0x17ecbc78\"\n&gt; address(y)\n[1] \"0x17ecbc78\"\n&gt; x[2] &lt;- 5\n&gt; address(x)\n[1] \"0x17ecb598\"  #xのアドレスが変わった\n&gt; address(y)\n[1] \"0x17ecbc78\"\n&gt; \n上記のように、参照カウントが2以上になると、オブジェクトの内容を変更する際に、あらたなメモリ領域が確保され、オブジェクトがコピーされてから変更が行われることが分かります。このメカニズムをCopy on modifyと呼びます。\nCopy on modify機構のおかげで、Rのプログラマは、オブジェクトがいくつの変数に参照されているかをあまり意識する必要がありません。xの内容を修正したときに、うっかりyの内容まで修正してしまう危険がないわけです。\n\n\n\ncopy_on_modify\n\n\n\n\n\n次のRコードは、二つの参照を持つリストオブジェクトの内容を変更するものである。pryr::address関数を用いて、上記のコードでCopy on modify機構が働いているかどうか確かめなさい。\nrm(list=ls()) # 全変数を削除\nx &lt;- list(a='A',b='B')\ny &lt;- x\nx[['a']] &lt;- 'AA'\n次はさらに複雑な例である。xはリストを要素にもつリストである。この入れ子になった内側のリストに変更を加えたとき、Copy on modifyは働くか？確かめなさい。\nrm(list=ls())\nx &lt;- list(a=list(b='B',d='D'))\ny &lt;- x\nx[['a']][['b']] &lt;- 'BB'\n\n\n\n\n\nところが、PythonにはCopy on modify機構がありません。どういうことかというと、オブジェクトがいくつの変数に参照されているかにかからわず、オブジェクトの内容変更に伴うコピーは自動的には起きません。\nこれを実際に確かめてみましょう。 Pythonにはベクトル型は存在しないので、代わりにリストを使いましょう。たとえば1,2,3という三つの整数を要素にもつリストは次のように作成します。(リストについては、次回詳しく取り上げます。)\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x\n[1, 2, 3]\nRのベクトルでは最初の要素にアクセスするにはx[1]と書きますが、pythonのリストではx[0]と書きます。つまり、インデックスは0からはじまります。それを除けばインデクシングのルールはRのベクトルと非常によく似ています。\n&gt;&gt;&gt; x\n[1, 2, 3]\n&gt;&gt;&gt; x[0]\n1\n&gt;&gt;&gt; x[1]\n2\n&gt;&gt;&gt; x[2]\n3\nさてそれでは準備が出来たので実験を開始しましょう。 PythonにおけるRのpryr::addressに対応する関数はビルトイン関数のidです。idは、変数が参照するオブジェクトのアドレスを10進数で返します。まずはpythonの変数が参照であることを確認しましょう。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; id(x)\n2080340453760\n&gt;&gt;&gt; id(y)\n2080340453760\n&gt;&gt;&gt; id(x) == id(y)\nTrue\n最後のid(x) == id(y)という式は、Rと同じで、左辺と右辺が正しければTrue、違っていればFalseを返す二項演算です。上記より、確かにpythonの代入がラベル型であることが分かります。なお、id(x) == id(y)は、次のように書くこともできます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n“x is y”は、xとyが同じオブジェクトを指しているときにTrue、そうでないときにFalseとなります。\nそれでは次に、Copy on modifyが働かないことを確かめましょう。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x[1] = 5\n&gt;&gt;&gt; x\n[1, 5, 3]\n&gt;&gt;&gt; y   # yまで変化した\n[1, 5, 3]\n&gt;&gt;&gt; x is y # Copy on modifyは起きていない\nTrue\n上記のように、複数の参照をもつオブジェクトの内容を変更すると、それを参照する全ての変数の内容が変わってしまいます。下図のように、Rとは違ってPythonはCopy on modifyを行わないからです。\n\n\n\nnot_copy_on_modify\n\n\n\n\n\nオブジェクトのメモリアドレスやオブジェクトの同一性がプログラムの中でどのように変化していくかを観察するには、VS Codeのデバッグモードを用いると分かりやすいです(condaコマンドのパスを通している必要があります)。\nGitHubディレクトリの下に、varsというディレクトリを作成し、VS Codeで開きましょう。debug.pyというファイルを作成し、次のように記述してください。\nx = [1,2,3]\ny = x\nx[1] = 5\npass\npassは、『何もしない』を意味します。\n次に、VS Codeの画面左側の虫のマークをクリックしてください。\n\n\n\nbug\n\n\n『実行とデバッグ』というボタンが現れますが、そのすぐ下の、『launch.jsonファイルを作成します』をクリックしてください。\n\n\n\nlaunch_json\n\n\nDebug Configurationというパレットが立ち上がりますので、一番上の、Python File Debug the currently active Python fileを選択してください。これで、今選択しているPythonコードをデバッグすることができるようになります。launch.jsonという設定ファイルが作成されますが、閉じてください。\n開いているdebug.pyファイルの1行目の左がわをクリックして、赤い印をつけましょう。これをブレークポイントと呼びます。デバッグをするときは、このブレークポイントを一つ以上設定します。\n\n\n\nbreak_point\n\n\n次に、『ウォッチ式』を定義します。画面左側中程にある『ウォッチ式』ペインの『＋』マークをクリックして、ウォッチ式を入力しましょう。ここでは次の3つのウォッチ式を入力してください。\n\nid(x)\nid(y)\nx is y\n\n\n\n\nwatch_eq\n\n\nウォッチ式とは、デバッグ中にリアルタイムで『ウォッチ』したい式のことです。\n以上でデバッグの準備が整いました。\n\n\n\nデバッグを起動するには、左上の緑色の三角マークをクリックします。\n\n\n\ndebug_button\n\n\nデバッグが起動すると、プログラムが実行され、ブレークポイントの行を実行する直前でストップします。また、画面上に6個のボタンが現れることに注意してください。\n\n\n\nstepin\n\n\nこれらのボタンは、左から順番に\n\n次のブレークポイントまで実行\nステップオーバー\nステップイン\nステップアウト\n再起動\n停止\n\nを表します。ステップオーバーとステップアウトは関数に関係があるので、今は説明を保留します。\nここから、ステップインという操作によって、1行ずつコードを評価しながら、ウォッチ式の値がどのように変化していくか観察していきます。\nステップインを表す下向きのやじるしをクリックしてください。すると、ブレークポイントの行が実行され、次の行へとフォーカスが移ります。\n左上の『変数』ペインのLocals欄とGlobals欄の両方にx: [1,2,3]というのが現れるはずです。\n\n\n\nvariable_pane\n\n\nこれは、変数xに[1,2,3]という値(オブジェクト)が付値されたということを表します。\n同時に、ウォッチ式のペインでは、id(x)の値に数字が現れるはずです。この値は、id(x)の値、すなわちオブジェクト[1,2,3]が位置するメモリのアドレスを表しています。\n\n\n\nwatch_eq_assigned\n\n\nyのほうはまだ代入が起きていないため、ウォッチ式id(y)の値はNameErrorとなっています。\n次に、もう一度ステップインしてください。次は、ウォッチ式id(y)の値が表示され、ウォッチ式x is yがTrueになるはずです。id(x)とid(y)の値が同じであることに注意してください。これは、xとyが同じオブジェクトを参照していることを表します。このことは、x is yがTrueになっていることからも分かります。\nもう一度ステップインすると、変数ペインのxとyの第2要素が同時に変化することに注意してください。これは、x is yがTrueだったので、予測できたことですね。\n最後にもう一度ステップインしてpassの行を実行し、デバッグを終了しておきましょう。\n\n\n\nPythonの初学者にとってちょっと分かりにくいのが、変数xが参照するオブジェクト自体の内容を修正するということと、変数xに別のオブジェクトを代入する・参照させる(参照を付け直す)という二つの操作の違いです。変更では、変数が参照するオブジェクトのアドレスは変化しませんが、代入では変化します。\n\n\n\n操作\n参照先のアドレス\n\n\n\n\nxが参照するオブジェクト自体の内容を変更\n変化しない\n\n\nxに別のオブジェクトを代入\n変化する\n\n\n\nたとえば、次の例では、xとyが同じオブジェクトを参照している状態でxに別のオブジェクトを代入しましたが、yは変化していません。代入操作では、単にxが別のオブジェクトを参照するようになるだけで、もとのオブジェクトには何の影響も与えないからです。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x # xとyは同じオブジェクトを参照\n&gt;&gt;&gt; x = [4,5,6] # xに異なるオブジェクトを代入\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y   # yは変化していない\n[1, 2, 3]\n&gt;&gt;&gt; x is y  # xとyは違うオブジェクトを指している\nFalse\n\n\n\nsubstituion\n\n\nしかしながら、ほんの少しだけコードを変えて次のようにすると、xへの操作は代入ではなく変更になります。yの内容まで変わってしまいますので注意してください。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x[:] = [4,5,6]  # スライス記法でxの内容を変更\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y   # yも変わってしまった\n[4, 5, 6]\n&gt;&gt;&gt; x is y  # xとyは同じオブジェクトを参照\nTrue\n\n\n\nslice\n\n\n変更したのは1行だけです。ここで用いたx[:]はスライス記法というもので、コロン:は「最初から最後まで、リストの全ての要素」を意味します。スライス記法については、教科書のセクション6.1.2に詳しく説明されているので読んでおきましょう。\nスライス記法がどのように機能しているのかを解説するついでに、Pythonに特有のアンパック代入も導入しておきましょう。Pythonでは、次のようにして、複数の変数に一挙に値を代入できます。\n&gt;&gt;&gt; x,y,z = [1,2,3]\n&gt;&gt;&gt; x\n1\n&gt;&gt;&gt; y\n2\n&gt;&gt;&gt; z\n3\nこれをアンパック代入と呼びます。アンパック代入については、教科書のセクション3.2.4に詳しいので読んでおいてください。\n上述のスライス記法の構文は、次のようにアンパック代入するのと実質的に同じことをやっていることになります。(実際には少し違います。)\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x[0],x[1],x[2] = [4,5,6]\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y\n[4, 5, 6]\n&gt;&gt;&gt; x is y\nTrue\nこれを見れば、スライス記法による代入が、実際にはxが指すリストオブジェクトの内容を変更してしまっているのが分かるでしょう。\n実際にはスライス記法による代入は、アンパック代入とは少し違って、左辺の要素数と右辺の要素数が違っても構いません。従って、いままで[1,2,3]があったところに[1,2,3,4]を代入することができます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x[:] = [4,5,6,7]\n&gt;&gt;&gt; x\n[4, 5, 6, 7]\n&gt;&gt;&gt; y\n[4, 5, 6, 7]\n&gt;&gt;&gt; x is y\nTrue\nこの操作では、一見、数字3個分のメモリ領域に4個めの数字を詰め込んでいるように見えます。ここでは種明かししませんが、このような一見無理のある代入をしたときにメモリ上で何が起きているのか、想像してみてください。そのような想像が、プログラミングのための思考能力を鍛えることになります。\n\n\nここでは、スライス記法の働きを、VS Codeのデバッグモードで確かめてみましょう。ウォッチ式をid(x)、id(y)、x is yの3つに設定し、次の２つのコードをステップイン実行し、ウォッチ式の変化がどのように異なるか観察してください。\nx = [1,2,3]\ny = x\nx[:] = [4,5,6]  # スライス記法でxの内容を変更\npass\nx = [1,2,3]\ny = x\nx = [4,5,6]  # スライス記法でxの内容を変更\npass\n\n\n\n次のコードにおいて、x[1]の変更がyの値に影響を与えるかどうか予想してから、実行して確かめてください。\n&gt;&gt;&gt; x = [0,1,2]\n&gt;&gt;&gt; y = x[1]\n&gt;&gt;&gt; x[1] = 5\n&gt;&gt;&gt; print(y)   # いくつになるか?\n&gt;&gt;&gt; x = [0,1,2]\n&gt;&gt;&gt; y = x[:]\n&gt;&gt;&gt; x[1] = 5\n&gt;&gt;&gt; print(y)   # 変わっているか?\n\n\n\n\nPythonでは、代入と変更の違いに関連して、初学者を混乱させるミュータブルなオブジェクトとイミュータブルなオブジェクトという概念があります。ミュータブルなオブジェクトは内容の書き換えが可能なオブジェクトであり、イミュータブルなオブジェクトとは、書き換え不可能なオブジェクトです。\n\n\n\n\n\n\n\n分類\nデータ型\n\n\n\n\nミュータブル\nリスト(list)、辞書(dict)、集合(set)\n\n\nイミュータブル\n整数(int)、浮動小数点数(float)、文字列(str)、ブール値(bool)、タプル(tuple)\n\n\n\nミュータブルとイミュータブルが紛らわしい概念であるのは、それが変数と定数の概念に、一見似ているからです。\n定数という概念はC言語などに現れる概念で、値の変更を禁止された変数のことです。しかしながら、PythonにはC言語のような定数は存在しません(TrueやFalse、Noneといった特殊なビルトイン(組込み)定数が存在するのみです)。\nPythonの変数は、いつでも好きなオブジェクトに貼り付けられるラベルです(箱ではありません)。箱ではなくラベルですから、イミュータブルなオブジェクトからイミュータブルなオブジェクトに付け替えられますし、イミュータブルなオブジェクトからミュータブルなオブジェクトに付け替えることも可能です。\n実際、文字列はイミュータブルですが、次のコードは全く正常であり、何のエラーも起きません。\n# %%\nx = \"First\"\nx = \"Second\"\nx = \"Third\"\n一方、イミュータブルやミュータブルは、ラベルが参照しているオブジェクトの性質であり、定数や変数とは異なる概念です。文字列はイミュータブルなので、その内容を変更することはできません。\n# %%\nx = \"Immutable\"\nx[0] = \"i\" #エラーが起きる\n上記2行目は、“Immutable”という文字列オブジェクトの最初の要素”I”を”i”に入れ替えよ、という許されない命令です。したがってエラーが出ます。\nTraceback (most recent call last):\n  File \"test.py\", line 2, in &lt;module&gt;\n    x[0] = \"i\"\nTypeError: 'str' object does not support item assignment\nよくある初学者のミスは、次のように、文字列の一部をスライスで変更しようというものです。\n&gt;&gt;&gt; x = \"This is Python.\"\n&gt;&gt;&gt; x[0:4] = \"It\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object does not support item assignment\nしかし同じことをリストで行うのは、全く正しい操作です。\n&gt;&gt;&gt; x = [1,2,3,4,5,6]\n&gt;&gt;&gt; x[0:4] = [1,2]\n&gt;&gt;&gt; x\n[1, 2, 5, 6]\n&gt;&gt;&gt;\nこのように、イミュータブルやミュータブルは、オブジェクトの性質であって、変数そのものの性質ではないことに注意しておきましょう。\n\n\n\n最後に、イミュータブルオブジェクトとメモリ利用に関連して、一つ注意事項を述べます。これは、Pythonプログラミング上はほとんど問題になりませんが、Pythonのメモリ利用を研究をする上で留意しておくべきことです。\n同じオブジェクトを二つ以上の変数が参照しているときに問題が生じるのは、オブジェクトに変更が加えられたときだけであることに注意してください。従って、オブジェクトがイミュータブルである場合は、いくつの変数がそのオブジェクトを参照しているかということは、Pythonのプログラマにとって全く問題になりません。\nこの事実を利用して、Pythonは、シンプルなイミュータブルオブジェクトに関しては、自動的に再利用するようになっています。\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 1\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x = 'a'\n&gt;&gt;&gt; y = 'a'\n&gt;&gt;&gt; x is y\nTrue\n上記では、xとyに独立に1を代入したはずが、xとyは同じオブジェクトを参照していることが分かります。整数オブジェクトはイミュータブルなので、これは全く問題になりません。xが指し示す整数オブジェクト1の内容をうっかり変更してしまって、予期せずyの変更を招く危険がないからです。文字列オブジェクト'a'についても同様です。また、TrueやFalseのブール型オブジェクト、「からっぽ」を意味するNoneオブジェクト等も必ず再利用されます。\n一方で、どれだけシンプルであろうとも、ミュータブルなオブジェクトは再利用されず、代入のたびに新たなメモリ領域が確保されます。\n&gt;&gt;&gt; x = [0]\n&gt;&gt;&gt; y = [0]\n&gt;&gt;&gt; x is y\nFalse\nまた、イミュータブルであっても、そもそも利用される確率の小さいオブジェクトは、再利用されません。\n&gt;&gt;&gt; x = 100000\n&gt;&gt;&gt; y = 100000\n&gt;&gt;&gt; x is y\nFalse\nこれは、利用頻度の小さいオブジェクトをメモリ上に確保したままにすると、メモリの利用効率が悪くなるからです。\nこういった事柄は一見些細な事柄ですが、Pythonのメモリ利用を研究する上でつまづくポイントになるので、知っておいて損はないでしょう。\n\n\n\n今回の講義を通して、『変数』という言葉を特に断りもなく使って来ました。そして、変数へ何らかの値を代入するということは、ラベルをオブジェクトに貼り付けることなのだと説明しました。ラベルが変数名であり、オブジェクトが値です。\nPythonのような言語では、変数名はラベルでしかなく、一つの変数名を、基本的にいつでもどのようなオブジェクトにでもラベルとして貼り付け、貼り付けかえることが可能です。xは整数にしか貼り付けてはいけないとか、yは関数にしか貼り付けてはいけないとか、そういう制約はありません。\nしたがって、次のようなコードが完全に機能します。\n# %%\nimport sys as x     # xにモジュールを代入\nprint(x)\nx = 1   # xに整数を代入\nprint(x)\nx = \"string\"    # xに文字列を代入\nprint(x)\nx = [1,2,3]     # xにリストを代入\nprint(x)\ndef x():        # xに関数を代入\n    print('I am x.')\nprint(x)\nx()     # xを関数として呼び出した\nコードの詳細はまだわからないと思いますが、このコードでは、同じ”x”という変数に、モジュール、整数、文字列、リスト、関数を次々と代入しています。このコードの出力は、次のようになります。\n# 出力\n&lt;module 'sys' (built-in)&gt;\n1\nstring\n[1, 2, 3]\n&lt;function x at 0x7fb1ac7938b0&gt;\nI am x.\n上記の出力は、最後の行を除きすべてprint(x)の出力です。これを見ると分かるように、xは、モジュール、整数、文字列、リスト、そして関数へと変化しています。\nこのようにPythonでは、最初に『xは整数だよ』とか、『xはモジュールだよ』と言った宣言をしません。x(が指すオブジェクト)のデータ型は、動的に変化し得るのです。このような言語の性質を動的型付けと呼びます。それに対して、C言語やJavaがそうであるように、『xは整数だよ』『xは配列だよ』といった宣言をし、そのあとはずっと同じ型のデータしか格納できない、といった性質を静的型付けと言います。\n動的型付けの利点は非常に柔軟なプログラミングができるということです。なぜならば、プログラムにおいて、xのデータ型に依存した処理を、ギリギリまで遅らせることができるからです。それどころか、場合によっては、最後まで型を気にする必要すらないからです。たとえば、print(x)と書くとき、xがどんな型をもっているのかなど、(ほとんど)気にする必要はありません。\n一方、静的型付け言語だと、xが整数なのか、文字列なのか、最初に決めてしまわならないし、最後まで気にしなくてなりません。従って、往々にして、型ごとに別々のコードを書かなくてはならないことになります。\n一方、動的型付け言語の欠点は、コードが実行されるまでxのデータ型がわからないため、xが現れるたびにインタープリタが逐一xの型を判断して、型に応じた適切な処理を実行しなくてはならないことです。そのコストは、実行速度の低下となって現れます。それに対して静的型付け言語は、最初から最後までxのデータ型が固定されているので、逐一データ型をチェックする必要はありません。静的型付け言語では、x+yという表現が出たとき、xは整数か、浮動小数点数か、文字列か、と問う必要はないのです。\n\n\n\nすでにお気づきのように、Pythonのような動的型付け言語においては、変数という言葉を関数やモジュールと言った言葉からわざわざ切り離して定義する意味はほとんどありません。そこで、本講義では、変数という言葉は、ラベルを意味するにすぎず、ときには数値であったり、関数であったり、モジュールであったりしても良いとします。要するに何らかのオブジェクトを参照している記号であれば、それは変数です。\nまた、名前、識別子、記号と言った言葉も使うことがありますが、これらは断りが無い限り全て変数と同じ意味で用いることにします。特に、変数が数値や文字列だけでなく、関数やモジュールを指すことを明確にしたいときに、これらの言葉を使うことがあります。\n\n\n\n今回の授業では、以下の点について学びました。\n\nハコ型の代入とラベル型の代入の違い\nCopy on modifyにまつわるRとPythonの違い\nスライス記法の挙動\nイミュータブル・ミュータブルの意味\n\n次回はリストについてさらに掘り下げて学んで行きます。リストについて掘り下げて学ぶことで、メモリやアドレスという概念がPythonの理解において重要であることが分かるでしょう。\n\n\n\n\n『R言語徹底解説』(Hadley Wickham著、石田基広、市川太祐、高柳慎一その他訳)(2016) 共立出版. ISBN-13 : 978-4320123939."
  },
  {
    "objectID": "programming2025/programming-4.html#代入付値とは何か",
    "href": "programming2025/programming-4.html#代入付値とは何か",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "本講義の受講者にとって、Rの次のような操作は至極ありふれたものだと思います。\n# コード1\nx &lt;- c(1,2,3)\ny &lt;- x\nx[2] &lt;- 5\nprint(x)\nprint(y)\n上記のコマンドを実行したときに、どのような結果が出力されるかを答えられない人はいないでしょう。実際にRの対話的インタープリタを起動するか、VS Code上で実行してみれば良いでしょう。\n&gt; print(x)\n[1] 1 5 3\n&gt; print(y)\n[1] 1 2 3\n&gt; \nしかし、コード1で実際に何が起きているのかを正しく説明できる人はあまり多くないと思います。多くの人が次のように考えているのではないでしょうか？\n\n変数xにベクトル(1,2,3)が代入される\n変数yに変数xの値、つまり(1,2,3)がコピーされる\n変数xの第2要素が5に書き換えられる\n変数xの値が出力される\n変数yの値が出力される\n\nしかし、実際に起きていることは、上記と少し違います。今回の目標はこれを理解することとします。今回の講義で、変数に値を代入するときRやPythonでは何が起きているのかが、ある程度分かるようになります。第1回で学んだメモリやアドレスの概念が必須になります。"
  },
  {
    "objectID": "programming2025/programming-4.html#ハコ型代入",
    "href": "programming2025/programming-4.html#ハコ型代入",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "上記の説明がどのように間違っているかを説明する前に、初学者向けの書籍に良く見られる「箱の比喩」を用いた代入の説明について解説しておきます。\n箱を用いた説明とは、次のようなものです。\n\n下図のように、変数xに1を代入するということは、xという箱に1という値を入れることであり、yにxを代入するということは、xに入っている値1をコピーしてyという箱に入れることである。\n\n\n\n\nbox-type substitution\n\n\nこのような説明は、C言語のようなプログラミング言語では正しい比喩ですが、RやPythonでは正しくありません。特にPythonでは正しい理解を妨げる説明です。\nC言語では、次のようにして、予めxやyが整数であることを変数の作成時に宣言します\nint x,y; // x,yが整数であることを宣言\nソースファイルにこの宣言を見つけたCのコンパイラは、マシン語に変換する際に、xやyといった変数名をメモリのアドレス(実際にはメモリ領域)あるいはレジスタ名といったもので置き換えてしまいます。\nしたがって、\ny = x;  // xの値をyに代入\nという代入操作は、あるアドレスのメモリ領域に格納されている値を別のメモリ領域にコピーすることを意味します。したがって、メモリ領域を箱と考えれば、箱の比喩は正しく実際に起こっていることを表しています。"
  },
  {
    "objectID": "programming2025/programming-4.html#ラベル型代入",
    "href": "programming2025/programming-4.html#ラベル型代入",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "プログラミングの世界では、124や”c”のような具体的な数値や文字だけではなく、それを操作するための付属的な情報を合わせもつものをオブジェクトと呼びます。\nオブジェクトは、表面的には数値や文字ですが、実際には数値や文字を格納する領域以外にもメモリ領域を占有しています。C言語の整数や文字列は、値を格納する分だけのメモリ領域しか占有しないので、オブジェクトではありません。一方、PythonやRの数値や文字列はすべてオブジェクトです。\nRやPythonでの代入の説明でより現実に近いのは以下のような比喩です。\n\n下図のように、変数xに1を代入するということは、1というオブジェクトにxというラベルを貼り付けることであり、変数yにxを代入するという操作は、ラベルxがついているオブジェクトにもう一つyという別のラベルを貼り付けることである。\n\n\n\n\nlabel-type substitution\n\n\nこの正しい見方では、1という一つのオブジェクトにx、yという二つのラベルが貼り付けられています。このようなラベルのことを参照(reference)と呼ぶことがあります。また、変数xやyはオブジェクト1を参照しているということもあります。\nそれでは、Rでの代入操作(y &lt;- x)がこのような「ラベル張り」であるということを確かめてみましょう。そのために、Hadley Wickhamが作ったpryrパッケージをインストールしましょう。\ninstall.packages('pryr')\npryrを読み込むと関数addressを使うことができるようになります。addressは、引数として与えた変数(参照)が指し示しているオブジェクトのアドレスを返す関数です。実際に使ってみましょう。\nlibrary(pryr)\nx &lt;- c(1,2,3)\naddress(x)\ny &lt;- x\naddress(y)\n上のように対話的インタープリタで入力すると、次のような出力が得られます。\n&gt; address(x)\n[1] \"0x183f3110\"\n&gt; y &lt;- x\n&gt; address(y)\n[1] \"0x183f3110\"\n&gt; \n出力が二つ得られていますが、一つ目の値0x183f3110は、xというラベルが貼り付けられているベクトル(1,2,3)というオブジェクトが格納されているメモリのアドレスを16進数で表したものです（具体的なアドレスの値は、実行時ごとに異なります）。また、二つ目の出力は、yというラベルが貼り付けられているオブジェクトのメモリ上のアドレスですが、これも0x183f3110となっており、xと同じオブジェクトにyが貼り付けられているということが分かります。\nこのように、C言語とは違ってx、yという別個のメモリアドレスが存在するわけではないことが分かります。"
  },
  {
    "objectID": "programming2025/programming-4.html#参照カウンタ",
    "href": "programming2025/programming-4.html#参照カウンタ",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "ところが、RはCopy on modifyという機構を備えていて、ラベル張りであることを余り意識させない作りになっています。Copy on modify機構について説明するために、まずは参照カウンタ(リファレンスカウンタ）について説明しましょう。以下、Rのヴァージョン3系列(3.5,3.6等)を仮定して話を進めますが、出力はヴァージョン4でも同じになるはずです。(ヴァージョン3と4の違いは課題で取り扱います。)\nベクトルのようなRのオブジェクトは、自分に何枚のラベルがついているかに関する情報を内部に格納しています。換言すると、Rオブジェクトは、自分がいくつの変数(xやy)に参照されているかを知っています。オブジェクトを参照している変数の数の事を参照カウントと呼びます。Rオブジェクトは、内部に自分自身の参照カウントを記憶する参照カウンタを持っています。\n参照カウンタの値は、関数pryr::refsによって調べることができます。\n&gt; rm(list=ls()) #一応全変数を削除\n&gt; x &lt;- c(1,2,3)\n&gt; refs(x)\n[1] 1\n&gt; y &lt;- x\n&gt; refs(x)\n[1] 2\n&gt; refs(y)\n[1] 2\n&gt;"
  },
  {
    "objectID": "programming2025/programming-4.html#copy-on-modifyメカニズム",
    "href": "programming2025/programming-4.html#copy-on-modifyメカニズム",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "さて、次のようにxに代入したベクトル(1,2,3)の内容を書き換えようとするとき、参照カウントが1の場合と2以上の場合では、Rは異なる挙動を示します。\nまずxの参照カウントが1の場合です。\nrm(list=ls()) #全変数を削除\nx &lt;- c(1,2,3)\naddress(x)\nx[2] &lt;- 5\naddress(x)\n上記を実行すると、次のような出力が得られます。\n&gt; x &lt;- c(1,2,3)\n&gt; address(x)\n[1] \"0x17f14dd8\"\n&gt; x[2] &lt;- 5\n&gt; address(x)\n[1] \"0x17f14dd8\" #xのアドレスは変わらない\n&gt; \n上記のように、xの内容を書き換える前後で、xは同じオブジェクトを参照しています。\nところが、xの参照カウントが2以上のとき、つまりxと同じオブジェクトを参照する変数yが存在するとき、異なる挙動が起きます。次を実行してみましょう。\nrm(list=ls()) #全変数を削除\nx &lt;- c(1,2,3)\ny &lt;- x\naddress(x)\naddress(y)\nx[2] &lt;- 5\naddress(x)\naddress(y)\n上記を実行すると、次のような出力が得られます。\n&gt; rm(list=ls()) #全変数を削除\n&gt; x &lt;- c(1,2,3)\n&gt; y &lt;- x\n&gt; address(x)\n[1] \"0x17ecbc78\"\n&gt; address(y)\n[1] \"0x17ecbc78\"\n&gt; x[2] &lt;- 5\n&gt; address(x)\n[1] \"0x17ecb598\"  #xのアドレスが変わった\n&gt; address(y)\n[1] \"0x17ecbc78\"\n&gt; \n上記のように、参照カウントが2以上になると、オブジェクトの内容を変更する際に、あらたなメモリ領域が確保され、オブジェクトがコピーされてから変更が行われることが分かります。このメカニズムをCopy on modifyと呼びます。\nCopy on modify機構のおかげで、Rのプログラマは、オブジェクトがいくつの変数に参照されているかをあまり意識する必要がありません。xの内容を修正したときに、うっかりyの内容まで修正してしまう危険がないわけです。\n\n\n\ncopy_on_modify\n\n\n\n\n\n次のRコードは、二つの参照を持つリストオブジェクトの内容を変更するものである。pryr::address関数を用いて、上記のコードでCopy on modify機構が働いているかどうか確かめなさい。\nrm(list=ls()) # 全変数を削除\nx &lt;- list(a='A',b='B')\ny &lt;- x\nx[['a']] &lt;- 'AA'\n次はさらに複雑な例である。xはリストを要素にもつリストである。この入れ子になった内側のリストに変更を加えたとき、Copy on modifyは働くか？確かめなさい。\nrm(list=ls())\nx &lt;- list(a=list(b='B',d='D'))\ny &lt;- x\nx[['a']][['b']] &lt;- 'BB'"
  },
  {
    "objectID": "programming2025/programming-4.html#pythonの挙動",
    "href": "programming2025/programming-4.html#pythonの挙動",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "ところが、PythonにはCopy on modify機構がありません。どういうことかというと、オブジェクトがいくつの変数に参照されているかにかからわず、オブジェクトの内容変更に伴うコピーは自動的には起きません。\nこれを実際に確かめてみましょう。 Pythonにはベクトル型は存在しないので、代わりにリストを使いましょう。たとえば1,2,3という三つの整数を要素にもつリストは次のように作成します。(リストについては、次回詳しく取り上げます。)\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x\n[1, 2, 3]\nRのベクトルでは最初の要素にアクセスするにはx[1]と書きますが、pythonのリストではx[0]と書きます。つまり、インデックスは0からはじまります。それを除けばインデクシングのルールはRのベクトルと非常によく似ています。\n&gt;&gt;&gt; x\n[1, 2, 3]\n&gt;&gt;&gt; x[0]\n1\n&gt;&gt;&gt; x[1]\n2\n&gt;&gt;&gt; x[2]\n3\nさてそれでは準備が出来たので実験を開始しましょう。 PythonにおけるRのpryr::addressに対応する関数はビルトイン関数のidです。idは、変数が参照するオブジェクトのアドレスを10進数で返します。まずはpythonの変数が参照であることを確認しましょう。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; id(x)\n2080340453760\n&gt;&gt;&gt; id(y)\n2080340453760\n&gt;&gt;&gt; id(x) == id(y)\nTrue\n最後のid(x) == id(y)という式は、Rと同じで、左辺と右辺が正しければTrue、違っていればFalseを返す二項演算です。上記より、確かにpythonの代入がラベル型であることが分かります。なお、id(x) == id(y)は、次のように書くこともできます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n“x is y”は、xとyが同じオブジェクトを指しているときにTrue、そうでないときにFalseとなります。\nそれでは次に、Copy on modifyが働かないことを確かめましょう。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x[1] = 5\n&gt;&gt;&gt; x\n[1, 5, 3]\n&gt;&gt;&gt; y   # yまで変化した\n[1, 5, 3]\n&gt;&gt;&gt; x is y # Copy on modifyは起きていない\nTrue\n上記のように、複数の参照をもつオブジェクトの内容を変更すると、それを参照する全ての変数の内容が変わってしまいます。下図のように、Rとは違ってPythonはCopy on modifyを行わないからです。\n\n\n\nnot_copy_on_modify"
  },
  {
    "objectID": "programming2025/programming-4.html#デバッグモードの活用",
    "href": "programming2025/programming-4.html#デバッグモードの活用",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "オブジェクトのメモリアドレスやオブジェクトの同一性がプログラムの中でどのように変化していくかを観察するには、VS Codeのデバッグモードを用いると分かりやすいです(condaコマンドのパスを通している必要があります)。\nGitHubディレクトリの下に、varsというディレクトリを作成し、VS Codeで開きましょう。debug.pyというファイルを作成し、次のように記述してください。\nx = [1,2,3]\ny = x\nx[1] = 5\npass\npassは、『何もしない』を意味します。\n次に、VS Codeの画面左側の虫のマークをクリックしてください。\n\n\n\nbug\n\n\n『実行とデバッグ』というボタンが現れますが、そのすぐ下の、『launch.jsonファイルを作成します』をクリックしてください。\n\n\n\nlaunch_json\n\n\nDebug Configurationというパレットが立ち上がりますので、一番上の、Python File Debug the currently active Python fileを選択してください。これで、今選択しているPythonコードをデバッグすることができるようになります。launch.jsonという設定ファイルが作成されますが、閉じてください。\n開いているdebug.pyファイルの1行目の左がわをクリックして、赤い印をつけましょう。これをブレークポイントと呼びます。デバッグをするときは、このブレークポイントを一つ以上設定します。\n\n\n\nbreak_point\n\n\n次に、『ウォッチ式』を定義します。画面左側中程にある『ウォッチ式』ペインの『＋』マークをクリックして、ウォッチ式を入力しましょう。ここでは次の3つのウォッチ式を入力してください。\n\nid(x)\nid(y)\nx is y\n\n\n\n\nwatch_eq\n\n\nウォッチ式とは、デバッグ中にリアルタイムで『ウォッチ』したい式のことです。\n以上でデバッグの準備が整いました。"
  },
  {
    "objectID": "programming2025/programming-4.html#ステップイン",
    "href": "programming2025/programming-4.html#ステップイン",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "デバッグを起動するには、左上の緑色の三角マークをクリックします。\n\n\n\ndebug_button\n\n\nデバッグが起動すると、プログラムが実行され、ブレークポイントの行を実行する直前でストップします。また、画面上に6個のボタンが現れることに注意してください。\n\n\n\nstepin\n\n\nこれらのボタンは、左から順番に\n\n次のブレークポイントまで実行\nステップオーバー\nステップイン\nステップアウト\n再起動\n停止\n\nを表します。ステップオーバーとステップアウトは関数に関係があるので、今は説明を保留します。\nここから、ステップインという操作によって、1行ずつコードを評価しながら、ウォッチ式の値がどのように変化していくか観察していきます。\nステップインを表す下向きのやじるしをクリックしてください。すると、ブレークポイントの行が実行され、次の行へとフォーカスが移ります。\n左上の『変数』ペインのLocals欄とGlobals欄の両方にx: [1,2,3]というのが現れるはずです。\n\n\n\nvariable_pane\n\n\nこれは、変数xに[1,2,3]という値(オブジェクト)が付値されたということを表します。\n同時に、ウォッチ式のペインでは、id(x)の値に数字が現れるはずです。この値は、id(x)の値、すなわちオブジェクト[1,2,3]が位置するメモリのアドレスを表しています。\n\n\n\nwatch_eq_assigned\n\n\nyのほうはまだ代入が起きていないため、ウォッチ式id(y)の値はNameErrorとなっています。\n次に、もう一度ステップインしてください。次は、ウォッチ式id(y)の値が表示され、ウォッチ式x is yがTrueになるはずです。id(x)とid(y)の値が同じであることに注意してください。これは、xとyが同じオブジェクトを参照していることを表します。このことは、x is yがTrueになっていることからも分かります。\nもう一度ステップインすると、変数ペインのxとyの第2要素が同時に変化することに注意してください。これは、x is yがTrueだったので、予測できたことですね。\n最後にもう一度ステップインしてpassの行を実行し、デバッグを終了しておきましょう。"
  },
  {
    "objectID": "programming2025/programming-4.html#変更と代入の違い",
    "href": "programming2025/programming-4.html#変更と代入の違い",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "Pythonの初学者にとってちょっと分かりにくいのが、変数xが参照するオブジェクト自体の内容を修正するということと、変数xに別のオブジェクトを代入する・参照させる(参照を付け直す)という二つの操作の違いです。変更では、変数が参照するオブジェクトのアドレスは変化しませんが、代入では変化します。\n\n\n\n操作\n参照先のアドレス\n\n\n\n\nxが参照するオブジェクト自体の内容を変更\n変化しない\n\n\nxに別のオブジェクトを代入\n変化する\n\n\n\nたとえば、次の例では、xとyが同じオブジェクトを参照している状態でxに別のオブジェクトを代入しましたが、yは変化していません。代入操作では、単にxが別のオブジェクトを参照するようになるだけで、もとのオブジェクトには何の影響も与えないからです。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x # xとyは同じオブジェクトを参照\n&gt;&gt;&gt; x = [4,5,6] # xに異なるオブジェクトを代入\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y   # yは変化していない\n[1, 2, 3]\n&gt;&gt;&gt; x is y  # xとyは違うオブジェクトを指している\nFalse\n\n\n\nsubstituion\n\n\nしかしながら、ほんの少しだけコードを変えて次のようにすると、xへの操作は代入ではなく変更になります。yの内容まで変わってしまいますので注意してください。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x[:] = [4,5,6]  # スライス記法でxの内容を変更\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y   # yも変わってしまった\n[4, 5, 6]\n&gt;&gt;&gt; x is y  # xとyは同じオブジェクトを参照\nTrue\n\n\n\nslice\n\n\n変更したのは1行だけです。ここで用いたx[:]はスライス記法というもので、コロン:は「最初から最後まで、リストの全ての要素」を意味します。スライス記法については、教科書のセクション6.1.2に詳しく説明されているので読んでおきましょう。\nスライス記法がどのように機能しているのかを解説するついでに、Pythonに特有のアンパック代入も導入しておきましょう。Pythonでは、次のようにして、複数の変数に一挙に値を代入できます。\n&gt;&gt;&gt; x,y,z = [1,2,3]\n&gt;&gt;&gt; x\n1\n&gt;&gt;&gt; y\n2\n&gt;&gt;&gt; z\n3\nこれをアンパック代入と呼びます。アンパック代入については、教科書のセクション3.2.4に詳しいので読んでおいてください。\n上述のスライス記法の構文は、次のようにアンパック代入するのと実質的に同じことをやっていることになります。(実際には少し違います。)\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x[0],x[1],x[2] = [4,5,6]\n&gt;&gt;&gt; x\n[4, 5, 6]\n&gt;&gt;&gt; y\n[4, 5, 6]\n&gt;&gt;&gt; x is y\nTrue\nこれを見れば、スライス記法による代入が、実際にはxが指すリストオブジェクトの内容を変更してしまっているのが分かるでしょう。\n実際にはスライス記法による代入は、アンパック代入とは少し違って、左辺の要素数と右辺の要素数が違っても構いません。従って、いままで[1,2,3]があったところに[1,2,3,4]を代入することができます。\n&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; x[:] = [4,5,6,7]\n&gt;&gt;&gt; x\n[4, 5, 6, 7]\n&gt;&gt;&gt; y\n[4, 5, 6, 7]\n&gt;&gt;&gt; x is y\nTrue\nこの操作では、一見、数字3個分のメモリ領域に4個めの数字を詰め込んでいるように見えます。ここでは種明かししませんが、このような一見無理のある代入をしたときにメモリ上で何が起きているのか、想像してみてください。そのような想像が、プログラミングのための思考能力を鍛えることになります。\n\n\nここでは、スライス記法の働きを、VS Codeのデバッグモードで確かめてみましょう。ウォッチ式をid(x)、id(y)、x is yの3つに設定し、次の２つのコードをステップイン実行し、ウォッチ式の変化がどのように異なるか観察してください。\nx = [1,2,3]\ny = x\nx[:] = [4,5,6]  # スライス記法でxの内容を変更\npass\nx = [1,2,3]\ny = x\nx = [4,5,6]  # スライス記法でxの内容を変更\npass\n\n\n\n次のコードにおいて、x[1]の変更がyの値に影響を与えるかどうか予想してから、実行して確かめてください。\n&gt;&gt;&gt; x = [0,1,2]\n&gt;&gt;&gt; y = x[1]\n&gt;&gt;&gt; x[1] = 5\n&gt;&gt;&gt; print(y)   # いくつになるか?\n&gt;&gt;&gt; x = [0,1,2]\n&gt;&gt;&gt; y = x[:]\n&gt;&gt;&gt; x[1] = 5\n&gt;&gt;&gt; print(y)   # 変わっているか?"
  },
  {
    "objectID": "programming2025/programming-4.html#ミュータブルとイミュータブル",
    "href": "programming2025/programming-4.html#ミュータブルとイミュータブル",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "Pythonでは、代入と変更の違いに関連して、初学者を混乱させるミュータブルなオブジェクトとイミュータブルなオブジェクトという概念があります。ミュータブルなオブジェクトは内容の書き換えが可能なオブジェクトであり、イミュータブルなオブジェクトとは、書き換え不可能なオブジェクトです。\n\n\n\n\n\n\n\n分類\nデータ型\n\n\n\n\nミュータブル\nリスト(list)、辞書(dict)、集合(set)\n\n\nイミュータブル\n整数(int)、浮動小数点数(float)、文字列(str)、ブール値(bool)、タプル(tuple)\n\n\n\nミュータブルとイミュータブルが紛らわしい概念であるのは、それが変数と定数の概念に、一見似ているからです。\n定数という概念はC言語などに現れる概念で、値の変更を禁止された変数のことです。しかしながら、PythonにはC言語のような定数は存在しません(TrueやFalse、Noneといった特殊なビルトイン(組込み)定数が存在するのみです)。\nPythonの変数は、いつでも好きなオブジェクトに貼り付けられるラベルです(箱ではありません)。箱ではなくラベルですから、イミュータブルなオブジェクトからイミュータブルなオブジェクトに付け替えられますし、イミュータブルなオブジェクトからミュータブルなオブジェクトに付け替えることも可能です。\n実際、文字列はイミュータブルですが、次のコードは全く正常であり、何のエラーも起きません。\n# %%\nx = \"First\"\nx = \"Second\"\nx = \"Third\"\n一方、イミュータブルやミュータブルは、ラベルが参照しているオブジェクトの性質であり、定数や変数とは異なる概念です。文字列はイミュータブルなので、その内容を変更することはできません。\n# %%\nx = \"Immutable\"\nx[0] = \"i\" #エラーが起きる\n上記2行目は、“Immutable”という文字列オブジェクトの最初の要素”I”を”i”に入れ替えよ、という許されない命令です。したがってエラーが出ます。\nTraceback (most recent call last):\n  File \"test.py\", line 2, in &lt;module&gt;\n    x[0] = \"i\"\nTypeError: 'str' object does not support item assignment\nよくある初学者のミスは、次のように、文字列の一部をスライスで変更しようというものです。\n&gt;&gt;&gt; x = \"This is Python.\"\n&gt;&gt;&gt; x[0:4] = \"It\"\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object does not support item assignment\nしかし同じことをリストで行うのは、全く正しい操作です。\n&gt;&gt;&gt; x = [1,2,3,4,5,6]\n&gt;&gt;&gt; x[0:4] = [1,2]\n&gt;&gt;&gt; x\n[1, 2, 5, 6]\n&gt;&gt;&gt;\nこのように、イミュータブルやミュータブルは、オブジェクトの性質であって、変数そのものの性質ではないことに注意しておきましょう。"
  },
  {
    "objectID": "programming2025/programming-4.html#イミュータブルオブジェクトの再利用",
    "href": "programming2025/programming-4.html#イミュータブルオブジェクトの再利用",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "最後に、イミュータブルオブジェクトとメモリ利用に関連して、一つ注意事項を述べます。これは、Pythonプログラミング上はほとんど問題になりませんが、Pythonのメモリ利用を研究をする上で留意しておくべきことです。\n同じオブジェクトを二つ以上の変数が参照しているときに問題が生じるのは、オブジェクトに変更が加えられたときだけであることに注意してください。従って、オブジェクトがイミュータブルである場合は、いくつの変数がそのオブジェクトを参照しているかということは、Pythonのプログラマにとって全く問題になりません。\nこの事実を利用して、Pythonは、シンプルなイミュータブルオブジェクトに関しては、自動的に再利用するようになっています。\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = 1\n&gt;&gt;&gt; x is y\nTrue\n&gt;&gt;&gt; x = 'a'\n&gt;&gt;&gt; y = 'a'\n&gt;&gt;&gt; x is y\nTrue\n上記では、xとyに独立に1を代入したはずが、xとyは同じオブジェクトを参照していることが分かります。整数オブジェクトはイミュータブルなので、これは全く問題になりません。xが指し示す整数オブジェクト1の内容をうっかり変更してしまって、予期せずyの変更を招く危険がないからです。文字列オブジェクト'a'についても同様です。また、TrueやFalseのブール型オブジェクト、「からっぽ」を意味するNoneオブジェクト等も必ず再利用されます。\n一方で、どれだけシンプルであろうとも、ミュータブルなオブジェクトは再利用されず、代入のたびに新たなメモリ領域が確保されます。\n&gt;&gt;&gt; x = [0]\n&gt;&gt;&gt; y = [0]\n&gt;&gt;&gt; x is y\nFalse\nまた、イミュータブルであっても、そもそも利用される確率の小さいオブジェクトは、再利用されません。\n&gt;&gt;&gt; x = 100000\n&gt;&gt;&gt; y = 100000\n&gt;&gt;&gt; x is y\nFalse\nこれは、利用頻度の小さいオブジェクトをメモリ上に確保したままにすると、メモリの利用効率が悪くなるからです。\nこういった事柄は一見些細な事柄ですが、Pythonのメモリ利用を研究する上でつまづくポイントになるので、知っておいて損はないでしょう。"
  },
  {
    "objectID": "programming2025/programming-4.html#動的型付け",
    "href": "programming2025/programming-4.html#動的型付け",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "今回の講義を通して、『変数』という言葉を特に断りもなく使って来ました。そして、変数へ何らかの値を代入するということは、ラベルをオブジェクトに貼り付けることなのだと説明しました。ラベルが変数名であり、オブジェクトが値です。\nPythonのような言語では、変数名はラベルでしかなく、一つの変数名を、基本的にいつでもどのようなオブジェクトにでもラベルとして貼り付け、貼り付けかえることが可能です。xは整数にしか貼り付けてはいけないとか、yは関数にしか貼り付けてはいけないとか、そういう制約はありません。\nしたがって、次のようなコードが完全に機能します。\n# %%\nimport sys as x     # xにモジュールを代入\nprint(x)\nx = 1   # xに整数を代入\nprint(x)\nx = \"string\"    # xに文字列を代入\nprint(x)\nx = [1,2,3]     # xにリストを代入\nprint(x)\ndef x():        # xに関数を代入\n    print('I am x.')\nprint(x)\nx()     # xを関数として呼び出した\nコードの詳細はまだわからないと思いますが、このコードでは、同じ”x”という変数に、モジュール、整数、文字列、リスト、関数を次々と代入しています。このコードの出力は、次のようになります。\n# 出力\n&lt;module 'sys' (built-in)&gt;\n1\nstring\n[1, 2, 3]\n&lt;function x at 0x7fb1ac7938b0&gt;\nI am x.\n上記の出力は、最後の行を除きすべてprint(x)の出力です。これを見ると分かるように、xは、モジュール、整数、文字列、リスト、そして関数へと変化しています。\nこのようにPythonでは、最初に『xは整数だよ』とか、『xはモジュールだよ』と言った宣言をしません。x(が指すオブジェクト)のデータ型は、動的に変化し得るのです。このような言語の性質を動的型付けと呼びます。それに対して、C言語やJavaがそうであるように、『xは整数だよ』『xは配列だよ』といった宣言をし、そのあとはずっと同じ型のデータしか格納できない、といった性質を静的型付けと言います。\n動的型付けの利点は非常に柔軟なプログラミングができるということです。なぜならば、プログラムにおいて、xのデータ型に依存した処理を、ギリギリまで遅らせることができるからです。それどころか、場合によっては、最後まで型を気にする必要すらないからです。たとえば、print(x)と書くとき、xがどんな型をもっているのかなど、(ほとんど)気にする必要はありません。\n一方、静的型付け言語だと、xが整数なのか、文字列なのか、最初に決めてしまわならないし、最後まで気にしなくてなりません。従って、往々にして、型ごとに別々のコードを書かなくてはならないことになります。\n一方、動的型付け言語の欠点は、コードが実行されるまでxのデータ型がわからないため、xが現れるたびにインタープリタが逐一xの型を判断して、型に応じた適切な処理を実行しなくてはならないことです。そのコストは、実行速度の低下となって現れます。それに対して静的型付け言語は、最初から最後までxのデータ型が固定されているので、逐一データ型をチェックする必要はありません。静的型付け言語では、x+yという表現が出たとき、xは整数か、浮動小数点数か、文字列か、と問う必要はないのです。"
  },
  {
    "objectID": "programming2025/programming-4.html#変数にまつわる用語",
    "href": "programming2025/programming-4.html#変数にまつわる用語",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "すでにお気づきのように、Pythonのような動的型付け言語においては、変数という言葉を関数やモジュールと言った言葉からわざわざ切り離して定義する意味はほとんどありません。そこで、本講義では、変数という言葉は、ラベルを意味するにすぎず、ときには数値であったり、関数であったり、モジュールであったりしても良いとします。要するに何らかのオブジェクトを参照している記号であれば、それは変数です。\nまた、名前、識別子、記号と言った言葉も使うことがありますが、これらは断りが無い限り全て変数と同じ意味で用いることにします。特に、変数が数値や文字列だけでなく、関数やモジュールを指すことを明確にしたいときに、これらの言葉を使うことがあります。"
  },
  {
    "objectID": "programming2025/programming-4.html#まとめ",
    "href": "programming2025/programming-4.html#まとめ",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "今回の授業では、以下の点について学びました。\n\nハコ型の代入とラベル型の代入の違い\nCopy on modifyにまつわるRとPythonの違い\nスライス記法の挙動\nイミュータブル・ミュータブルの意味\n\n次回はリストについてさらに掘り下げて学んで行きます。リストについて掘り下げて学ぶことで、メモリやアドレスという概念がPythonの理解において重要であることが分かるでしょう。"
  },
  {
    "objectID": "programming2025/programming-4.html#参考書",
    "href": "programming2025/programming-4.html#参考書",
    "title": "第4回 変数とメモリ",
    "section": "",
    "text": "『R言語徹底解説』(Hadley Wickham著、石田基広、市川太祐、高柳慎一その他訳)(2016) 共立出版. ISBN-13 : 978-4320123939."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Rinri/5Syakaikeiyakusetu.html",
    "href": "Rinri/5Syakaikeiyakusetu.html",
    "title": "５　社会契約説",
    "section": "",
    "text": "中世（キリスト教カトリック時代）\n絶対王政（王権神授説）\n\n\n\n\n神＞教皇＞国王\n神＞国王\n中世のカトリックが支配する時代では、教皇の方が国王より上になる。(例：聖職叙任権)\nしかし、十字軍失敗などでカトリックの教皇の権威は失墜。絶対王政が発生し、王権神授説がでて、王が一番上へ。\nしかし、王に抑圧された民衆が反乱を起こす（フランス革命など）。ここで出てきたのが、社会契約説である。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "社会契約説"
    ]
  },
  {
    "objectID": "Rinri/5Syakaikeiyakusetu.html#契約とは",
    "href": "Rinri/5Syakaikeiyakusetu.html#契約とは",
    "title": "５　社会契約説",
    "section": "契約とは",
    "text": "契約とは\n\n一神教において\n神　→契約→　人間\n社会契約\n神と人間は平等である",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "社会契約説"
    ]
  },
  {
    "objectID": "Rinri/5Syakaikeiyakusetu.html#社会契約説の画期性",
    "href": "Rinri/5Syakaikeiyakusetu.html#社会契約説の画期性",
    "title": "５　社会契約説",
    "section": "社会契約説の画期性",
    "text": "社会契約説の画期性\n\n国家権力の根拠を神から人へ\n\n\n\n\n\n\n\n王権神授説\n社会契約説\n\n\n\n\n神が国王に王権を授与。国王が神の信任の元に民を支配\n神が規定した民が王と契約を結ぶことで、民の信任の元、自然権を王に預ける\n\n\n\n国王を契約制にするという発想\n科学的手法によるアプローチ\n原子論\n社会契約説は原子論の応用。社会契約説は、社会の単位は個人になる。原子のように、社会の最小構成単位は分割できないので、ここから政治哲学も考えてよいのではないかという発想から生まれている。国王も民も人間なのだから、最小単位は一緒。つまり、出自なども考える必要性はない。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "社会契約説"
    ]
  },
  {
    "objectID": "Rinri/5Syakaikeiyakusetu.html#ホップズリバイアサン",
    "href": "Rinri/5Syakaikeiyakusetu.html#ホップズリバイアサン",
    "title": "５　社会契約説",
    "section": "ホップズ「リバイアサン」",
    "text": "ホップズ「リバイアサン」\n表紙が有名\n王の体は、人でできている。多くの人から国王が成り立っているということを示す\n\nホップズの考える自然状態\n\n万人の万人による闘争\n\n人間の最高の目的は「自己保存」\n\n\nホップズの自然権\n\n自らの生命を維持するための権利\n\n\n\nホップズの自然法\n\n生命が脅かされることを禁ずる\n\n\n\nホップズの特徴\n\n人々が自らの権利を権力者に譲渡\n\n平和と安全に関する権力者の意思や判断（＝法）に服従する\n絶対王政的であるが、これはピューリタン革命のように強い権力を持たせないと内政が崩壊すると考えていたから",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "社会契約説"
    ]
  },
  {
    "objectID": "Rinri/5Syakaikeiyakusetu.html#ロック統治二論",
    "href": "Rinri/5Syakaikeiyakusetu.html#ロック統治二論",
    "title": "５　社会契約説",
    "section": "ロック「統治二論」",
    "text": "ロック「統治二論」\n\nロックの自然状態\n\n自由で平等、自然法に拘束される\n\n自然に労働を加えることで、必要なものを生産する\n\n\nロックの自然権\n\n所有権/固有権\n処罰権\n\nヒトは自然状態において、プロパティの侵害に対して、各自が処罰する権利を持つ。\n→これ結構危なくね？\n\n\n自然状態には問題がある。だから 契約を結ぼう！ という考え方\n\nホップズと違うのは、自然権を譲渡ではなく貸与している点にある\n\n\n\n革命権\n\n人々に信託に基づき国家は成立するので、目的に反する場合、信託は失効し、権力は人々の手に戻る\nその場合は、革命という形で政府を破壊しても構わない\n日本では、「内閣不信任決議」という形で規定",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "社会契約説"
    ]
  },
  {
    "objectID": "Rinri/5Syakaikeiyakusetu.html#ルソー-社会契約論",
    "href": "Rinri/5Syakaikeiyakusetu.html#ルソー-社会契約論",
    "title": "５　社会契約説",
    "section": "ルソー　「社会契約論」",
    "text": "ルソー　「社会契約論」\nルソーは、ロックなどよりだいぶ後に出てきた人物。 ホップズとロックの自然状態を批判。\n2人と違い、自然状態のほうが望ましいという。 自然人は、所有権という概念がなく、自由で平等だから。\nしかし、人間は農耕を始めるなど、不自由で不平等の社会状態を始めようとする。\n\n不平等な社会状態を契約によって自由平等な社会状態に変えようとする考え方\n\n→　この手段が革命であり、その結果、フランス革命が発生",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "社会契約説"
    ]
  },
  {
    "objectID": "Rinri/3Kihanrinrigaku.html",
    "href": "Rinri/3Kihanrinrigaku.html",
    "title": "３　客観主義と主観主義",
    "section": "",
    "text": "規範倫理学で前提とされている事柄を一段上から（＝メタに）研究すること\n\n倫理に答えはあるのか？\n倫理の事柄は普遍的であるのか？\n倫理的な判断とは何か？\n倫理的な判断は動機づけの力を持つか？\n\n根本を問う学問分野\n\n\n\n\n\n\nノート例） イスラム圏での女性の教育差別\n\n\n\nイスラムの文化では、女性は教育において差別される。しかし、彼らの文化では正しい価値観であり、それをほかの国の文化の目線から批判することは許されるのか？\n\n\n\n\n倫理学の問いに「答えはないのではない」というのは、証明できていない。 そうではなくて、答えを出すのが難しいということはわかる。\n\n\n\n「リンゴは丸いのはなぜ？」という問いは「丸い」という客観的な性質を持つから言える。\n→ 「良さ」なども客観的性質があるという考え方\n\n\n\n「善さ」を普遍的なものだと考えられる\nある行為が善いのは、実際にその行為が善いからであって、それは当の行為を見てみればだれにでもわかる\nつまり、誰がどう見ても正しいという概念が生まれる\n\n\n\n\n\n善さも対象側に変化がない限り、安定している\n\n\n\n\n\n私たちは、道徳的進歩を認められる\n\n\n\n\n\n道徳的性質は客観的か？（味のように、私たち主観の側が投影しているだけでは…）\n仮に客観的な善さや正しさがあったとしても、一体それが誰にどうやってわかるの？\n\n\n\n\n\n\n\n\n倫理的な判断の個人差を説明できる　「人それぞれ」\n\n\n\n\n\n\n\n\n倫理的な価値は「私たちのものだ」といえる。\n倫理のために人間があるわけではなく、人間のために倫理があるのではないか？\n\n\n\n\n\n奴隷制や男尊女卑を肯定する道徳観も「人それぞれ」で成立する\n外部からの批判ができないので、倫理は権力者や多数派のものになってしまう\n大悪人を批判することはできなくなる\n\n\n\n\n\n道徳的な事柄が当てはまるかどうかは、文化や社会によって変わるという考え方\n\n\n\n\n\n\nノート例\n\n\n\n死者への弔い方も火葬・土葬・死者の肉を食らうなど様々で、それが正しいかは文化で異なる\n\n\n\n\n\n（例に対して）周辺信念が違うだけで、死者を弔う気持ちは一緒なら道徳は同じであろう\n事実として違っていても道徳的に批判ができなくなる\n\nEx）地球平面説は科学で否定できるが、道徳的観点から批判不可能",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "客観主義と主観主義"
    ]
  },
  {
    "objectID": "Rinri/3Kihanrinrigaku.html#客観主義",
    "href": "Rinri/3Kihanrinrigaku.html#客観主義",
    "title": "３　客観主義と主観主義",
    "section": "",
    "text": "「リンゴは丸いのはなぜ？」という問いは「丸い」という客観的な性質を持つから言える。\n→ 「良さ」なども客観的性質があるという考え方\n\n\n\n「善さ」を普遍的なものだと考えられる\nある行為が善いのは、実際にその行為が善いからであって、それは当の行為を見てみればだれにでもわかる\nつまり、誰がどう見ても正しいという概念が生まれる\n\n\n\n\n\n善さも対象側に変化がない限り、安定している\n\n\n\n\n\n私たちは、道徳的進歩を認められる\n\n\n\n\n\n道徳的性質は客観的か？（味のように、私たち主観の側が投影しているだけでは…）\n仮に客観的な善さや正しさがあったとしても、一体それが誰にどうやってわかるの？",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "客観主義と主観主義"
    ]
  },
  {
    "objectID": "Rinri/3Kihanrinrigaku.html#主観主義",
    "href": "Rinri/3Kihanrinrigaku.html#主観主義",
    "title": "３　客観主義と主観主義",
    "section": "",
    "text": "倫理的な判断の個人差を説明できる　「人それぞれ」\n\n\n\n\n\n\n\n\n倫理的な価値は「私たちのものだ」といえる。\n倫理のために人間があるわけではなく、人間のために倫理があるのではないか？\n\n\n\n\n\n奴隷制や男尊女卑を肯定する道徳観も「人それぞれ」で成立する\n外部からの批判ができないので、倫理は権力者や多数派のものになってしまう\n大悪人を批判することはできなくなる",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "客観主義と主観主義"
    ]
  },
  {
    "objectID": "Rinri/3Kihanrinrigaku.html#道徳的相対主義",
    "href": "Rinri/3Kihanrinrigaku.html#道徳的相対主義",
    "title": "３　客観主義と主観主義",
    "section": "",
    "text": "道徳的な事柄が当てはまるかどうかは、文化や社会によって変わるという考え方\n\n\n\n\n\n\nノート例\n\n\n\n死者への弔い方も火葬・土葬・死者の肉を食らうなど様々で、それが正しいかは文化で異なる\n\n\n\n\n\n（例に対して）周辺信念が違うだけで、死者を弔う気持ちは一緒なら道徳は同じであろう\n事実として違っていても道徳的に批判ができなくなる\n\nEx）地球平面説は科学で否定できるが、道徳的観点から批判不可能",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "客観主義と主観主義"
    ]
  },
  {
    "objectID": "Rinri/2Tetsugakutekisikou.html",
    "href": "Rinri/2Tetsugakutekisikou.html",
    "title": "２　哲学的思考と高校倫理の難しさ",
    "section": "",
    "text": "哲学の判断基準は、合理的か否かである。\n\n\n合理的判断に必要な要素は３つ\n\n事実と価値の区別\n「～である」は事実、「～であるべき」は価値\n事実判断から価値判断は直に出ない。\n\n\n\n\n\n\n警告注意\n\n\n\nEx）「昔から牛を使っている」（事実）\n　　　　　　　↓\n「牛を利用してよい」（価値）\nこの論理の持って生き方は合理的ではない。\n\n\n判断の一貫性\n道徳的に重要な違いがない限り、全てにおいて一貫性がある。\n公平な視点\n自己中心的ではなくて、普遍な判断をする。 ただし、普遍性を極めすぎても、ほかの面と両立しなくなるので難しい…",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学的思考と高校倫理学の難しさ"
    ]
  },
  {
    "objectID": "Rinri/2Tetsugakutekisikou.html#合理的判断とは",
    "href": "Rinri/2Tetsugakutekisikou.html#合理的判断とは",
    "title": "２　哲学的思考と高校倫理の難しさ",
    "section": "",
    "text": "合理的判断に必要な要素は３つ\n\n事実と価値の区別\n「～である」は事実、「～であるべき」は価値\n事実判断から価値判断は直に出ない。\n\n\n\n\n\n\n警告注意\n\n\n\nEx）「昔から牛を使っている」（事実）\n　　　　　　　↓\n「牛を利用してよい」（価値）\nこの論理の持って生き方は合理的ではない。\n\n\n判断の一貫性\n道徳的に重要な違いがない限り、全てにおいて一貫性がある。\n公平な視点\n自己中心的ではなくて、普遍な判断をする。 ただし、普遍性を極めすぎても、ほかの面と両立しなくなるので難しい…",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学的思考と高校倫理学の難しさ"
    ]
  },
  {
    "objectID": "Rinri/2Tetsugakutekisikou.html#政経部門とちがい教科書や資料集を読んでもよくわからない",
    "href": "Rinri/2Tetsugakutekisikou.html#政経部門とちがい教科書や資料集を読んでもよくわからない",
    "title": "２　哲学的思考と高校倫理の難しさ",
    "section": "政経部門とちがい、教科書や資料集を読んでもよくわからない",
    "text": "政経部門とちがい、教科書や資料集を読んでもよくわからない\n高校倫理を教えるうえで、上記の哲学的思考は、生徒が身に着けるべき思考法である。しかしながら、哲学的思考はとても難しく、高校生どころか大人でも難しい。\n哲学者の思考は、すべてこの思考法に基づいているわけであるが、この思考法を失念してしまうと、ただでさえ難しい文章が理解不能な文章と化す。教員も、この思考法は失念しがちであり、生徒ともに哲学の泥沼へハマっていく。\nそうして暗記中心の活動になっていき、倫理の内容が多すぎることもあり、適切な思考力を養成できない場合が多い。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学的思考と高校倫理学の難しさ"
    ]
  },
  {
    "objectID": "Rinri/2Tetsugakutekisikou.html#課題問題ベースと思想史ベースの兼ね合いがむずかしい",
    "href": "Rinri/2Tetsugakutekisikou.html#課題問題ベースと思想史ベースの兼ね合いがむずかしい",
    "title": "２　哲学的思考と高校倫理の難しさ",
    "section": "「課題・問題ベース」と「思想史ベース」の兼ね合いがむずかしい",
    "text": "「課題・問題ベース」と「思想史ベース」の兼ね合いがむずかしい\n「主体的・対話的・深い学び」が目標であるにもかかわらず、内容は思想史が中心になってしまう。基礎的な概念や理論の把握がないと対話の効果は限定的だと思うけど、そうした把握をさせているだけで時間が溶けていく。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学的思考と高校倫理学の難しさ"
    ]
  },
  {
    "objectID": "Rinri/2Tetsugakutekisikou.html#抽象的な話になるので生徒の関心を維持できない",
    "href": "Rinri/2Tetsugakutekisikou.html#抽象的な話になるので生徒の関心を維持できない",
    "title": "２　哲学的思考と高校倫理の難しさ",
    "section": "抽象的な話になるので、生徒の関心を維持できない",
    "text": "抽象的な話になるので、生徒の関心を維持できない\n「具体」⇔「抽象」が大事な気がするが難しい。そもそも何が（哲学的に）問題なのか理解させにくいことがあるほか、具体的な問題には関心を引けても、それについての抽象的考察まで関心を維持しにくい。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学的思考と高校倫理学の難しさ"
    ]
  },
  {
    "objectID": "Rinri/2Tetsugakutekisikou.html#reason理性理由への信頼",
    "href": "Rinri/2Tetsugakutekisikou.html#reason理性理由への信頼",
    "title": "２　哲学的思考と高校倫理の難しさ",
    "section": "reason（理性・理由）への信頼",
    "text": "reason（理性・理由）への信頼\n往々にして哲学は「理性・理由」を重視する。そのため、「感覚としては受けいれがたいが理性・理由に従うとこうならざるをえない」という議論もある。これを学ぶ際にどのようにして付き合うのか。",
    "crumbs": [
      "Home",
      "哲学・倫理学",
      "哲学的思考と高校倫理学の難しさ"
    ]
  },
  {
    "objectID": "Shizenchirigaku/2Taikijyunkan.html",
    "href": "Shizenchirigaku/2Taikijyunkan.html",
    "title": "２　大気循環",
    "section": "",
    "text": "地球は、ハビタブルゾーンにあり、生命維持に必要な液体の水が存在できる地域である。\n\n\n\n\n\n\nノートハビタブルゾーン\n\n\n\nある天体で生命が発生しうる、発生した生命を維持しうる可能性のある宇宙空間。つまり、太陽の光によって熱くなり過ぎず、かつ光が届かな過ぎて寒くなりすぎず、液体の水が存在できる地域であり、太陽系では地球と火星付近を指す。\n\n\nしかし、ここにあっても地球の温度は現在の気温まで上がらない。\n\n\n地球内部で太陽光を吸収するものは、植物程度であり、太陽から放射されるエネルギーと比較すれば、計算に影響ないレベルでほぼゼロといってよい。\nよって、太陽の放射エネルギーは地球の放射エネルギーと変わらない(放射平衡)といえて、以下の式が成り立つ。\n\\[\n\\LARGE I \\pi r^2 (1 - A) = 4 \\pi r^2 \\sigma T^4\n\\tag{1}\\]\n左辺が太陽の放射エネルギー、右辺が地球が放射するエネルギーである。\n\n\\(I = 1.37 \\times 10^3 W/m^2\\) ：太陽定数\n\\(T\\) : 地球の表面温度（絶対温度 K）\n\\(\\sigma = 5.67 \\times 10^{-8} \\text{ W/m}^2\\text{K}^4\\) : シュテファン・ボルツマン定数 （表面温度から放射エネルギーに変換する定数）\n\\(r\\) : 地球の半径\n\\(A = 0.3\\) : 地球の反射率\n\n\\(T\\) について計算すると、地球の表面温度がわかる\nとくと、\\(T = 255(K)\\), すなわち \\(-18{}^\\circ c\\) となる。\n\\(-18{}^\\circ c\\) では、水は液体では存在できず、生命維持はできない。\nこのように、ハビタブルゾーンだけでは、生命の維持は説明できないのである。\n\n\n\n\n\n\n注意放射平衡\n\n\n\nここは難しいので覚えなくてもよい。温室効果なしでは、生命維持に必要な温度を確保できないことがわかればOK\n\n\n\n\n\n太陽からの日射エネルギーが大気を通過して地表面に吸収される。加熱された地表面から、熱が地球外に向けて放射される。その時に、温室効果ガスが熱を吸収するため、地球から逃げないため、暖かくなる。このため、\\(-18{}^\\circ c\\) にならずに地球は生命が維持できている。これが、火星と地球の違いである。\n\n\n\n温室効果の仕組み",
    "crumbs": [
      "Home",
      "地理学",
      "大気大循環"
    ]
  },
  {
    "objectID": "Shizenchirigaku/2Taikijyunkan.html#温室効果がない場合の地球温度",
    "href": "Shizenchirigaku/2Taikijyunkan.html#温室効果がない場合の地球温度",
    "title": "２　大気循環",
    "section": "",
    "text": "地球内部で太陽光を吸収するものは、植物程度であり、太陽から放射されるエネルギーと比較すれば、計算に影響ないレベルでほぼゼロといってよい。\nよって、太陽の放射エネルギーは地球の放射エネルギーと変わらない(放射平衡)といえて、以下の式が成り立つ。\n\\[\n\\LARGE I \\pi r^2 (1 - A) = 4 \\pi r^2 \\sigma T^4\n\\tag{1}\\]\n左辺が太陽の放射エネルギー、右辺が地球が放射するエネルギーである。\n\n\\(I = 1.37 \\times 10^3 W/m^2\\) ：太陽定数\n\\(T\\) : 地球の表面温度（絶対温度 K）\n\\(\\sigma = 5.67 \\times 10^{-8} \\text{ W/m}^2\\text{K}^4\\) : シュテファン・ボルツマン定数 （表面温度から放射エネルギーに変換する定数）\n\\(r\\) : 地球の半径\n\\(A = 0.3\\) : 地球の反射率\n\n\\(T\\) について計算すると、地球の表面温度がわかる\nとくと、\\(T = 255(K)\\), すなわち \\(-18{}^\\circ c\\) となる。\n\\(-18{}^\\circ c\\) では、水は液体では存在できず、生命維持はできない。\nこのように、ハビタブルゾーンだけでは、生命の維持は説明できないのである。\n\n\n\n\n\n\n注意放射平衡\n\n\n\nここは難しいので覚えなくてもよい。温室効果なしでは、生命維持に必要な温度を確保できないことがわかればOK",
    "crumbs": [
      "Home",
      "地理学",
      "大気大循環"
    ]
  },
  {
    "objectID": "Shizenchirigaku/2Taikijyunkan.html#温室効果の仕組み",
    "href": "Shizenchirigaku/2Taikijyunkan.html#温室効果の仕組み",
    "title": "２　大気循環",
    "section": "",
    "text": "太陽からの日射エネルギーが大気を通過して地表面に吸収される。加熱された地表面から、熱が地球外に向けて放射される。その時に、温室効果ガスが熱を吸収するため、地球から逃げないため、暖かくなる。このため、\\(-18{}^\\circ c\\) にならずに地球は生命が維持できている。これが、火星と地球の違いである。\n\n\n\n温室効果の仕組み",
    "crumbs": [
      "Home",
      "地理学",
      "大気大循環"
    ]
  },
  {
    "objectID": "Shizenchirigaku/2Taikijyunkan.html#自転による影響",
    "href": "Shizenchirigaku/2Taikijyunkan.html#自転による影響",
    "title": "２　大気循環",
    "section": "自転による影響",
    "text": "自転による影響\n実際の大気循環は、地球の自転によってコリオリの力が働く。\n\n\n\n\n\n\nノートコリオリの力\n\n\n\n回転座標系上で移動した際に移動方向と垂直な方向に移動速度に比例した大きさで受ける慣性力のこと。反時計回りに回転する物体では右に働き、時計回りでは左に働く。\n\n\nそのため、実際の大気循環はグニャグニャである。\n\n\n\n大気循環の図 / 作成者：日本の気象庁 (JMA) / ライセンス：CC BY-SA 3.0\n\n\n\nハドレー循環\n\n\n\nハドレー循環\n\n\n\n\n\n\n\n\nノートハドレー循環\n\n\n\n赤道付近の地表面で温められた空気が上昇（上空10km-15km）し北上し、コリオリの力により東へ流される。北緯30度付近の上空では、西風となるが、赤道から空気塊が供給され続けるため、逃げ場を失った空気塊は、下降気流となって地表面に降下する。この循環をハドレー循環と呼ぶ。\n\n\nこの循環によって、北緯30°付近で中緯度高圧帯が形成される。ここで背の高い高気圧（＝太平洋高気圧）が形成される。この時点の太平洋高気圧は、高温・乾燥しているが、太平洋上を進むにつれ湿気を持ち、高温・多湿となり、夏に日本へやってくる。このようにして、上部は高温乾燥、下部は高温多湿の小笠原気団が形成される。\n降下した空気塊の一部は赤道付近の地表面の空気を補う形で赤道方向に動く。コリオリの力により北半球では右方向にずれる。この風を貿易風（偏東風）という。\n\n\n極循環\n\n\n\n極循環\n\n\n\n\n\n\n\n\nノート極循環\n\n\n\n高緯度帯（極付近）で冷たい空気が下降し、地表を低緯度（約60度付近）に向かって流れ、そこで上昇して上空を極へ戻る。このような高緯度域で起こる空気の循環を極循環という。\n\n\n北極や南極周辺は地球上で最も太陽からうけるエネルギーが小さく、気温が低いため、地表面周辺（上空1000m～2000mまでの大気境界層）の空気は冷やされ、体積が小さくなり、大気密度が上昇し、下降気流が発生する（極高圧帯）。そのあと、極地や中緯度高圧帯から地表を動いてきた空気が集まり、上昇気流が発生（暖かい空気）する（高緯度低圧帯）。これによって、生じるのが、低温で乾燥した高気圧を有するシベリア気団である。\n地表に降りた空気は、地表面を低緯度側へ動く。この風を極偏東風という。\n\n\n\n\n\n\nヒント直接循環\n\n\n\nハドレー循環と極循環は、直接的な南北の熱移動であり、これを直接循環という。\n\n\n\n\nフェレル循環\n\n\n\nフェレル循環\n\n\n\n\n\n\n\n\nノートフェレル循環\n\n\n\n低緯度地帯の暖気が北上すると同時に徐々に上昇する。高緯度地帯の上空の寒気が南下すると同時に下降する。この循環をフェレル循環という。\n\n\n緯度約30度付近（中緯度高圧帯）で降下した空気塊の一部は高緯度方向へ移動する。 コリオリの力により北半球では右方向にずれ、南から北へ向かう風が西風（偏西風）に変わる。 緯度約60度付近で、上昇する。\n\n\n\n\n\n\nヒント間接循環\n\n\n\nフェレル循環は、大気の熱源に直接駆動されるのではなく、低緯度のハドレー循環と高緯度の極循環の間に挟まれて生じる（見かけ上の）循環になる。",
    "crumbs": [
      "Home",
      "地理学",
      "大気大循環"
    ]
  },
  {
    "objectID": "Shizenchirigaku/3Keppen.html",
    "href": "Shizenchirigaku/3Keppen.html",
    "title": "３　ケッペンの気候区分",
    "section": "",
    "text": "ケッペン(Koppen W. P.)が考案した気候区分。植生分布に注目している点が特徴。\n\n\n\nケッペンの気候区分\n\n\n\nこの図は、Köppen World Map (retouched version) を元にしています。  作者は Ali Zifan であり、 CC BY-SA 3.0 ライセンスの下で利用可能です。 （原データ: M. Kottek, J. Grieser, C. Beck, B. Rudolf und F. Rubel (2006) の論文）\n\n\n\n\n\n\n\n最寒月の気温により区分\nA（熱帯）：最寒月が18℃以上\nC（温帯）：最寒月が-3℃以上18℃未満\nD（亜寒帯）：最寒月が-3℃以下\n\n\n\n降水量の少ない地域と気温が低い気候に区分\nB（乾燥帯）：乾燥限界未満の年平均雨量\nE（寒帯）：最暖月平均気温が10℃未満\n\n\n\n\nA（熱帯）、C（温帯）、D（冷帯）には更に区分あり\n\n\n\n\n\n\n\n\n\n\n小文字\n項目\n最暖月\n最寒月\n備考\n\n\n\n\na\n夏高温\n22℃以上\n\n\n\n\nb\n夏冷温\n22℃以下\n\n10℃以上 4カ月以上\n\n\nc\n冬低温\n10℃以上 4カ月未満\n－38℃以上\n\n\n\nd\n\n\n－38℃以上\n\n\n\nf\n\n年中 (各月) 多雨\n\n著しい乾燥なし\n\n\ns\n\n夏に少雨\n\n最乾燥月雨量 × 3 ＜ 最湿潤月雨量\n\n\nw\n\n冬に少雨\n\n最乾燥月雨量 × 10 ＜ 最湿潤月雨量\n\n\nm\n\nf と w の中間型 (Mittel) の意\n\nケッペンのを修正した m₁, m₂ の場合はモンスーン monsoon の影響が大きい地域\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n区 分\n最寒月\n最暖月\n気候区分名\n特 徴\n\n\n\n\n熱帯 A\n18℃以上\n\nAf 熱帯雨林気候\n最小雨月 60 mm 以上\n\n\n\n18℃以上\n\nAm 熱帯モンスーン気候\n最小雨月 60 mm 未満、年降水量多い\n\n\n\n18℃以上\n\nAw サバナ気候\n乾季が長く年降水量が少ない\n\n\n温帯 C\n18℃〜－3℃\n\nCw 温帯冬少雨気候\n温暖で冬は少雨\n\n\n\n18℃〜－3℃\n\nCfa 温帯温暖湿潤気候\n夏は多雨、冬乾燥\n\n\n\n18℃〜－3℃\n\nCfb 西岸海洋性気候\n一年を通じて雨がある\n\n\n\n18℃〜－3℃\n\nCs 地中海性気候\n夏は乾燥、冬降雨\n\n\n冷帯 D\n－3℃以下\n10℃以上 4カ月以上\nDf 亜寒帯湿潤気候\n大陸性混交林気候、降雨割合多い\n\n\n\n－3℃以下\n10℃以上 3カ月未満\nDw 亜寒帯冬少雨気候\n針葉樹林（タイガ）気候、降雨小\n\n\n寒帯 E\n－3℃以下\n月の平均気温により\nET ツンドラ気候\nTundra 降水量少ない、夏のみ地表が融け、植物みられる\n\n\n\n－3℃以下\n0℃以下\nEF 氷雪気候\nFrost 植物なし、氷雪地域\n\n\n乾燥帯 B\n\n月の降水量により\nBS ステップ気候\n年降水量がややある\n\n\n\n\n\nBW 砂漠気候\n年降水量きわめて少ない\n\n\n高地気候\n常春的な温暖な気候\n\nG 山地気候\n標高 2,000〜3,000 m の高地\n\n\n(ケッペンの区分にはない)\n\n\nH 高山気候\n標高 3,000 m 以上の高地\n\n\n\n\n\nケッペンの気候区分を補正し設定したものである。海抜の高い地域は、気温の逓減率の関係上、同緯度の低地より低温となり、熱帯地方の高山（標高2000～3000ｍ）は、常春の気候ともいえるほど暖かくなる。",
    "crumbs": [
      "Home",
      "地理学",
      "ケッペンの気候区分"
    ]
  },
  {
    "objectID": "Shizenchirigaku/3Keppen.html#分類基準",
    "href": "Shizenchirigaku/3Keppen.html#分類基準",
    "title": "３　ケッペンの気候区分",
    "section": "",
    "text": "最寒月の気温により区分\nA（熱帯）：最寒月が18℃以上\nC（温帯）：最寒月が-3℃以上18℃未満\nD（亜寒帯）：最寒月が-3℃以下\n\n\n\n降水量の少ない地域と気温が低い気候に区分\nB（乾燥帯）：乾燥限界未満の年平均雨量\nE（寒帯）：最暖月平均気温が10℃未満\n\n\n\n\nA（熱帯）、C（温帯）、D（冷帯）には更に区分あり\n\n\n\n\n\n\n\n\n\n\n小文字\n項目\n最暖月\n最寒月\n備考\n\n\n\n\na\n夏高温\n22℃以上\n\n\n\n\nb\n夏冷温\n22℃以下\n\n10℃以上 4カ月以上\n\n\nc\n冬低温\n10℃以上 4カ月未満\n－38℃以上\n\n\n\nd\n\n\n－38℃以上\n\n\n\nf\n\n年中 (各月) 多雨\n\n著しい乾燥なし\n\n\ns\n\n夏に少雨\n\n最乾燥月雨量 × 3 ＜ 最湿潤月雨量\n\n\nw\n\n冬に少雨\n\n最乾燥月雨量 × 10 ＜ 最湿潤月雨量\n\n\nm\n\nf と w の中間型 (Mittel) の意\n\nケッペンのを修正した m₁, m₂ の場合はモンスーン monsoon の影響が大きい地域\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n区 分\n最寒月\n最暖月\n気候区分名\n特 徴\n\n\n\n\n熱帯 A\n18℃以上\n\nAf 熱帯雨林気候\n最小雨月 60 mm 以上\n\n\n\n18℃以上\n\nAm 熱帯モンスーン気候\n最小雨月 60 mm 未満、年降水量多い\n\n\n\n18℃以上\n\nAw サバナ気候\n乾季が長く年降水量が少ない\n\n\n温帯 C\n18℃〜－3℃\n\nCw 温帯冬少雨気候\n温暖で冬は少雨\n\n\n\n18℃〜－3℃\n\nCfa 温帯温暖湿潤気候\n夏は多雨、冬乾燥\n\n\n\n18℃〜－3℃\n\nCfb 西岸海洋性気候\n一年を通じて雨がある\n\n\n\n18℃〜－3℃\n\nCs 地中海性気候\n夏は乾燥、冬降雨\n\n\n冷帯 D\n－3℃以下\n10℃以上 4カ月以上\nDf 亜寒帯湿潤気候\n大陸性混交林気候、降雨割合多い\n\n\n\n－3℃以下\n10℃以上 3カ月未満\nDw 亜寒帯冬少雨気候\n針葉樹林（タイガ）気候、降雨小\n\n\n寒帯 E\n－3℃以下\n月の平均気温により\nET ツンドラ気候\nTundra 降水量少ない、夏のみ地表が融け、植物みられる\n\n\n\n－3℃以下\n0℃以下\nEF 氷雪気候\nFrost 植物なし、氷雪地域\n\n\n乾燥帯 B\n\n月の降水量により\nBS ステップ気候\n年降水量がややある\n\n\n\n\n\nBW 砂漠気候\n年降水量きわめて少ない\n\n\n高地気候\n常春的な温暖な気候\n\nG 山地気候\n標高 2,000〜3,000 m の高地\n\n\n(ケッペンの区分にはない)\n\n\nH 高山気候\n標高 3,000 m 以上の高地\n\n\n\n\n\nケッペンの気候区分を補正し設定したものである。海抜の高い地域は、気温の逓減率の関係上、同緯度の低地より低温となり、熱帯地方の高山（標高2000～3000ｍ）は、常春の気候ともいえるほど暖かくなる。",
    "crumbs": [
      "Home",
      "地理学",
      "ケッペンの気候区分"
    ]
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "",
    "text": "木戸孝允「国の富強は人民の富強」\n\n\n\n江戸時代の身分制度をうち破る画期的なもの\n身分の壁を越えて、能力が発揮できない江戸時代\n\n福沢諭吉 「門閥制度は親の敵である」\n\n学制では、小学校建設は地元の出資で建設\n明治13年　明治天皇巡礼　文明開化の視察 　　→小学校はその中でも重要な施設\n\n\n\n小学校では、男女共学で、成績順に席が並ぶ　↔︎身分順だった江戸時代\n教科書は高価　→黒板に掛図をかける（アメリカでよく行われていたものを輸入）\n\n\n\n進級には試験の合格が必要　試験に追われる小学生だった\n問答試験と口述試験　公平性担保のため、試験は公開され、役人や保護者などの立会人がいた\n子どもの考えではなく、暗唱が求められた。立会人の役人も口頭試問\n日本の未来を担う優秀な子どもたちを選別\n身分などとは関係なく努力の成績による評価で決まる　→四民平等を象徴・努力すれば評価されるということを子どもたちに実感させる\n沢柳政太郎　文部省　まだコネ入省が多い時代に能力を買われて入省できた\n\n\n\nまだ尋常小学校は324万人で、上がれば上がるほど少なくなっていく。帝国大学卒は無試験で官僚へなれた\n立身出世は、試験を勝ち抜けるかで決まる\n学歴階層の形成　帝国大学への進学が目指された &gt; 学歴を積んで上に上がることが最良\nという価値観が出来上がった。\n→学歴社会の形成で、倒れる子どもたちも\n経済的な負担で就学率は伸び悩むほか、試験の弊害で不登校も1/5に上る\n\n\n\n沢柳政太郎\n\n見かけの就学率は上がっても、不登校が多い これは、教育行政が、小学教育の普及ばかりに目が行き、有効性がないことを理解していない\n\n\n\n\n小学校の授業料無償化\n国語科の新設　科目の統廃合で授業数削減\n小学生で教える漢字数の制限\n運動場の設置が義務化　体育科新設必修化 &gt; 心身のバランスよい発育を目指す\n進級試験を廃止　授業によって成績を付ける &gt; 競争心で心身の発育を害し、試験のための勉強を避けたい\n\n→明治期の終わりに就学率は98％まであがる\n一人ひとりの個性を大事にしたいという沢柳の思い #### 課題 * 代わりに中学校の入学試験で、試験偏重が始まってしまう\n→学歴社会の風潮から、中学校の倍率が上がる\n\n学力の低下がみられる　←軍部からも指摘 &gt; 成人は学歴相当の能力をもっていない。それは、記憶暗唱への偏重で、実践がおろそかだから\n\n明治後期には、このような声が聞こえてくる &gt; 試験のモチベーションは変わっていないなかで、明治のゆとり教育では試験準備ができないので、基礎学力を強化すべきではないか\n教員アンケートの結果 * 個性無視　努力などで評価したい * 記憶や試験偏重"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#明治",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#明治",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "",
    "text": "木戸孝允「国の富強は人民の富強」\n\n\n\n江戸時代の身分制度をうち破る画期的なもの\n身分の壁を越えて、能力が発揮できない江戸時代\n\n福沢諭吉 「門閥制度は親の敵である」\n\n学制では、小学校建設は地元の出資で建設\n明治13年　明治天皇巡礼　文明開化の視察 　　→小学校はその中でも重要な施設\n\n\n\n小学校では、男女共学で、成績順に席が並ぶ　↔︎身分順だった江戸時代\n教科書は高価　→黒板に掛図をかける（アメリカでよく行われていたものを輸入）\n\n\n\n進級には試験の合格が必要　試験に追われる小学生だった\n問答試験と口述試験　公平性担保のため、試験は公開され、役人や保護者などの立会人がいた\n子どもの考えではなく、暗唱が求められた。立会人の役人も口頭試問\n日本の未来を担う優秀な子どもたちを選別\n身分などとは関係なく努力の成績による評価で決まる　→四民平等を象徴・努力すれば評価されるということを子どもたちに実感させる\n沢柳政太郎　文部省　まだコネ入省が多い時代に能力を買われて入省できた\n\n\n\nまだ尋常小学校は324万人で、上がれば上がるほど少なくなっていく。帝国大学卒は無試験で官僚へなれた\n立身出世は、試験を勝ち抜けるかで決まる\n学歴階層の形成　帝国大学への進学が目指された &gt; 学歴を積んで上に上がることが最良\nという価値観が出来上がった。\n→学歴社会の形成で、倒れる子どもたちも\n経済的な負担で就学率は伸び悩むほか、試験の弊害で不登校も1/5に上る\n\n\n\n沢柳政太郎\n\n見かけの就学率は上がっても、不登校が多い これは、教育行政が、小学教育の普及ばかりに目が行き、有効性がないことを理解していない\n\n\n\n\n小学校の授業料無償化\n国語科の新設　科目の統廃合で授業数削減\n小学生で教える漢字数の制限\n運動場の設置が義務化　体育科新設必修化 &gt; 心身のバランスよい発育を目指す\n進級試験を廃止　授業によって成績を付ける &gt; 競争心で心身の発育を害し、試験のための勉強を避けたい\n\n→明治期の終わりに就学率は98％まであがる\n一人ひとりの個性を大事にしたいという沢柳の思い #### 課題 * 代わりに中学校の入学試験で、試験偏重が始まってしまう\n→学歴社会の風潮から、中学校の倍率が上がる\n\n学力の低下がみられる　←軍部からも指摘 &gt; 成人は学歴相当の能力をもっていない。それは、記憶暗唱への偏重で、実践がおろそかだから\n\n明治後期には、このような声が聞こえてくる &gt; 試験のモチベーションは変わっていないなかで、明治のゆとり教育では試験準備ができないので、基礎学力を強化すべきではないか\n教員アンケートの結果 * 個性無視　努力などで評価したい * 記憶や試験偏重"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#大正",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#大正",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "大正",
    "text": "大正\n\n沢柳政太郎の実験\n「自由教育」\n興味関心を重視した一斉授業ではない教育 　受験対策をせず、成績もつけない\n一時的にブームに"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#昭和",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#昭和",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "昭和",
    "text": "昭和\n自由教育は、戦争で下火に"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#戦後",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#戦後",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "戦後",
    "text": "戦後\nGHQ占領下の日本\n\n第一次米国教育使節団\n試験第一主義を修正すべき &gt; 軍国主義でなかったとしても、日本の教育は改革しなければならなかった。試験偏重で、受験準備にとらわれた制度は、批判的判断の自由を奪い、当局者の操縦に容易に身を任せてしまうことになるだろう"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#アメリカは日本の教育制度のどこに問題があると分析したか",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#アメリカは日本の教育制度のどこに問題があると分析したか",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "アメリカは日本の教育制度のどこに問題があると分析したか",
    "text": "アメリカは日本の教育制度のどこに問題があると分析したか\n\n学校における勅語の朗読・御真影の奉拝等の式を挙げることは望ましくない\n学校管理が中央集権的\nカリキュラムが不自由\nつめこみ主義　←暗記偏重\n画一主義　← 「一斉授業」\n忠孝のような上長への服従\n→ 思考の独立・個性の発展及び民主的公民としての権利と責任が欠落\n型通りの試験では試され得ぬ深い知識が欠落　←試験偏重\n高等教育の閉鎖化で少数者の特権化\n高等教育機関における教授の経済的および学問的自由がない\n図書館施設の不足"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#第一次米国教育使節団はどのように改革しようとしたか",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#第一次米国教育使節団はどのように改革しようとしたか",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "第一次米国教育使節団は、どのように改革しようとしたか",
    "text": "第一次米国教育使節団は、どのように改革しようとしたか\n\n課税で維持し、男女共学制を採り、かつ授業料無徴収の学校における義務教育の引上げをなし、修業年限を九か年に延長、換言すれば生徒が十六歳に達するまで教育を施す年限延長（現在の義務教育制度）\n三年制の「上級中等学校」をも設置し、授業料は無徴収、ゆくゆくは男女共学制を採り、初級中等学校よりの進学希望者全部に種々の学習の機会が提供されるようにすべき（現在の高校）\n教育委員会の設置と教育委員会の委員の公選制\n各自に思考の独立・個性の発展および民主的公民としての権利と責任とを、助長するようにすべき\n高等教育機関における教授の経済的および学問的自由の確立 （日本国憲法 学問の自由）\n有能な男女で学資の無いため研究を続けられぬ人々に、続いて研究ができるよう確実に保証してやるための、財政的援助（現在の奨学金制度）"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#第二次米国教育使節団は第一次案をどう変化させたのか",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#第二次米国教育使節団は第一次案をどう変化させたのか",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "第二次米国教育使節団は、第一次案をどう変化させたのか",
    "text": "第二次米国教育使節団は、第一次案をどう変化させたのか\n\n道徳および精神教育　われわれは日本に来てから、新教育が道徳的および精神的支柱を失っているということを聞かされた。しかしこうした見解は、個人生活の一面のみを見ているからかも知れない。\n　道徳的または精神的価値は、われわれの周囲のいたるところにある。われわれは、それを家庭生活や学校生活の中に見出すことができるのである。教師は青少年の日常経験の中にそれらの価値を生かし、あらゆる学習活動も単に知力の発達だけでなく、徳性の完成に役立たすことができるのである。道徳教育は、ただ杜会科だけからくるものだと考えるのは無意味で、それは全教育課程を通じて力説されなければならない。\n\n\n国は中央集権化の方向へ再び進んでいるが、教育委員会は地方分権のままであるべき"
  },
  {
    "objectID": "Kyouikuseidoronn/2KyouikuSeidoronn.html#日本の教育制度の中心的役割を果たしている試験はなぜアメリカの意図とは違い是正されないまま現在まで持続しているのか",
    "href": "Kyouikuseidoronn/2KyouikuSeidoronn.html#日本の教育制度の中心的役割を果たしている試験はなぜアメリカの意図とは違い是正されないまま現在まで持続しているのか",
    "title": "教区制度論 〜日本の教育制度の歴史と課題〜",
    "section": "日本の教育制度の中心的役割を果たしている試験は、なぜアメリカの意図とは違い、是正されないまま現在まで持続しているのか",
    "text": "日本の教育制度の中心的役割を果たしている試験は、なぜアメリカの意図とは違い、是正されないまま現在まで持続しているのか\n戦後、アジア各国が共産化していく\n→ 国民の個性の自由を尊重する第一次案では、日本は共産化するおそれがある\n\n米国にとって、日本は扱いやすい国でありたい\n共産主義の防波堤にしたい\n\n教育は、従来の画一的な詰め込み教育・試験偏重へ戻される。\nコチラの方が、上長の言うことを聞いてくれる人間が生まれる。\n昭和58年　中教審答申にて、戦前の軍国教育を取り除いたVer.のシン・詰め込み教育が完成\n\n教育委員会の公選制を任命制へ戻す\n道徳教育の復活\n国定教科書の復活\n学習指導要領の復活\n\n\n令和８年文科省答申にて、かなり自由教育的な改革が始まる予定\nこの詰め込み教育の脱却から戦後約80年かかった。\n教育制度論トップに戻る\nトップページに戻る"
  },
  {
    "objectID": "Kyouikuseidoronn/index.html",
    "href": "Kyouikuseidoronn/index.html",
    "title": "教育制度論",
    "section": "",
    "text": "教育制度論\nこの資料は、2025年高知工科大学において開講された教員養成科目「教育制度論（永国寺 経済マネジメント学群むけ）」（講師：中村直人教授）を基に、藤井が再構成したものである。"
  },
  {
    "objectID": "Kyouikuseidoronn/index.html#明治期の改革と米国教育使節団の改革",
    "href": "Kyouikuseidoronn/index.html#明治期の改革と米国教育使節団の改革",
    "title": "教育制度論",
    "section": "明治期の改革と米国教育使節団の改革",
    "text": "明治期の改革と米国教育使節団の改革\n教育制度論２　明治期の改革と米国教育使節団の改革"
  },
  {
    "objectID": "Kyouikuseidoronn/index.html#アメリカの教育制度",
    "href": "Kyouikuseidoronn/index.html#アメリカの教育制度",
    "title": "教育制度論",
    "section": "アメリカの教育制度　",
    "text": "アメリカの教育制度　\n教育制度論３　 　\n\n戻る\nトップページに戻る"
  }
]